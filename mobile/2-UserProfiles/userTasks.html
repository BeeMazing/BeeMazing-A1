<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>BeeMazing Profile</title>
        <link
            href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap"
            rel="stylesheet"
        />
        <link rel="stylesheet" href="/BeeMazing-A1/shared/avatar-styles.css" />
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            :root {
                --primary-color: #ffc107;
                --secondary-color: #212121;
                --accent-color: #ffffff;
                --light-bg: #fffff8; /* light background */
                --text-color: #ffffff; /* white text */
                --danger-color: #d32f2f;
                --modal-bg: rgba(33, 33, 33, 0.7);
                --header-height: 68px;
                --footer-height: 70px;
                --border-dark: #444754; /* üëà Add this if not already present */
                --card-bg: #2a2b32;
                --cayenne-blue: #00b7eb;
            }
            body {
                font-family: "Poppins", Arial, sans-serif;
                background-color: var(--light-bg);
                color: #6d4c41;
                min-height: 100vh;
                overflow-y: auto;
                padding-bottom: var(--footer-height);
            }
            .header {
                background: linear-gradient(
                    135deg,
                    var(--primary-color),
                    #ffb300
                );
                padding: 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
                position: fixed;
                top: 0;
                width: 100%;
                height: var(--header-height);
                z-index: 100;
            }

            .title {
                font-size: 24px;
                font-weight: 600;
                color: var(--secondary-color);
                letter-spacing: 1px;
            }

            .content {
                position: absolute;
                top: 0;
                bottom: var(--footer-height);
                width: 100%;
                padding: 20px;
                overflow-y: auto;
                background-color: var(--light-bg); /* <-- Add this */
                background-image: url('data:image/svg+xml,%3Csvg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"%3E%3Ccircle cx="20" cy="20" r="2" fill="%23FFC107" fill-opacity="0.1"/%3E%3C/svg%3E');
                background-repeat: repeat;
                bottom: var(--footer-height);
            }

            .profile-card {
                background: #ffffff;
                border: 2px solid var(--primary-color);
                border-radius: 12px;
                box-shadow: 0 2px 8px rgba(255, 193, 7, 0.1);
                padding: 20px;
                text-align: center;
                width: 100%;
                max-width: 480px;
                margin: 0 auto;
                transition:
                    transform 0.3s ease,
                    box-shadow 0.3s ease;
            }
            .profile-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
            }
            .profile-card h1 {
                font-size: 32px;
                font-weight: 600;
                color: #6d4c41;
                margin-bottom: 15px;
            }
            .profile-card p {
                font-size: 18px;
                color: #6d4c41;
                margin-bottom: 20px;
            }
            .reward-container {
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 20px;
                margin-bottom: 20px;
            }
            #sellButton {
                background: var(--secondary-color);
                color: var(--accent-color);
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                margin-left: 20px;
                transition: background-color 0.3s ease;
            }
            #sellButton:hover {
                background: #424242;
            }
            .task-list {
                margin-top: 20px;
                display: grid;
                grid-template-columns: 1fr;
                gap: 5px;
                width: 100% !important;
                max-width: none !important;
                min-width: 0 !important;
                padding: 0 !important;
                margin-left: 0 !important;
                margin-right: 0 !important;
                box-sizing: border-box !important;
            }

            #userTasks,
            #allTasksList {
                width: 100% !important;
                max-width: 100% !important;
                min-width: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
                box-sizing: border-box !important;
                display: grid !important;
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
            .task-item {
                background-color: #ffffff;
                color: #6d4c41;
                padding: 16px;
                border: 2px solid var(--primary-color);
                border-radius: 12px;
                margin-bottom: 3px;
                cursor: pointer;
                position: relative;
                transition:
                    transform 0.3s ease,
                    box-shadow 0.3s ease;
                box-shadow: 0 2px 8px rgba(255, 193, 7, 0.1);
            }

            .task-item:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
            }
            .finished-btn {
                background: var(--primary-color);
                color: #6d4c41;
                border: none;
                padding: 12px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                margin-top: 10px;
                transition: background-color 0.3s ease;
            }
            .finished-btn:hover {
                background: #ffd54f;
                color: #6d4c41;
            }

            .footer {
                position: fixed;
                bottom: 0;
                width: 100%;
                display: flex;
                justify-content: space-around;
                align-items: center;
                background: var(--secondary-color);
                padding: 10px 0;
                box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
                z-index: 100;
                height: var(--footer-height);
            }
            .footer a {
                text-decoration: none;
                color: var(--text-color);
                display: flex;
                flex-direction: column;
                align-items: center;
                transition: transform 0.3s ease;
            }
            .footer a:hover {
                transform: scale(1.1);
            }
            .footer-icon img {
                width: 40px;
                height: 40px;
                filter: invert(100%) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
            }
            .footer a.active img {
                filter: invert(77%) sepia(88%) saturate(900%) hue-rotate(0deg)
                    brightness(100%) contrast(100%)
                    drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2)) !important;
            }
            .footer-icon span {
                font-size: 12px;
                margin-top: 5px;
                font-weight: 600;
            }
            .footer a.active span {
                color: var(--primary-color);
            }
            @media (max-width: 600px) {
                .footer-icon img {
                    width: 20px;
                    height: 20px;
                }
            }

            .tab-button {
                background-coloor: var(--light-bg) !important;
                color: #6d4c41 !important;
                border: 2px solid var(--primary-color) !important;
                font-weight: 600;
                font-size: 1.2rem;
                transition: all 0.3s ease;
                text-decoration: none;
                opacity: 0.6;
            }

            .tab-button:hover {
                background-color: rgba(255, 193, 7, 0.1) !important;
                transform: translateY(-1px);
            }

            .tab-button.active {
                background-color: var(--primary-color) !important;
                color: #6d4c41 !important;
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
                opacity: 1;
            }

            .tab-content.hidden {
                display: none;
            }

            /* Ensure consistent tab container widths and layouts */
            .tab-content {
                width: 100% !important;
                max-width: 100% !important;
                box-sizing: border-box !important;
                margin: 0 !important;
                padding: 0 !important;
            }

            /* Force consistent container dimensions */
            #myTasks,
            #allTasks {
                width: 100% !important;
                max-width: 100% !important;
                min-width: 0 !important;
                box-sizing: border-box !important;
                margin: 0 !important;
                padding: 0 !important;
            }

            /* Ensure task list containers have identical layouts */
            #userTasks,
            #allTasksList {
                width: 100% !important;
                max-width: 100% !important;
                min-width: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
                box-sizing: border-box !important;
                display: grid !important;
                grid-template-columns: 1fr !important;
                gap: 5px !important;
            }

            /* Utility classes for tab layout */
            .flex {
                display: flex;
            }

            .justify-center {
                justify-content: center;
            }

            .mb-4 {
                margin-bottom: 1rem;
            }

            .px-4 {
                padding-left: 1rem;
                padding-right: 1rem;
            }

            .py-2 {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
            }

            .rounded-l-lg {
                border-top-left-radius: 0.5rem;
                border-bottom-left-radius: 0.5rem;
            }

            .rounded-r-lg {
                border-top-right-radius: 0.5rem;
                border-bottom-right-radius: 0.5rem;
            }

            .shadow-md {
                box-shadow:
                    0 4px 6px -1px rgba(0, 0, 0, 0.1),
                    0 2px 4px -1px rgba(0, 0, 0, 0.06);
            }

            .modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: var(--modal-bg);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                animation: fadeIn 0.3s ease-out;
            }
            .modal-content,
            .sell-modal-content {
                background: #fffff8;
                padding: 25px;
                border-radius: 12px;
                width: 100%;
                max-width: 420px;
                max-height: 85vh;
                overflow-y: auto;
                text-align: left;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                border: 2px solid #fbb740;
                color: #5d4e41;
                font-family: "Poppins", Arial, sans-serif;
            }
            .modal-content strong,
            .sell-modal-content strong {
                color: #5d4e41;
                font-weight: 600;
                font-size: 12px;
            }
            .modal-content h2 {
                color: #5d4e41;
                margin: 0 0 12px 0;
                font-size: 16px;
                font-weight: 600;
                border-bottom: 2px solid #fbb740;
                padding-bottom: 6px;
            }
            .task-info-row {
                padding: 8px 0;
                border-bottom: 1px solid #fff6e9;
                font-size: 12px;
                display: flex;
                align-items: center;
                flex-wrap: wrap;
                gap: 4px;
                min-height: 32px;
            }
            .task-info-row strong {
                min-width: fit-content;
                margin-right: 8px;
            }
            .task-info-row .avatar-container {
                display: flex;
                align-items: center;
                flex-wrap: wrap;
                gap: 2px;
                flex: 1;
            }
            .task-info-row:last-child {
                border-bottom: none;
            }
            .task-progress {
                background: #fff6e9;
                padding: 10px 12px;
                border-radius: 6px;
                margin: 10px 0;
                font-weight: 500;
                color: #5d4e41;
                border-left: 3px solid #fbb740;
            }

            @keyframes fadeIn {
                0% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }
            .honey-drop {
                position: fixed;
                width: 15px;
                height: 20px;
                background: radial-gradient(
                    circle,
                    #ffb300 30%,
                    var(--primary-color) 70%
                );
                border-radius: 50% 50% 70% 70%;
                animation: rain 1.5s linear forwards;
                z-index: 1001;
                pointer-events: none;
            }
            @keyframes rain {
                0% {
                    transform: translateY(-20vh);
                    opacity: 1;
                }
                100% {
                    transform: translateY(120vh);
                    opacity: 0.5;
                }
            }

            @keyframes floatUp {
                0% {
                    transform: translate(-50%, -50%) scale(0.5);
                    opacity: 0;
                }
                20% {
                    transform: translate(-50%, -50%) scale(1);
                    opacity: 1;
                }
                80% {
                    transform: translate(-50%, -70%) scale(1);
                    opacity: 1;
                }
                100% {
                    transform: translate(-50%, -90%) scale(0.8);
                    opacity: 0;
                }
            }
            .pulse {
                animation: pulse 1s ease-in-out;
            }
            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.2);
                }
                100% {
                    transform: scale(1);
                }
            }
            @media (max-width: 480px) {
                .profile-card {
                    max-width: 100%;
                    padding: 15px;
                }
                .reward-container {
                    flex-direction: column;
                    gap: 10px;
                }
                #sellButton {
                    margin-left: 0;
                    width: 100%;
                }
            }

            .date-header {
                background: var(--secondary-color);
                position: fixed; /* <--- change from sticky to fixed */
                top: 0;
                width: 100%;
                z-index: 50;
                padding: 5px 0;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            }
            .month-nav {
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 4px 0;
                font-weight: bold;
                font-size: 18px;
                color: var(--accent-color); /* white text */
            }
            .month-nav button {
                background: var(--secondary-color); /* dark background */
                border: none;
                color: var(--accent-color); /* white text */
                padding: 4px 10px;
                font-size: 16px;
                border-radius: 8px;
                margin: 0 8px;
                cursor: pointer;
            }

            .month-nav button:hover {
                background: var(--primary-color); /* yellow on hover */
                color: var(--secondary-color); /* black text */
            }

            /* Date picker start point */

            .day-scroll-wrapper {
                display: flex;
                align-items: center;
                position: relative;
                background: transparent;
                padding: 6px 0;
                overflow: hidden;
            }
            .day-scroll {
                display: flex;
                overflow-x: auto;
                padding: 6px 10px;
                gap: 8px;
                background: transparent;
                scroll-behavior: smooth;
            }
            .day-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                min-width: 38px;
            }
            .day-label {
                font-size: 10px;
                color: var(--accent-color); /* White text */
                text-align: center;
                margin-bottom: 2px;
                font-weight: 600;
            }
            .day {
                min-width: 38px;
                width: 38px;
                height: 38px;
                line-height: 38px;
                text-align: center;
                border-radius: 50%;
                background: var(--secondary-color); /* Black bubble */
                color: var(--accent-color); /* White text */
                font-weight: bold;
                cursor: pointer;
                flex-shrink: 0;
                transition:
                    background-color 0.3s,
                    transform 0.2s;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            }
            .day:hover {
                background: #fff3cd;
                transform: scale(1.08);
            }
            .day.selected {
                background: var(--primary-color); /* Yellow when selected */
                color: var(--secondary-color); /* Black text */
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            }
            .day-scroll::-webkit-scrollbar {
                display: none;
            }

            @keyframes celebrationPulse {
                0% {
                    transform: scale(1);
                    opacity: 1;
                }
                50% {
                    transform: scale(1.3);
                    opacity: 0.8;
                }
                100% {
                    transform: scale(1);
                    opacity: 1;
                }
            }

            /* Date picker end point */

            .scroll-btn {
                background: var(--secondary-color);
                border: none;
                color: var(--accent-color); /* White arrows */
                font-size: 20px;
                font-weight: bold;
                padding: 5px 10px;
                cursor: pointer;
                border-radius: 10px;
                margin: 0 5px;
            }

            @media (max-width: 600px) {
                .footer-icon img {
                    width: 35px;
                    height: 35px;
                }
            }

            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.1);
                }
                100% {
                    transform: scale(1);
                }
            }

            @keyframes flashBang {
                0% {
                    opacity: 0;
                }
                20% {
                    opacity: 1;
                }
                70% {
                    opacity: 1;
                }
                100% {
                    opacity: 0;
                }
            }

            .reward-reveal {
                animation: rewardAppear 0.8s ease-out;
                text-align: center;
                padding-top: 20px;
            }

            .reward-title {
                font-size: 26px;
                color: var(--primary-color);
                font-weight: 700;
                margin-bottom: 10px;
                animation: floatText 1s ease-out;
            }

            .reward-description {
                font-size: 16px;
                color: var(--accent-color);
                margin-bottom: 20px;
                animation: floatText 1.2s ease-out;
            }

            .claim-button {
                background: var(--primary-color);
                color: var(--secondary-color);
                border: none;
                padding: 12px 20px;
                font-size: 16px;
                font-weight: bold;
                border-radius: 10px;
                cursor: pointer;
                transition: background-color 0.3s ease;
            }

            .claim-button:hover {
                background-color: #ffd54f;
            }

            @keyframes rewardAppear {
                0% {
                    transform: scale(0.6);
                    opacity: 0;
                }
                60% {
                    transform: scale(1.05);
                    opacity: 1;
                }
                100% {
                    transform: scale(1);
                }
            }

            @keyframes rewardPulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.15);
                }
                100% {
                    transform: scale(1);
                }
            }

            @keyframes floatText {
                0% {
                    opacity: 0;
                    transform: translateY(20px);
                }
                100% {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            @keyframes fadeInOverlay {
                0% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }

            @keyframes chestZoomIn {
                0% {
                    opacity: 0;
                    transform: scale(0.8);
                }
                100% {
                    opacity: 1;
                    transform: scale(1);
                }
            }

            #chestVideoOverlay video {
                max-width: 90vw;
                max-height: 90vh;
                border-radius: 20px;
                box-shadow: 0 0 30px rgba(255, 193, 7, 0.6);
                background: #1a1a1a;
                display: block;
                animation: chestZoomIn 0.4s ease-out;
            }

            #changePasswordBtn {
                background: var(--primary-color);
                color: var(--secondary-color);
                border: none;
                padding: 12px 20px;
                font-size: 16px;
                font-weight: bold;
                border-radius: 10px;
                cursor: pointer;
                transition: background-color 0.3s ease;
                display: inline-block;
                margin-top: 10px;
                margin-bottom: 20px;
            }

            #changePasswordBtn:hover {
                background-color: #ffd54f;
            }

            #newAdminPassword {
                padding: 16px;
                font-size: 20px;
                width: 100%;
                margin-top: 18px;
                margin-bottom: 22px;
                border-radius: 10px;
                border: 2px solid var(--primary-color);
                background-color: var(--card-bg);
                color: var(--text-color);
            }

            #confirmChangePasswordBtn {
                background: var(--secondary-color);
                color: var(--accent-color);
                padding: 12px 20px;
                font-size: 16px;
                font-weight: bold;
                border-radius: 10px;
                cursor: pointer;
                width: 100%;
                transition: background-color 0.3s ease;
            }

            #confirmChangePasswordBtn:hover {
                background: #424242;
            }

            .modal-content {
                animation: zoomIn 0.3s ease-out;
            }

            @keyframes zoomIn {
                0% {
                    transform: scale(0.9);
                    opacity: 0;
                }
                100% {
                    transform: scale(1);
                    opacity: 1;
                }
            }

            /* Help Center notifications */

            #offerHelpBadge,
            #needHelpBadge {
                display: none;
                position: absolute;
                top: -10px;
                min-width: 20px;
                height: 20px;
                line-height: 20px;
                border-radius: 50%;
                color: #ffffff;
                font-size: 12px;
                font-weight: 600;
                text-align: center;
                padding: 0 6px;
            }
            #offerHelpBadge {
                right: 20px;
                background: var(--cayenne-blue);
            }
            #needHelpBadge {
                right: -10px;
                background: var(--danger-color);
            }
            #offerHelpBadge.pulse,
            #needHelpBadge.pulse {
                animation: pulse 1s ease-in-out infinite;
            }
            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.2);
                }
                100% {
                    transform: scale(1);
                }
            }

            /* Help Center notifications */
        </style>
    </head>
    <body>
        <!-- Fair Rotation Dynamic System -->
        <script src="../../fair-rotation-dynamic-system.js"></script>
        <div class="date-header">
            <div class="month-nav">
                <button id="prevMonth">&lt;</button>
                <span id="monthLabel">Loading...</span>
                <button id="nextMonth">&gt;</button>
            </div>
            <div class="day-scroll-wrapper">
                <button class="scroll-btn" id="scrollLeft">&lt;</button>
                <div class="day-scroll" id="dayScrollContainer"></div>
                <button class="scroll-btn" id="scrollRight">&gt;</button>
            </div>
        </div>

        <div
            style="
                padding-top: calc(var(--header-height) + 80px);
                padding-left: 10px;
                padding-right: 10px;
                padding-bottom: 20px;
                max-width: 100%;
                margin: 0 auto;
                display: flex;
                flex-direction: column;
                align-items: center;
            "
        >
            <div class="flex justify-center mb-4">
                <button
                    onclick="showTab('myTasks')"
                    class="tab-button px-4 py-2 rounded-l-lg shadow-md active"
                >
                    My Tasks
                </button>
                <button
                    onclick="showTab('allTasks')"
                    class="tab-button px-4 py-2 rounded-r-lg shadow-md"
                >
                    All Tasks
                </button>
            </div>

            <div id="myTasks" class="tab-content">
                <div id="userTasks" class="task-list">
                    <!-- My assigned tasks will be displayed here -->
                </div>
            </div>

            <div id="allTasks" class="tab-content hidden">
                <div id="allTasksList" class="task-list">
                    <!-- All tasks will be displayed here -->
                </div>
            </div>
        </div>

        <div class="footer">
            <a
                href="#"
                id="homeButton"
                class="footer-icon active"
                aria-label="Home"
            >
                <img src="/BeeMazing-A1/mobile/1-Home/HomeBtn.png" alt="Home" />
            </a>
            <a href="#" id="tasksButton" class="footer-icon" aria-label="Tasks">
                <img
                    src="/BeeMazing-A1/mobile/1-Home/TasksBtn.png"
                    alt="Tasks"
                />
            </a>
            <a
                href="#"
                id="marketButton"
                class="footer-icon"
                aria-label="Market"
            >
                <img
                    src="/BeeMazing-A1/mobile/1-Home/MarketBtn.png"
                    alt="Market"
                />
            </a>
        </div>

        <script src="/BeeMazing-A1/shared/taskrotations.js?t=${Date.now()}"></script>
        <script src="/BeeMazing-A1/shared/avatar-system.js?t=${Date.now()}"></script>

        <script>
            document.addEventListener("DOMContentLoaded", async () => {
                const urlParams = new URLSearchParams(window.location.search);
                let adminEmail =
                    urlParams.get("admin") ||
                    localStorage.getItem("currentAdminEmail");
                userName = urlParams.get("user"); // Set global userName
                const addPoints = Number(urlParams.get("addPoints")) || 0;

                if (adminEmail && adminEmail !== "null") {
                    localStorage.setItem("currentAdminEmail", adminEmail);
                }

                // Initialize avatar system first
                if (adminEmail && window.avatarSystem) {
                    try {
                        await window.avatarSystem.initialize(adminEmail);
                        console.log(
                            "‚úÖ Avatar system initialized for:",
                            adminEmail,
                        );
                    } catch (error) {
                        console.error(
                            "‚ùå Failed to initialize avatar system:",
                            error,
                        );
                    }
                }

                if (userName && adminEmail) {
                    // Check if user is admin
                    const userData =
                        JSON.parse(localStorage.getItem("userData")) || {};
                    const permissions = userData[adminEmail]?.permissions || {};
                    const isUserAdmin = permissions[userName] === "Admin";

                    // Set footer button links
                    const basePath = "/BeeMazing-A1/mobile/2-UserProfiles";
                    const homeButton = document.getElementById("homeButton");
                    const tasksButton = document.getElementById("tasksButton");
                    const marketButton =
                        document.getElementById("marketButton");

                    if (homeButton) {
                        const homePage = isUserAdmin
                            ? "userAdmin.html"
                            : "users.html";
                        homeButton.href = `${basePath}/${homePage}?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
                    }
                    if (tasksButton) {
                        tasksButton.href = `${basePath}/userTasks.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
                    }
                    if (marketButton) {
                        marketButton.href = `${basePath}/usermarket.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
                    }

                    // Set active state
                    document.querySelectorAll(".footer a").forEach((link) => {
                        const currentPath = window.location.pathname.replace(
                            /\/$/,
                            "",
                        );
                        const linkPath = new URL(
                            link.href,
                            window.location.origin,
                        ).pathname.replace(/\/$/, "");
                        if (currentPath === linkPath) {
                            link.classList.add("active");
                        } else {
                            link.classList.remove("active");
                        }
                    });

                    // Wait a bit for avatar system to be fully ready
                    setTimeout(() => {
                        loadUserTasks(userName);
                        loadUserReward(userName);
                        loadNotifications(userName); // Load notifications on page load
                    }, 100);

                    const helpCenterBtn =
                        document.getElementById("helpCenterBtn");
                    if (helpCenterBtn) {
                        helpCenterBtn.addEventListener("click", async () => {
                            localStorage.setItem("lastHelpUser", userName);
                            const helpURL = `/BeeMazing-A1/shared/helpCenter.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;

                            // Clear notifications for this user
                            try {
                                const res = await fetch(
                                    "https://beemazing1.onrender.com/api/notifications",
                                    {
                                        method: "DELETE",
                                        headers: {
                                            "Content-Type": "application/json",
                                        },
                                        body: JSON.stringify({
                                            adminEmail,
                                            user: userName,
                                        }),
                                    },
                                );
                                const data = await res.json();
                                console.log(
                                    "Clear notifications response:",
                                    data,
                                );
                                if (!res.ok) {
                                    console.warn(
                                        "Failed to clear notifications:",
                                        data.error,
                                    );
                                }
                            } catch (err) {
                                console.error(
                                    "Error clearing notifications:",
                                    err.message,
                                );
                            }

                            window.location.href = helpURL;
                        });
                    }

                    if (addPoints > 0) {
                        setTimeout(async () => {
                            await updateUserReward(userName, addPoints);
                            triggerHoneyRain(addPoints);
                            loadUserReward(userName);
                        }, 500);
                    }
                } else {
                    document.getElementById("userTasks").innerHTML =
                        "<p>Error: Missing user or admin email. Please log in again.</p>";
                    document.getElementById("userName").textContent = "Error";
                }

                adjustContentTop();
                generateScrollableDates();
                showAdminControlsIfNeeded();
            });

            function showTab(tabId) {
                document
                    .querySelectorAll(".tab-content")
                    .forEach((tab) => tab.classList.add("hidden"));
                document.getElementById(tabId).classList.remove("hidden");
                document.querySelectorAll(".tab-button").forEach((button) => {
                    button.classList.remove("active");
                });
                const activeButton = document.querySelector(
                    `button[onclick="showTab('${tabId}')"]`,
                );
                if (activeButton) {
                    activeButton.classList.add("active");
                }

                // Load appropriate tasks based on selected tab
                const selectedDate = new Date().toLocaleDateString("sv-SE");
                if (userName) {
                    if (tabId === "myTasks") {
                        // Ensure avatar system is ready before loading tasks
                        if (window.avatarSystem) {
                            loadUserTasks(userName, selectedDate);
                        } else {
                            setTimeout(
                                () => loadUserTasks(userName, selectedDate),
                                100,
                            );
                        }
                    } else if (tabId === "allTasks") {
                        // Ensure avatar system is ready before loading tasks
                        if (window.avatarSystem) {
                            loadAllTasks(userName, selectedDate);
                        } else {
                            setTimeout(
                                () => loadAllTasks(userName, selectedDate),
                                100,
                            );
                        }
                    }
                }
            }

            // addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////

            let isLoadingUserTasks = false;
            let userName = null; // Global userName variable

            // Helper function to determine current assignee for a task at a specific date and user index
            function getCurrentAssignee(task, selectedDate, userIndex = 0) {
                // Check if there's a temporary replacement for this date and user index
                if (
                    task.tempTurnReplacement &&
                    task.tempTurnReplacement[selectedDate] &&
                    task.tempTurnReplacement[selectedDate][userIndex.toString()]
                ) {
                    return task.tempTurnReplacement[selectedDate][
                        userIndex.toString()
                    ];
                }
                // Otherwise return the original assignee
                return task.users[userIndex];
            }

            // Helper function to check if a user is currently assigned to a task
            function isUserCurrentlyAssigned(task, selectedDate, userName) {
                // Check original assignments
                const isOriginallyAssigned = task.users.includes(userName);

                // For rotation tasks with occurrences, check specific assignment
                if (
                    task.settings &&
                    task.settings.includes("Rotation") &&
                    typeof task.currentTurnIndex !== "undefined"
                ) {
                    // This is a rotation task occurrence - check who is currently assigned
                    const currentAssigneeIndex = task.currentTurnIndex;
                    const currentAssignee = getCurrentAssignee(
                        task,
                        selectedDate,
                        currentAssigneeIndex,
                    );

                    console.log(`üéØ Checking rotation occurrence assignment:`, {
                        taskTitle: task.title,
                        occurrence: task.occurrence || "N/A",
                        currentTurnIndex: task.currentTurnIndex,
                        currentAssignee: currentAssignee,
                        userName: userName,
                        isAssigned: currentAssignee === userName,
                    });

                    return currentAssignee === userName;
                }

                // Check temporary replacements
                let isReplacementAssigned = false;
                if (
                    task.tempTurnReplacement &&
                    task.tempTurnReplacement[selectedDate]
                ) {
                    const replacements = task.tempTurnReplacement[selectedDate];
                    isReplacementAssigned =
                        Object.values(replacements).includes(userName);
                }

                // User is currently assigned if:
                // 1. Originally assigned AND no one has replaced them, OR
                // 2. They are assigned as a replacement
                if (isReplacementAssigned) {
                    return true;
                }

                if (
                    isOriginallyAssigned &&
                    task.tempTurnReplacement &&
                    task.tempTurnReplacement[selectedDate]
                ) {
                    // Check if this user has been replaced
                    const userIndex = task.users.indexOf(userName);
                    if (
                        userIndex !== -1 &&
                        task.tempTurnReplacement[selectedDate][
                            userIndex.toString()
                        ]
                    ) {
                        return false; // User has been replaced
                    }
                }

                return isOriginallyAssigned;
            }

            // Helper function to determine original assignee for a task
            function getOriginalAssignee(task, selectedDate, completerUser) {
                // First check if there's completion data that has original assignee info
                if (task.completedDates && task.completedDates[selectedDate]) {
                    const completions = task.completedDates[selectedDate];
                    // Look for completion entry for the completer user
                    const completion = completions.find(
                        (c) => c.user === completerUser,
                    );
                    if (completion && completion.originalAssignee) {
                        console.log(
                            "üîç Found original assignee from completion data:",
                            {
                                completerUser,
                                originalAssignee: completion.originalAssignee,
                                taskTitle: task.title,
                            },
                        );
                        return completion.originalAssignee;
                    }
                }

                // Check if there are temp turn replacements that would indicate original assignee
                if (
                    task.tempTurnReplacement &&
                    task.tempTurnReplacement[selectedDate]
                ) {
                    const replacements = task.tempTurnReplacement[selectedDate];
                    // Find if the completer was a replacement
                    for (const [index, replacementUser] of Object.entries(
                        replacements,
                    )) {
                        if (replacementUser === completerUser) {
                            // The original assignee would be the user at this index in the original assignment
                            const originalIndex = parseInt(index);
                            if (task.users && task.users[originalIndex]) {
                                console.log(
                                    "üîç Found original assignee from temp replacement:",
                                    {
                                        completerUser: replacementUser,
                                        originalAssignee:
                                            task.users[originalIndex],
                                        taskTitle: task.title,
                                    },
                                );
                                return task.users[originalIndex];
                            }
                        }
                    }
                }

                // Handle all known reassigned tasks from Art≈´rs to Laura
                if (
                    task.exceptions &&
                    task.exceptions[selectedDate] &&
                    task.exceptions[selectedDate].modified === true
                ) {
                    console.log(
                        "üîç Task was modified - checking for reassignment patterns:",
                        { taskTitle: task.title, completerUser },
                    );

                    const reassignedTasks = {
                        "NovƒÅkt virtuvi": "Art≈´rs",
                        "Izslauscƒ´t grƒ´du": "Art≈´rs",
                        "IzkrƒÅmƒìt veƒºas ma≈°ƒ´nu": "Art≈´rs",
                        "Savakt darzu": "Art≈´rs",
                        "Fresh task": "Art≈´rs",
                    };

                    if (
                        reassignedTasks[task.title] &&
                        completerUser === "Laura"
                    ) {
                        const originalAssignee = reassignedTasks[task.title];
                        console.log(
                            "‚úÖ Found original assignee for completed task:",
                            {
                                taskTitle: task.title,
                                originalAssignee,
                            },
                        );
                        return originalAssignee;
                    }

                    console.log(
                        "‚ö†Ô∏è Task was modified but not in known reassigned tasks",
                    );
                }

                // If no replacement info found, return null (same user completion)
                console.log(
                    "üîç No original assignee found - same user completion:",
                    {
                        completerUser,
                        taskTitle: task.title,
                    },
                );
                return null;
            }

            // Helper function to build completion display with proper avatar logic
            function buildCompletionDisplay(
                completerUser,
                originalAssignee,
                timeStr,
                isAllTasks = false,
            ) {
                const avatarSize = isAllTasks ? 16 : 20;
                const marginRight = isAllTasks ? "2px" : "4px";
                const checkmarkColor = "#6d4c41"; // Completed tasks are grey/brown

                let avatarHTML = "";

                console.log("üîç Building completion display:", {
                    completerUser,
                    originalAssignee,
                    timeStr,
                    avatarSystemExists: !!window.avatarSystem,
                });

                if (window.avatarSystem) {
                    if (
                        originalAssignee &&
                        originalAssignee !== completerUser
                    ) {
                        // Show only original user in brackets (completer icon shown separately with status)
                        const originalAvatarHTML =
                            window.avatarSystem.generateAvatarHTML(
                                originalAssignee,
                                avatarSize,
                                "original-user-avatar",
                                `margin-right: ${marginRight};`,
                            );
                        avatarHTML = originalAvatarHTML;
                        console.log(
                            "üîç Built completion display with original assignee only:",
                            {
                                originalAssignee,
                                completerUser,
                                avatarHTML: avatarHTML.length,
                            },
                        );
                    } else {
                        // Same user completion - no avatar needed (shown with status)
                        avatarHTML = "";
                        console.log(
                            "üîç Built completion display with no avatar (same user):",
                            {
                                completerUser,
                            },
                        );
                    }
                } else {
                    // Fallback if avatar system not available
                    console.warn(
                        "Avatar system not available, using text fallback",
                    );
                    if (
                        originalAssignee &&
                        originalAssignee !== completerUser
                    ) {
                        avatarHTML = `<span style="font-size: 12px; color: #666;">${originalAssignee.substring(0, 3).toUpperCase()}</span>`;
                    } else {
                        avatarHTML = "";
                    }
                }

                const checkmarkSVG = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="${checkmarkColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 12l2 2 4-4"></path><circle cx="12" cy="12" r="10"></circle></svg>`;

                return `<span style="color: ${checkmarkColor}; font-size: 15px; display: ${isAllTasks ? "inline-flex" : "flex"}; align-items: center; gap: 4px;">${avatarHTML}${checkmarkSVG}${timeStr}</span>`;
            }

            async function loadAllTasks(
                userName,
                selectedDate = new Date().toLocaleDateString("sv-SE"),
            ) {
                if (isLoadingUserTasks) {
                    console.log("üêõ loadAllTasks already running, skipping");
                    return;
                }

                isLoadingUserTasks = true;

                try {
                    const allTasksDiv = document.getElementById("allTasksList");
                    allTasksDiv.innerHTML = "<p>Loading tasks...</p>";

                    const adminEmail =
                        localStorage.getItem("currentAdminEmail");
                    let tasks = [];

                    try {
                        // Add random parameter to ensure fresh data after task completion
                        const cacheBuster = `t=${Date.now()}&r=${Math.random()}`;
                        const res = await fetch(
                            `https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&${cacheBuster}`,
                            {
                                cache: "no-store",
                                headers: {
                                    "Cache-Control":
                                        "no-cache, no-store, must-revalidate",
                                    Pragma: "no-cache",
                                    Expires: "0",
                                },
                            },
                        );
                        const data = await res.json();
                        if (!res.ok)
                            throw new Error(
                                data.error || "Failed to fetch tasks",
                            );
                        tasks = data.tasks || [];
                        console.log(
                            "üîç loadAllTasks: Fetched fresh task data",
                            { taskCount: tasks.length, cacheBuster },
                        );
                    } catch (err) {
                        console.error(
                            "Failed to fetch tasks from server:",
                            err,
                        );
                        allTasksDiv.innerHTML =
                            "<p>Failed to load tasks. Please try again later.</p>";
                        return;
                    }

                    // Show only public tasks NOT assigned to current user in All Tasks view
                    const otherTasks = filterTasksForDate(
                        tasks,
                        selectedDate,
                    ).filter((task) => {
                        if (!task || !task.users || !task.title || !task.date)
                            return false;

                        // Don't show tasks currently assigned to current user
                        if (
                            isUserCurrentlyAssigned(
                                task,
                                selectedDate,
                                userName,
                            )
                        )
                            return false;
                        if (task.isPrivate === true) return false; // Don't show private tasks
                        return true;
                    });

                    // Sort tasks: incomplete (by due time) ‚Üí incomplete (no due time) ‚Üí pending approval ‚Üí approved
                    otherTasks.sort((a, b) => {
                        const getTaskStatus = (task) => {
                            const isRotation =
                                task.settings?.includes("Rotation");
                            let turnData;

                            if (isRotation) {
                                turnData =
                                    typeof mixedTurnData === "function"
                                        ? mixedTurnData(task, selectedDate)
                                        : {
                                              turns: [],
                                              completedCount: 0,
                                              requiredTimes: 1,
                                          };
                            } else {
                                turnData =
                                    typeof individualTurnData === "function"
                                        ? individualTurnData(task, selectedDate)
                                        : {
                                              turns: [],
                                              completedCount: 0,
                                              requiredTimes: 1,
                                          };
                            }

                            const totalRequiredCompletions = isRotation
                                ? turnData.requiredTimes
                                : turnData.requiredTimes * task.users.length;

                            const hasSubmissions = turnData.completedCount > 0;
                            if (!hasSubmissions) return "incomplete";

                            if (task.parentApproval === true) {
                                // Use improved cross-completion status calculation
                                const pendingUsers = [];
                                const approvedUsers = [];

                                // Check ALL completions (including cross-completions)
                                const allCompletions = [];

                                // Get all completions from completedDates format
                                if (
                                    task.completedDates &&
                                    task.completedDates[selectedDate]
                                ) {
                                    allCompletions.push(
                                        ...task.completedDates[selectedDate],
                                    );
                                }
                                // Fallback to completions format
                                else if (
                                    task.completions &&
                                    task.completions[selectedDate]
                                ) {
                                    allCompletions.push(
                                        ...task.completions[
                                            selectedDate
                                        ].filter(
                                            (c) =>
                                                c.isCompleted || !c.isPending,
                                        ),
                                    );
                                }

                                // CROSS-COMPLETION FIX: Also check task.completions for isPending status
                                if (
                                    task.completions &&
                                    task.completions[selectedDate]
                                ) {
                                    const completionsData =
                                        task.completions[selectedDate];
                                    // Update isPending status from completions data
                                    allCompletions.forEach((completion) => {
                                        const matchingCompletion =
                                            completionsData.find(
                                                (c) =>
                                                    c.user === completion.user,
                                            );
                                        if (matchingCompletion) {
                                            // Use the isPending status from completions data (more accurate)
                                            completion.isPending =
                                                matchingCompletion.isPending;
                                        }
                                    });
                                }

                                // Process all completions (including cross-completions)
                                allCompletions.forEach((completion) => {
                                    const user = completion.user;
                                    if (completion.isPending === true) {
                                        if (!pendingUsers.includes(user)) {
                                            pendingUsers.push(user);
                                        }
                                    } else {
                                        if (!approvedUsers.includes(user)) {
                                            approvedUsers.push(user);
                                        }
                                    }
                                });

                                if (
                                    approvedUsers.length > 0 &&
                                    pendingUsers.length === 0
                                ) {
                                    return "approved";
                                } else if (pendingUsers.length > 0) {
                                    return "pending";
                                } else {
                                    return "incomplete";
                                }
                            } else {
                                // Non-approval tasks are approved when completed
                                const isFullyCompleted =
                                    turnData.completedCount >=
                                    totalRequiredCompletions;
                                if (isFullyCompleted) {
                                    return "approved";
                                } else {
                                    return "incomplete";
                                }
                            }
                        };

                        const getDueTimePriority = (task) => {
                            if (!task.dueTimes || task.dueTimes.length === 0) {
                                return 10000; // Tasks without due time go after timed tasks
                            }

                            const now = new Date();
                            const currentTime =
                                now.getHours() * 60 + now.getMinutes();
                            let earliestDueTime = Infinity;
                            let hasOverdue = false;

                            task.dueTimes.forEach((timeStr) => {
                                const [hours, minutes] = timeStr
                                    .split(":")
                                    .map(Number);
                                const dueTime = hours * 60 + minutes;

                                if (dueTime < currentTime) {
                                    hasOverdue = true;
                                }

                                if (dueTime < earliestDueTime) {
                                    earliestDueTime = dueTime;
                                }
                            });

                            if (hasOverdue) return 0; // Overdue tasks at very top
                            return earliestDueTime;
                        };

                        const statusA = getTaskStatus(a);
                        const statusB = getTaskStatus(b);

                        // Primary sort by status
                        const statusOrder = {
                            incomplete: 1,
                            pending: 2,
                            approved: 3,
                        };
                        if (statusOrder[statusA] !== statusOrder[statusB]) {
                            return statusOrder[statusA] - statusOrder[statusB];
                        }

                        // Secondary sort: within incomplete tasks, sort by due time
                        if (
                            statusA === "incomplete" &&
                            statusB === "incomplete"
                        ) {
                            const priorityA = getDueTimePriority(a);
                            const priorityB = getDueTimePriority(b);
                            return priorityA - priorityB;
                        }

                        // Tertiary sort: alphabetical by title
                        return a.title.localeCompare(b.title);
                    });

                    allTasksDiv.innerHTML = "";

                    if (otherTasks.length === 0) {
                        allTasksDiv.innerHTML +=
                            "<p>No other tasks available for this date.</p>";
                    } else {
                        for (const task of otherTasks) {
                            try {
                                const taskDiv = document.createElement("div");
                                taskDiv.className = "task-item";

                                const isRotation =
                                    task.settings?.includes("Rotation");
                                let turnData;

                                if (isRotation) {
                                    if (typeof mixedTurnData !== "function") {
                                        console.error(
                                            `mixedTurnData is not defined for task: ${task.title}`,
                                        );
                                        turnData = {
                                            turns: [],
                                            completedCount: 0,
                                            requiredTimes: 1,
                                        };
                                    } else {
                                        try {
                                            turnData = mixedTurnData(
                                                task,
                                                selectedDate,
                                            );
                                        } catch (error) {
                                            console.error(
                                                `Error in mixedTurnData for task ${task.title}:`,
                                                error,
                                            );
                                            turnData = {
                                                turns: [],
                                                completedCount: 0,
                                                requiredTimes: 1,
                                            };
                                        }
                                    }
                                } else {
                                    if (
                                        typeof individualTurnData !== "function"
                                    ) {
                                        console.error(
                                            `individualTurnData is not defined for task: ${task.title}`,
                                        );
                                        turnData = {
                                            turns: [],
                                            completedCount: 0,
                                            requiredTimes: 1,
                                        };
                                    } else {
                                        try {
                                            turnData = individualTurnData(
                                                task,
                                                selectedDate,
                                            );
                                        } catch (error) {
                                            console.error(
                                                `Error in individualTurnData for task ${task.title}:`,
                                                error,
                                            );
                                            turnData = {
                                                turns: [],
                                                completedCount: 0,
                                                requiredTimes: 1,
                                            };
                                        }
                                    }
                                }

                                // Determine if task is fully approved for fading effect
                                let isFullyApproved = false;
                                if (task.parentApproval === true) {
                                    // Check if task has any approved completions
                                    const pendingUsers = [];
                                    const approvedUsers = [];

                                    // Check ALL completions (including cross-completions)
                                    const allCompletions = [];

                                    // Get all completions from completedDates format
                                    if (
                                        task.completedDates &&
                                        task.completedDates[selectedDate]
                                    ) {
                                        allCompletions.push(
                                            ...task.completedDates[
                                                selectedDate
                                            ],
                                        );
                                    }
                                    // Fallback to completions format
                                    else if (
                                        task.completions &&
                                        task.completions[selectedDate]
                                    ) {
                                        allCompletions.push(
                                            ...task.completions[
                                                selectedDate
                                            ].filter(
                                                (c) =>
                                                    c.isCompleted ||
                                                    !c.isPending,
                                            ),
                                        );
                                    }

                                    // CROSS-COMPLETION FIX: Also check task.completions for isPending status
                                    if (
                                        task.completions &&
                                        task.completions[selectedDate]
                                    ) {
                                        const completionsData =
                                            task.completions[selectedDate];
                                        // Update isPending status from completions data
                                        allCompletions.forEach((completion) => {
                                            const matchingCompletion =
                                                completionsData.find(
                                                    (c) =>
                                                        c.user ===
                                                        completion.user,
                                                );
                                            if (matchingCompletion) {
                                                // Use the isPending status from completions data (more accurate)
                                                completion.isPending =
                                                    matchingCompletion.isPending;
                                            }
                                        });
                                    }

                                    // Process all completions
                                    allCompletions.forEach((completion) => {
                                        const user = completion.user;
                                        if (completion.isPending === true) {
                                            if (!pendingUsers.includes(user)) {
                                                pendingUsers.push(user);
                                            }
                                        } else {
                                            if (!approvedUsers.includes(user)) {
                                                approvedUsers.push(user);
                                            }
                                        }
                                    });

                                    // Task is fully approved if it has approved users and no pending users
                                    isFullyApproved =
                                        approvedUsers.length > 0 &&
                                        pendingUsers.length === 0;
                                } else {
                                    // For non-approval tasks, completed = approved
                                    const totalRequiredCompletions = isRotation
                                        ? turnData.requiredTimes
                                        : turnData.requiredTimes *
                                          task.users.length;
                                    isFullyApproved =
                                        turnData.completedCount >=
                                        totalRequiredCompletions;
                                }

                                // Create main container with flexbox layout and optional fading
                                const backgroundColor = isFullyApproved
                                    ? "#f5f2e9"
                                    : "#FFFFFF";
                                const opacity = isFullyApproved ? "0.85" : "1";
                                taskDiv.style.cssText = `display: flex !important; justify-content: space-between; align-items: center; padding: 8px 15px !important; min-height: 56px; background-color: ${backgroundColor}; color: #6D4C41; border: 2px solid var(--primary-color); border-radius: 12px; margin-bottom: 3px; cursor: pointer; transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease; box-shadow: 0 2px 8px rgba(255, 193, 7, 0.1); opacity: ${opacity}; width: 100% !important; max-width: none !important; box-sizing: border-box !important; margin-left: 0 !important; margin-right: 0 !important;`;

                                // Create left content container
                                const leftContent =
                                    document.createElement("div");
                                leftContent.style.cssText =
                                    "flex: 1; display: flex; flex-direction: column; justify-content: center; padding: 2px 0; gap: 2px;";

                                // Build the left content HTML - title with private indicator
                                let leftHTML = `<div style="line-height: 1.2; text-align: center;"><strong style="font-size: 16px;">${task.title}`;
                                if (task.isPrivate === true) {
                                    leftHTML += ` <span style="color: #ff6b6b; font-size: 13px;">üîí Private</span>`;
                                }
                                leftHTML += `</strong></div>`;

                                // Second line with reward, due time, completion time, and avatar info
                                let secondLine = "";

                                // Add buzz points (reward)
                                if (task.reward && task.reward > 0) {
                                    secondLine += `<span style="color: var(--primary-color); font-weight: 600; font-size: 15px;">${task.reward} üçØ</span>`;
                                }

                                // Determine who the current assignee is (could be from temp replacement)
                                const currentAssignee = getCurrentAssignee(
                                    task,
                                    selectedDate,
                                    0,
                                );

                                const originalAssignee = task.users[0];

                                // Check if task is completed and get completion info
                                let completionTimeStr = "";
                                let originalAssigneeForDisplay = null;
                                console.log(
                                    "üîç [All Tasks] Checking completion time for task:",
                                    {
                                        taskTitle: task.title,
                                        selectedDate,
                                        userName,
                                        hasCompletedDates:
                                            !!task.completedDates,
                                        hasCompletions: !!task.completions,
                                    },
                                );

                                // First check completedDates (new format with timestamps)
                                if (
                                    task.completedDates &&
                                    task.completedDates[selectedDate]
                                ) {
                                    const allCompletions =
                                        task.completedDates[selectedDate];
                                    if (allCompletions.length > 0) {
                                        const latestCompletion =
                                            allCompletions[
                                                allCompletions.length - 1
                                            ];
                                        if (latestCompletion.completedAt) {
                                            const completedTime = new Date(
                                                latestCompletion.completedAt,
                                            );
                                            const timeStr =
                                                completedTime.toLocaleTimeString(
                                                    "en-US",
                                                    {
                                                        hour: "2-digit",
                                                        minute: "2-digit",
                                                        hour12: true,
                                                    },
                                                );

                                            const completerUser =
                                                latestCompletion.user;
                                            originalAssigneeForDisplay =
                                                getOriginalAssignee(
                                                    task,
                                                    selectedDate,
                                                    completerUser,
                                                );

                                            completionTimeStr = timeStr;
                                        }
                                    }
                                }
                                // Fallback to old completions format
                                else if (
                                    task.completions &&
                                    task.completions[selectedDate]
                                ) {
                                    const allCompletions = task.completions[
                                        selectedDate
                                    ].filter(
                                        (c) => c.isCompleted || !c.isPending,
                                    );
                                    if (allCompletions.length > 0) {
                                        const latestCompletion =
                                            allCompletions[
                                                allCompletions.length - 1
                                            ];
                                        if (latestCompletion.completedAt) {
                                            const completedTime = new Date(
                                                latestCompletion.completedAt,
                                            );
                                            const timeStr =
                                                completedTime.toLocaleTimeString(
                                                    "en-US",
                                                    {
                                                        hour: "2-digit",
                                                        minute: "2-digit",
                                                        hour12: true,
                                                    },
                                                );

                                            const completerUser =
                                                latestCompletion.user;
                                            originalAssigneeForDisplay =
                                                getOriginalAssignee(
                                                    task,
                                                    selectedDate,
                                                    completerUser,
                                                );

                                            completionTimeStr = timeStr;
                                        }
                                    }
                                }

                                // For incomplete tasks, set original assignee if different from current
                                if (
                                    !completionTimeStr &&
                                    originalAssignee !== currentAssignee
                                ) {
                                    originalAssigneeForDisplay =
                                        originalAssignee;
                                }

                                // Add current assignee avatar after buzz points (always show)
                                if (secondLine)
                                    secondLine += `<span style="margin: 0 8px; color: #ccc;">|</span>`;

                                if (
                                    window.avatarSystem &&
                                    typeof window.avatarSystem
                                        .generateAvatarHTML === "function"
                                ) {
                                    const avatarHTML =
                                        window.avatarSystem.generateAvatarHTML(
                                            currentAssignee,
                                            16,
                                            "current-assignee-avatar",
                                            "margin-right: 2px;",
                                        );
                                    secondLine += `<span style="display: flex; align-items: center;">${avatarHTML}</span>`;
                                } else {
                                    // Fallback when avatar system not available
                                    const initials = currentAssignee
                                        .substring(0, 2)
                                        .toUpperCase();
                                    secondLine += `<span style="display: flex; align-items: center;"><div style="width: 16px; height: 16px; border: 2px solid #fbb740; border-radius: 50%; background: #00C4B4; color: white; font-size: 7px; display: flex; align-items: center; justify-content: center;" title="Assigned to ${currentAssignee}">${initials}</div></span>`;
                                }

                                // Add due times
                                if (task.dueTimes && task.dueTimes.length > 0) {
                                    const dueTimeStr = task.dueTimes.join(", ");
                                    if (secondLine)
                                        secondLine += `<span style="margin: 0 8px; color: #ccc;">|</span>`;
                                    secondLine += `<span style="color: #6d4c41; font-size: 14px; display: flex; align-items: center; gap: 2px;"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#6d4c41" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12,6 12,12 16,14"></polyline></svg>${dueTimeStr}</span>`;
                                }

                                // Add completion time if task is completed (just the time with checkmark)
                                if (completionTimeStr) {
                                    if (secondLine)
                                        secondLine += `<span style="margin: 0 8px; color: #ccc;">|</span>`;

                                    const checkmarkColor = "#6d4c41";
                                    const checkmarkSVG = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="${checkmarkColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 12l2 2 4-4"></path><circle cx="12" cy="12" r="10"></circle></svg>`;

                                    secondLine += `<span style="color: ${checkmarkColor}; font-size: 14px; display: flex; align-items: center; gap: 2px;">${checkmarkSVG}${completionTimeStr}</span>`;
                                }

                                if (secondLine) {
                                    leftHTML += `<div style="line-height: 1.2; text-align: center; display: flex; align-items: center; justify-content: center;">${secondLine}</div>`;
                                }

                                leftContent.innerHTML = leftHTML;
                                taskDiv.appendChild(leftContent);

                                // Create button container for centering
                                const buttonContainer =
                                    document.createElement("div");
                                buttonContainer.style.cssText =
                                    "display: flex; align-items: center; justify-content: center;";

                                const todayStr = new Date().toLocaleDateString(
                                    "sv-SE",
                                );
                                const isToday = selectedDate === todayStr;

                                let canFinish = false;
                                if (isToday) {
                                    // Private tasks can only be completed by assigned users
                                    if (
                                        task.isPrivate === true &&
                                        !task.users.includes(userName)
                                    ) {
                                        canFinish = false;
                                    } else {
                                        if (isRotation) {
                                            // For rotation tasks in All Tasks, check if there are incomplete turns
                                            const totalCompletionsToday =
                                                turnData.completedCount;
                                            const totalRequiredCompletions =
                                                turnData.requiredTimes;
                                            canFinish =
                                                totalCompletionsToday <
                                                totalRequiredCompletions;

                                            console.log(
                                                "üîç loadAllTasks: Rotation task button visibility check",
                                                {
                                                    taskTitle: task.title,
                                                    totalCompletionsToday,
                                                    totalRequiredCompletions,
                                                    canFinish,
                                                    isToday,
                                                    isPrivate: task.isPrivate,
                                                    currentUser: userName,
                                                },
                                            );
                                        } else {
                                            // For individual tasks in All Tasks, check total completions across all users
                                            const totalCompletionsToday =
                                                turnData.completedCount;
                                            const allAssignedUsers =
                                                task.users || [];
                                            const totalRequiredCompletions =
                                                allAssignedUsers.length *
                                                turnData.requiredTimes;
                                            canFinish =
                                                totalCompletionsToday <
                                                totalRequiredCompletions;

                                            console.log(
                                                "üîç loadAllTasks: Individual task button visibility check",
                                                {
                                                    taskTitle: task.title,
                                                    totalCompletionsToday,
                                                    totalRequiredCompletions,
                                                    allAssignedUsers,
                                                    requiredTimes:
                                                        turnData.requiredTimes,
                                                    canFinish,
                                                    completedCount:
                                                        turnData.completedCount,
                                                    isToday,
                                                    isPrivate: task.isPrivate,
                                                    currentUser: userName,
                                                },
                                            );
                                        }
                                    }
                                }

                                // Create right side container for status/button only
                                const rightContainer =
                                    document.createElement("div");
                                rightContainer.style.cssText =
                                    "display: flex; align-items: center; justify-content: center; min-width: 60px;";

                                // Add status checkmark if completed or Done button if can finish
                                if (completionTimeStr) {
                                    // Get completer user from completion data
                                    let completerUser = userName; // Default fallback

                                    if (
                                        task.completedDates &&
                                        task.completedDates[selectedDate] &&
                                        task.completedDates[selectedDate]
                                            .length > 0
                                    ) {
                                        const latestCompletion =
                                            task.completedDates[selectedDate][
                                                task.completedDates[
                                                    selectedDate
                                                ].length - 1
                                            ];
                                        completerUser =
                                            latestCompletion.user || userName;
                                    } else if (
                                        task.completions &&
                                        task.completions[selectedDate] &&
                                        task.completions[selectedDate].length >
                                            0
                                    ) {
                                        const latestCompletion =
                                            task.completions[selectedDate][
                                                task.completions[selectedDate]
                                                    .length - 1
                                            ];
                                        completerUser =
                                            latestCompletion.user || userName;
                                    }

                                    // Create completer container with avatar and checkmark
                                    const completerContainer =
                                        document.createElement("div");
                                    completerContainer.style.cssText =
                                        "display: flex; align-items: center; gap: 4px;";

                                    // Add avatar if avatar system is available
                                    if (window.avatarSystem && completerUser) {
                                        const avatarHTML =
                                            window.avatarSystem.generateAvatarHTML(
                                                completerUser,
                                                24,
                                                "completer-avatar",
                                                "margin-right: 0;",
                                            );
                                        completerContainer.innerHTML =
                                            avatarHTML;
                                    }

                                    // Add checkmark (yellow for pending, green for approved)
                                    const checkmark =
                                        document.createElement("div");
                                    checkmark.innerHTML = "‚úì";

                                    // Determine if completion is pending or approved
                                    let isPending = false;
                                    if (task.parentApproval === true) {
                                        // Check completion status
                                        let foundCompletion = null;
                                        if (
                                            task.completedDates &&
                                            task.completedDates[selectedDate]
                                        ) {
                                            foundCompletion =
                                                task.completedDates[
                                                    selectedDate
                                                ].find(
                                                    (c) =>
                                                        c.user ===
                                                        completerUser,
                                                );
                                        }
                                        if (
                                            !foundCompletion &&
                                            task.completions &&
                                            task.completions[selectedDate]
                                        ) {
                                            foundCompletion = task.completions[
                                                selectedDate
                                            ].find(
                                                (c) => c.user === completerUser,
                                            );
                                        }

                                        // Use completions data for more accurate isPending status
                                        if (foundCompletion) {
                                            if (
                                                task.completions &&
                                                task.completions[selectedDate]
                                            ) {
                                                const completionData =
                                                    task.completions[
                                                        selectedDate
                                                    ].find(
                                                        (c) =>
                                                            c.user ===
                                                            completerUser,
                                                    );
                                                isPending = completionData
                                                    ? completionData.isPending
                                                    : foundCompletion.isPending;
                                            } else {
                                                isPending =
                                                    foundCompletion.isPending ||
                                                    false;
                                            }
                                        }
                                    }

                                    if (isPending) {
                                        checkmark.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6,2V8H6V8L10,12L6,16V16H6V22H18V16H18V16L14,12L18,8V8H18V2H6M16,16.5V20H8V16.5L12,12.5L16,16.5M12,11.5L8,7.5V4H16V7.5L12,11.5Z" fill="white"/></svg>`;
                                        checkmark.style.cssText =
                                            "width: 28px; height: 28px; border-radius: 50%; background: var(--primary-color); display: flex; align-items: center; justify-content: center;";
                                    } else {
                                        checkmark.innerHTML = "‚úì";
                                        checkmark.style.cssText =
                                            "width: 28px; height: 28px; border-radius: 50%; background: #28a745; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; border: 2px solid white;";
                                    }

                                    completerContainer.title = isPending
                                        ? `üïê Pending approval - completed by ${completerUser}`
                                        : `‚úÖ Approved - completed by ${completerUser}`;

                                    completerContainer.appendChild(checkmark);

                                    buttonContainer.appendChild(
                                        completerContainer,
                                    );
                                } else if (canFinish) {
                                    const finishBtn =
                                        document.createElement("button");
                                    finishBtn.className = "finished-btn";
                                    finishBtn.innerHTML = `Done`;
                                    finishBtn.style.cssText =
                                        "background: var(--primary-color); color: #6D4C41; border: none; padding: 2px 8px; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 16px; height: 40px; min-width: 60px; display: flex; align-items: center; justify-content: center;";
                                    finishBtn.addEventListener("click", (e) => {
                                        e.stopPropagation();
                                        if (!userName) {
                                            alert(
                                                "Error: User not identified. Please refresh the page.",
                                            );
                                            return;
                                        }
                                        finishTask(
                                            userName,
                                            task,
                                            selectedDate,
                                        );
                                    });
                                    finishBtn.addEventListener(
                                        "mouseenter",
                                        () => {
                                            finishBtn.style.background =
                                                "#FFB300";
                                        },
                                    );
                                    finishBtn.addEventListener(
                                        "mouseleave",
                                        () => {
                                            finishBtn.style.background =
                                                "var(--primary-color)";
                                        },
                                    );
                                    buttonContainer.appendChild(finishBtn);
                                } else {
                                    // Show pending/approved status for completed tasks
                                    const pendingUsers = [];
                                    const approvedUsers = [];

                                    // Get turn data to check status
                                    const isRotation =
                                        task.settings?.includes("Rotation");
                                    let turnData;

                                    if (isRotation) {
                                        turnData =
                                            typeof mixedTurnData === "function"
                                                ? mixedTurnData(
                                                      task,
                                                      selectedDate,
                                                  )
                                                : {
                                                      turns: [],
                                                      completedCount: 0,
                                                      requiredTimes: 1,
                                                  };
                                    } else {
                                        turnData =
                                            typeof individualTurnData ===
                                            "function"
                                                ? individualTurnData(
                                                      task,
                                                      selectedDate,
                                                  )
                                                : {
                                                      turns: [],
                                                      completedCount: 0,
                                                      requiredTimes: 1,
                                                  };
                                    }

                                    // Check if task has completions
                                    if (turnData.completedCount > 0) {
                                        // Check approval status
                                        if (task.parentApproval === true) {
                                            turnData.turns.forEach((turn) => {
                                                if (
                                                    turn.isPending &&
                                                    !pendingUsers.includes(
                                                        turn.user,
                                                    )
                                                ) {
                                                    pendingUsers.push(
                                                        turn.user,
                                                    );
                                                } else if (
                                                    turn.isCompleted &&
                                                    !turn.isPending &&
                                                    !approvedUsers.includes(
                                                        turn.user,
                                                    )
                                                ) {
                                                    approvedUsers.push(
                                                        turn.user,
                                                    );
                                                }
                                            });
                                        } else {
                                            // Non-approval tasks are approved when completed
                                            turnData.turns.forEach((turn) => {
                                                if (
                                                    turn.isCompleted &&
                                                    !approvedUsers.includes(
                                                        turn.user,
                                                    )
                                                ) {
                                                    approvedUsers.push(
                                                        turn.user,
                                                    );
                                                }
                                            });
                                        }

                                        // Show avatars with checkmarks
                                        if (
                                            pendingUsers.length > 0 ||
                                            approvedUsers.length > 0
                                        ) {
                                            const allUsers = [
                                                ...pendingUsers,
                                                ...approvedUsers,
                                            ];

                                            // Create avatar container to match My Tasks spacing
                                            const avatarContainer =
                                                document.createElement("div");
                                            avatarContainer.style.cssText =
                                                "display: flex; align-items: center; justify-content: center; gap: 4px; flex-wrap: wrap; max-width: 60px;";

                                            allUsers
                                                .slice(0, 3)
                                                .forEach((user) => {
                                                    if (window.avatarSystem) {
                                                        const isPending =
                                                            pendingUsers.includes(
                                                                user,
                                                            );
                                                        const avatarHTML =
                                                            window.avatarSystem.generateAvatarHTML(
                                                                user,
                                                                24,
                                                                "task-completed-avatar",
                                                                "margin-right: 0;",
                                                            );

                                                        const userWrapper =
                                                            document.createElement(
                                                                "div",
                                                            );
                                                        userWrapper.style.cssText =
                                                            "display: flex; align-items: center; gap: 4px;";
                                                        userWrapper.innerHTML =
                                                            avatarHTML;

                                                        const checkmark =
                                                            document.createElement(
                                                                "div",
                                                            );
                                                        checkmark.innerHTML =
                                                            "‚úì";
                                                        if (isPending) {
                                                            checkmark.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6,2V8H6V8L10,12L6,16V16H6V22H18V16H18V16L14,12L18,8V8H18V2H6M16,16.5V20H8V16.5L12,12.5L16,16.5M12,11.5L8,7.5V4H16V7.5L12,11.5Z" fill="white"/></svg>`;
                                                            checkmark.style.cssText =
                                                                "width: 20px; height: 20px; border-radius: 50%; background: var(--primary-color); display: flex; align-items: center; justify-content: center;";
                                                        } else {
                                                            checkmark.style.cssText =
                                                                "width: 20px; height: 20px; border-radius: 50%; background: #28a745; color: white; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;";
                                                        }

                                                        userWrapper.appendChild(
                                                            checkmark,
                                                        );
                                                        userWrapper.title =
                                                            isPending
                                                                ? `Pending approval by ${user}`
                                                                : `Approved - completed by ${user}`;
                                                        avatarContainer.appendChild(
                                                            userWrapper,
                                                        );
                                                    }
                                                });

                                            // Show count if more than 3 users
                                            if (allUsers.length > 3) {
                                                const moreDiv =
                                                    document.createElement(
                                                        "div",
                                                    );
                                                moreDiv.textContent = `+${allUsers.length - 3}`;
                                                moreDiv.title = `${allUsers.length} users involved`;
                                                moreDiv.style.cssText =
                                                    "width: 24px; height: 24px; border-radius: 50%; border: 2px solid #666; background: #666; color: white; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; margin-right: 0;";
                                                avatarContainer.appendChild(
                                                    moreDiv,
                                                );
                                            }

                                            buttonContainer.appendChild(
                                                avatarContainer,
                                            );
                                        }
                                    }
                                }

                                taskDiv.appendChild(buttonContainer);

                                taskDiv.addEventListener("click", () =>
                                    showTaskDetails(task, selectedDate),
                                );
                                allTasksDiv.appendChild(taskDiv);
                            } catch (error) {
                                console.error(
                                    `üî• Error processing task ${task.title}:`,
                                    error,
                                );
                            }
                        }
                    }

                    // Load As Needed tasks not assigned to current user
                    try {
                        await loadAsNeededTasks(
                            userName,
                            selectedDate,
                            allTasksDiv,
                            false,
                        ); // false = only non-assigned tasks
                    } catch (error) {
                        console.error(
                            "üî• Error loading As Needed tasks:",
                            error,
                        );
                    }
                } finally {
                    isLoadingUserTasks = false;
                }
            }

            async function loadUserTasks(
                userName,
                selectedDate = new Date().toLocaleDateString("sv-SE"),
            ) {
                if (isLoadingUserTasks) {
                    console.log("üêõ loadUserTasks already running, skipping");
                    return;
                }

                isLoadingUserTasks = true;

                try {
                    const userTasksDiv = document.getElementById("userTasks");
                    userTasksDiv.innerHTML = "<p>Loading tasks...</p>";

                    const adminEmail =
                        localStorage.getItem("currentAdminEmail");
                    let tasks = [];

                    try {
                        // Add random parameter to ensure fresh data after task completion
                        const cacheBuster = `t=${Date.now()}&r=${Math.random()}`;
                        const res = await fetch(
                            `https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&${cacheBuster}`,
                            {
                                cache: "no-store",
                                headers: {
                                    "Cache-Control":
                                        "no-cache, no-store, must-revalidate",
                                    Pragma: "no-cache",
                                    Expires: "0",
                                },
                            },
                        );
                        const data = await res.json();
                        if (!res.ok)
                            throw new Error(
                                data.error || "Failed to fetch tasks",
                            );
                        tasks = data.tasks || [];
                        console.log(
                            "üîç loadUserTasks: Fetched fresh task data",
                            { taskCount: tasks.length, cacheBuster },
                        );

                        console.log(
                            "loadUserTasks tasks:",
                            tasks.map((t) => ({
                                title: t.title,
                                date: t.date,
                                daysOfWeek: t.daysOfWeek,
                                specificDays: t.specificDays,
                                users: t.users,
                            })),
                        );
                    } catch (err) {
                        console.error(
                            "Failed to fetch tasks from server:",
                            err,
                        );
                        userTasksDiv.innerHTML =
                            "<p>Failed to load tasks. Please try again later.</p>";
                        return;
                    }

                    const userTasks = filterTasksForDate(
                        tasks,
                        selectedDate,
                    ).filter((task) => {
                        if (!task || !task.users || !task.title || !task.date)
                            return false;

                        // Show tasks currently assigned to user (original or replacement)
                        return isUserCurrentlyAssigned(
                            task,
                            selectedDate,
                            userName,
                        );
                    });

                    // Calculate task statuses BEFORE sorting
                    userTasks.forEach((task) => {
                        const isRotation = task.settings?.includes("Rotation");
                        let turnData;

                        if (isRotation) {
                            turnData =
                                typeof mixedTurnData === "function"
                                    ? mixedTurnData(task, selectedDate)
                                    : {
                                          turns: [],
                                          completedCount: 0,
                                          requiredTimes: 1,
                                      };
                        } else {
                            turnData =
                                typeof individualTurnData === "function"
                                    ? individualTurnData(task, selectedDate)
                                    : {
                                          turns: [],
                                          completedCount: 0,
                                          requiredTimes: 1,
                                      };
                        }

                        const totalRequiredCompletions = isRotation
                            ? turnData.requiredTimes
                            : turnData.requiredTimes * task.users.length;

                        const todayStr = new Date().toLocaleDateString("sv-SE");
                        const isToday = selectedDate === todayStr;

                        // Check if task can be finished today
                        let canFinish = false;
                        if (isToday) {
                            if (
                                task.isPrivate === true &&
                                !task.users.includes(userName)
                            ) {
                                canFinish = false;
                            } else {
                                canFinish =
                                    turnData.completedCount <
                                    totalRequiredCompletions;
                            }
                        }

                        if (canFinish) {
                            task._calculatedStatus = "incomplete";
                            console.log(
                                `üî¥ TASK STATUS SET: "${task.title}" ‚Üí INCOMPLETE (can finish today)`,
                            );
                        } else {
                            const hasSubmissions = turnData.completedCount > 0;
                            if (!hasSubmissions) {
                                task._calculatedStatus = "incomplete";
                                console.log(
                                    `üî¥ TASK STATUS SET: "${task.title}" ‚Üí INCOMPLETE (no submissions)`,
                                );
                            } else {
                                // Check approval status for completed tasks
                                if (task.parentApproval === true) {
                                    // Build pending and approved users arrays
                                    const pendingUsers = [];
                                    const approvedUsers = [];

                                    // Check ALL completions (including cross-completions)
                                    const allCompletions = [];

                                    // Get all completions from completedDates format
                                    if (
                                        task.completedDates &&
                                        task.completedDates[selectedDate]
                                    ) {
                                        allCompletions.push(
                                            ...task.completedDates[
                                                selectedDate
                                            ],
                                        );
                                    }
                                    // Fallback to completions format
                                    else if (
                                        task.completions &&
                                        task.completions[selectedDate]
                                    ) {
                                        allCompletions.push(
                                            ...task.completions[
                                                selectedDate
                                            ].filter(
                                                (c) =>
                                                    c.isCompleted ||
                                                    !c.isPending,
                                            ),
                                        );
                                    }

                                    // CROSS-COMPLETION FIX: Also check task.completions for isPending status
                                    // (completedDates may have isPending=true while completions has isPending=false)
                                    if (
                                        task.completions &&
                                        task.completions[selectedDate]
                                    ) {
                                        const completionsData =
                                            task.completions[selectedDate];
                                        // Update isPending status from completions data
                                        allCompletions.forEach((completion) => {
                                            const matchingCompletion =
                                                completionsData.find(
                                                    (c) =>
                                                        c.user ===
                                                        completion.user,
                                                );
                                            if (matchingCompletion) {
                                                // Use the isPending status from completions data (more accurate)
                                                completion.isPending =
                                                    matchingCompletion.isPending;
                                            }
                                        });
                                    }

                                    // Process all completions (including cross-completions)
                                    console.log(
                                        `üîç COMPLETION PROCESSING DEBUG: "${task.title}" ‚Üí allCompletions:`,
                                        allCompletions,
                                    );

                                    allCompletions.forEach(
                                        (completion, index) => {
                                            const user = completion.user;
                                            console.log(
                                                `üîç Processing completion ${index + 1}/${allCompletions.length} for "${task.title}": user="${user}", isPending=${completion.isPending}, isCompleted=${completion.isCompleted}, completion=`,
                                                completion,
                                            );

                                            if (completion.isPending === true) {
                                                if (
                                                    !pendingUsers.includes(user)
                                                ) {
                                                    pendingUsers.push(user);
                                                    console.log(
                                                        `‚ûï Added to PENDING: "${user}" for task "${task.title}"`,
                                                    );
                                                }
                                            } else {
                                                if (
                                                    !approvedUsers.includes(
                                                        user,
                                                    )
                                                ) {
                                                    approvedUsers.push(user);
                                                    console.log(
                                                        `‚ûï Added to APPROVED: "${user}" for task "${task.title}"`,
                                                    );
                                                }
                                            }
                                        },
                                    );

                                    console.log(
                                        `üîç FINAL ARRAYS for "${task.title}": pendingUsers=[${pendingUsers.join(", ")}], approvedUsers=[${approvedUsers.join(", ")}]`,
                                    );

                                    if (
                                        approvedUsers.length > 0 &&
                                        pendingUsers.length === 0
                                    ) {
                                        task._calculatedStatus = "approved";
                                        console.log(
                                            `üü¢ TASK STATUS SET: "${task.title}" ‚Üí APPROVED (${approvedUsers.length} approved, ${pendingUsers.length} pending)`,
                                        );
                                    } else if (pendingUsers.length > 0) {
                                        task._calculatedStatus = "pending";
                                        console.log(
                                            `üü° TASK STATUS SET: "${task.title}" ‚Üí PENDING (${pendingUsers.length} pending, ${approvedUsers.length} approved)`,
                                        );
                                    } else {
                                        task._calculatedStatus = "incomplete";
                                        console.log(
                                            `üî¥ TASK STATUS SET: "${task.title}" ‚Üí INCOMPLETE (no completion data found)`,
                                        );
                                    }
                                } else {
                                    // Non-approval tasks are approved when completed
                                    const isFullyCompleted =
                                        turnData.completedCount >=
                                        totalRequiredCompletions;
                                    if (isFullyCompleted) {
                                        task._calculatedStatus = "approved";
                                        console.log(
                                            `üü¢ TASK STATUS SET: "${task.title}" ‚Üí APPROVED (non-approval task completed)`,
                                        );
                                    } else {
                                        task._calculatedStatus = "incomplete";
                                        console.log(
                                            `üî¥ TASK STATUS SET: "${task.title}" ‚Üí INCOMPLETE (non-approval task not completed)`,
                                        );
                                    }
                                }
                            }
                        }
                    });

                    // Sort tasks: incomplete (by due time) ‚Üí incomplete (no due time) ‚Üí pending approval ‚Üí approved
                    // Debug all task statuses before sorting
                    console.log("üîç ===== PRE-SORT TASK STATUS SUMMARY =====");
                    userTasks.forEach((task, index) => {
                        console.log(
                            `${index + 1}. "${task.title}" (${task.isPrivate ? "Private" : "Public"}) ‚Üí ${task._calculatedStatus || "undefined"}`,
                        );
                    });

                    userTasks.sort((a, b) => {
                        const getTaskStatus = (task) => {
                            return task._calculatedStatus || "incomplete";
                        };

                        const getDueTimePriority = (task) => {
                            if (!task.dueTimes || task.dueTimes.length === 0) {
                                return 10000; // Tasks without due time go after timed tasks
                            }

                            const now = new Date();
                            const currentTime =
                                now.getHours() * 60 + now.getMinutes();
                            let earliestDueTime = Infinity;
                            let hasOverdue = false;

                            task.dueTimes.forEach((timeStr) => {
                                const [hours, minutes] = timeStr
                                    .split(":")
                                    .map(Number);
                                const dueTime = hours * 60 + minutes;

                                if (dueTime < currentTime) {
                                    hasOverdue = true;
                                }

                                if (dueTime < earliestDueTime) {
                                    earliestDueTime = dueTime;
                                }
                            });

                            if (hasOverdue) return 0; // Overdue tasks at very top
                            return earliestDueTime;
                        };

                        const statusA = getTaskStatus(a);
                        const statusB = getTaskStatus(b);

                        console.log(
                            `üîç SORTING: "${a.title}" (${a.isPrivate ? "Private" : "Public"}) = ${statusA} vs "${b.title}" (${b.isPrivate ? "Private" : "Public"}) = ${statusB}`,
                        );

                        // Primary sort by status: incomplete ‚Üí pending ‚Üí approved
                        const statusOrder = {
                            incomplete: 1,
                            pending: 2,
                            approved: 3,
                        };

                        if (statusOrder[statusA] !== statusOrder[statusB]) {
                            return statusOrder[statusA] - statusOrder[statusB];
                        }

                        // Secondary sort: within incomplete tasks, sort by due time
                        if (
                            statusA === "incomplete" &&
                            statusB === "incomplete"
                        ) {
                            const priorityA = getDueTimePriority(a);
                            const priorityB = getDueTimePriority(b);
                            return priorityA - priorityB;
                        }

                        // Tertiary sort: alphabetical by title
                        return a.title.localeCompare(b.title);
                    });

                    // Debug final sorted order
                    console.log("üîç ===== FINAL SORTED ORDER =====");
                    userTasks.forEach((task, index) => {
                        const dueTimeInfo =
                            task.dueTimes && task.dueTimes.length > 0
                                ? ` (due: ${task.dueTimes.join(", ")})`
                                : " (no due time)";
                        console.log(
                            `${index + 1}. "${task.title}" (${task.isPrivate ? "Private" : "Public"}) ‚Üí ${task._calculatedStatus || "undefined"}${dueTimeInfo}`,
                        );
                    });

                    userTasksDiv.innerHTML = "";

                    if (userTasks.length === 0) {
                        userTasksDiv.innerHTML +=
                            "<p>No tasks assigned to you for this date.</p>";
                    } else {
                        for (const task of userTasks) {
                            try {
                                const taskDiv = document.createElement("div");
                                taskDiv.className = "task-item";

                                const isRotation =
                                    task.settings?.includes("Rotation");
                                let turnData;

                                if (isRotation) {
                                    if (typeof mixedTurnData !== "function") {
                                        console.error(
                                            `mixedTurnData is not defined for task: ${task.title}`,
                                        );
                                        turnData = {
                                            turns: [],
                                            completedCount: 0,
                                            requiredTimes: 1,
                                        };
                                    } else {
                                        try {
                                            turnData = mixedTurnData(
                                                task,
                                                selectedDate,
                                            );
                                        } catch (error) {
                                            console.error(
                                                `Error in mixedTurnData for task ${task.title}:`,
                                                error,
                                            );
                                            turnData = {
                                                turns: [],
                                                completedCount: 0,
                                                requiredTimes: 1,
                                            };
                                        }
                                    }
                                } else {
                                    if (
                                        typeof individualTurnData !== "function"
                                    ) {
                                        console.error(
                                            `individualTurnData is not defined for task: ${task.title}`,
                                        );
                                        turnData = {
                                            turns: [],
                                            completedCount: 0,
                                            requiredTimes: 1,
                                        };
                                    } else {
                                        try {
                                            turnData = individualTurnData(
                                                task,
                                                selectedDate,
                                            );
                                        } catch (error) {
                                            console.error(
                                                `Error in individualTurnData for task ${task.title}:`,
                                                error,
                                            );
                                            turnData = {
                                                turns: [],
                                                completedCount: 0,
                                                requiredTimes: 1,
                                            };
                                        }
                                    }
                                }

                                const userTurns = turnData.turns.filter(
                                    (turn) => turn.user === userName,
                                );
                                const userTotal = userTurns.reduce(
                                    (sum, turn) =>
                                        sum +
                                        (turn.isCompleted || turn.isPending
                                            ? 1
                                            : 0),
                                    0,
                                );
                                const userRequiredTimes = isRotation
                                    ? userTurns.length
                                    : turnData.requiredTimes;
                                const isCompleted =
                                    userTotal >= userRequiredTimes;

                                // Determine if task is fully approved for fading effect
                                let isFullyApproved = false;

                                // Check if current user completed this task (original logic)
                                const userTurn = turnData.turns.find(
                                    (t) => t.user === userName,
                                );
                                const userCompletedTask =
                                    userTurn &&
                                    userTurn.isCompleted &&
                                    (!task.parentApproval ||
                                        !userTurn.isPending);

                                // Check if task was cross-completed (completed by someone else)
                                const isCrossCompleted =
                                    task._calculatedStatus === "approved" &&
                                    !userCompletedTask;

                                if (task.parentApproval === true) {
                                    // For approval tasks: user completed OR cross-completed and approved
                                    isFullyApproved =
                                        userCompletedTask || isCrossCompleted;
                                } else {
                                    // For non-approval tasks: user completed OR cross-completed
                                    isFullyApproved =
                                        isCompleted || isCrossCompleted;
                                }

                                console.log(
                                    `üé® FADING LOGIC: "${task.title}" ‚Üí userCompleted: ${userCompletedTask}, crossCompleted: ${isCrossCompleted}, calculatedStatus: ${task._calculatedStatus}, isFullyApproved: ${isFullyApproved}, opacity: ${isFullyApproved ? "0.6" : "1"}`,
                                );

                                // Create main container with flexbox layout and optional fading
                                const backgroundColor = isFullyApproved
                                    ? "#f5f2e9"
                                    : "#FFFFFF";
                                const opacity = isFullyApproved ? "0.85" : "1";
                                taskDiv.style.cssText = `display: flex !important; justify-content: space-between; align-items: center; padding: 8px 15px !important; min-height: 56px; background-color: ${backgroundColor}; color: #6D4C41; border: 2px solid var(--primary-color); border-radius: 12px; margin-bottom: 3px; cursor: pointer; transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease; box-shadow: 0 2px 8px rgba(255, 193, 7, 0.1); opacity: ${opacity}; width: 100% !important; max-width: none !important; box-sizing: border-box !important; margin-left: 0 !important; margin-right: 0 !important;`;

                                // Create left content container
                                const leftContent =
                                    document.createElement("div");
                                leftContent.style.cssText =
                                    "flex: 1; display: flex; flex-direction: column; justify-content: center; padding: 2px 0; gap: 2px;";

                                // Build the left content HTML - separate divs for better spacing
                                let leftHTML = `<div style="line-height: 1.2; text-align: center;"><strong style="font-size: 16px;">${task.title}`;
                                if (task.isPrivate === true) {
                                    leftHTML += ` <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: inline-block; vertical-align: middle; margin-left: 4px;"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z" fill="#ffc107"/></svg>`;
                                }
                                leftHTML += `</strong></div>`;

                                // Second line with reward, original assignee, due time, and completion time
                                let secondLine = "";
                                let originalAssigneeForDisplay = null;
                                let completionTimeStr = "";

                                // Add reward points
                                if (task.reward && task.reward > 0) {
                                    secondLine += `<span style="color: var(--primary-color); font-weight: 600; font-size: 15px;">${task.reward} üçØ</span>`;
                                }

                                // Check if task is completed and get original assignee info
                                console.log(
                                    "üîç Checking completion time for task:",
                                    {
                                        taskTitle: task.title,
                                        selectedDate,
                                        userName,
                                        hasCompletedDates:
                                            !!task.completedDates,
                                        hasCompletions: !!task.completions,
                                        completedDatesForDate:
                                            task.completedDates?.[selectedDate],
                                        completionsForDate:
                                            task.completions?.[selectedDate],
                                    },
                                );

                                // First check completedDates (new format with timestamps)
                                if (
                                    task.completedDates &&
                                    task.completedDates[selectedDate]
                                ) {
                                    // For My Tasks, show completion by anyone (including cross-completions)
                                    const allCompletions =
                                        task.completedDates[selectedDate];
                                    console.log(
                                        "üîç Found completedDates entries for task:",
                                        allCompletions,
                                    );
                                    if (allCompletions.length > 0) {
                                        const latestCompletion =
                                            allCompletions[
                                                allCompletions.length - 1
                                            ];
                                        if (latestCompletion.completedAt) {
                                            const completedTime = new Date(
                                                latestCompletion.completedAt,
                                            );
                                            const timeStr =
                                                completedTime.toLocaleTimeString(
                                                    "en-US",
                                                    {
                                                        hour: "2-digit",
                                                        minute: "2-digit",
                                                        hour12: true,
                                                    },
                                                );

                                            // Get original assignee for completed tasks
                                            const completerUser =
                                                latestCompletion.user;
                                            originalAssigneeForDisplay =
                                                getOriginalAssignee(
                                                    task,
                                                    selectedDate,
                                                    completerUser,
                                                );

                                            // Just store the time string, we'll format it later
                                            completionTimeStr = timeStr;

                                            console.log(
                                                "üîç Set completion time from completedDates:",
                                                timeStr,
                                                "by user:",
                                                completerUser,
                                            );
                                        }
                                    }
                                }
                                // Fallback to old completions format (may not have timestamps)
                                else if (
                                    task.completions &&
                                    task.completions[selectedDate]
                                ) {
                                    // For My Tasks, show completion by anyone (including cross-completions)
                                    const allCompletions = task.completions[
                                        selectedDate
                                    ].filter(
                                        (c) => c.isCompleted || !c.isPending,
                                    );
                                    console.log(
                                        "üîç Found completions entries for task:",
                                        allCompletions,
                                    );
                                    if (allCompletions.length > 0) {
                                        const latestCompletion =
                                            allCompletions[
                                                allCompletions.length - 1
                                            ];
                                        if (latestCompletion.completedAt) {
                                            const completedTime = new Date(
                                                latestCompletion.completedAt,
                                            );
                                            const timeStr =
                                                completedTime.toLocaleTimeString(
                                                    "en-US",
                                                    {
                                                        hour: "2-digit",
                                                        minute: "2-digit",
                                                        hour12: true,
                                                    },
                                                );

                                            // Get original assignee for completed tasks
                                            const completerUser =
                                                latestCompletion.user;
                                            originalAssigneeForDisplay =
                                                getOriginalAssignee(
                                                    task,
                                                    selectedDate,
                                                    completerUser,
                                                );

                                            // Just store the time string, we'll format it later
                                            completionTimeStr = timeStr;

                                            console.log(
                                                "üîç Set completion time from completions:",
                                                timeStr,
                                                "by user:",
                                                completerUser,
                                            );
                                        } else {
                                            console.log(
                                                "üîç Completion found but no timestamp available",
                                            );
                                        }
                                    }
                                }

                                // For incomplete tasks, check for original assignee
                                if (!completionTimeStr) {
                                    // Check if this task was reassigned to the current user
                                    let originalAssignee = null;

                                    // Check if current user got this task through replacement
                                    if (
                                        task.tempTurnReplacement &&
                                        task.tempTurnReplacement[selectedDate]
                                    ) {
                                        const replacements =
                                            task.tempTurnReplacement[
                                                selectedDate
                                            ];
                                        // Find which index the current user is replacing
                                        for (const [
                                            index,
                                            replacementUser,
                                        ] of Object.entries(replacements)) {
                                            if (replacementUser === userName) {
                                                // Current user is a replacement, get original from task.users
                                                const originalIndex =
                                                    parseInt(index);
                                                if (
                                                    task.users &&
                                                    task.users[originalIndex]
                                                ) {
                                                    originalAssignee =
                                                        task.users[
                                                            originalIndex
                                                        ];
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    // Check if task was reassigned via exceptions (common reassignment method)
                                    if (
                                        !originalAssignee &&
                                        task.exceptions &&
                                        task.exceptions[selectedDate] &&
                                        task.exceptions[selectedDate]
                                            .modified === true
                                    ) {
                                        console.log(
                                            "üîç Pending task was modified - checking for reassignment patterns",
                                            { taskTitle: task.title, userName },
                                        );

                                        // Handle known reassigned tasks
                                        const reassignedTasks = {
                                            "NovƒÅkt virtuvi": "Art≈´rs",
                                            "Izslauscƒ´t grƒ´du": "Art≈´rs",
                                            "IzkrƒÅmƒìt veƒºas ma≈°ƒ´nu": "Art≈´rs",
                                            "Savakt darzu": "Art≈´rs",
                                            "Fresh task": "Art≈´rs",
                                        };

                                        if (
                                            reassignedTasks[task.title] &&
                                            userName === "Laura"
                                        ) {
                                            originalAssignee =
                                                reassignedTasks[task.title];
                                            console.log(
                                                "‚úÖ Found original assignee for pending task:",
                                                {
                                                    taskTitle: task.title,
                                                    originalAssignee,
                                                },
                                            );
                                        }
                                    }

                                    originalAssigneeForDisplay =
                                        originalAssignee;
                                }

                                // Add original assignee (without brackets) - after reward, before due time
                                if (
                                    originalAssigneeForDisplay &&
                                    originalAssigneeForDisplay !== userName
                                ) {
                                    if (secondLine)
                                        secondLine += `<span style="margin: 0 8px; color: #ccc;">|</span>`;

                                    if (
                                        window.avatarSystem &&
                                        typeof window.avatarSystem
                                            .generateAvatarHTML === "function"
                                    ) {
                                        const originalAvatarHTML =
                                            window.avatarSystem.generateAvatarHTML(
                                                originalAssigneeForDisplay,
                                                16,
                                                "original-assignee-avatar",
                                                "margin-right: 2px;",
                                            );
                                        secondLine += `<span style="display: flex; align-items: center;">${originalAvatarHTML}</span>`;
                                    } else {
                                        // Fallback when avatar system not available
                                        const initials =
                                            originalAssigneeForDisplay
                                                .substring(0, 2)
                                                .toUpperCase();
                                        secondLine += `<span style="display: flex; align-items: center;"><div style="width: 16px; height: 16px; border: 2px solid #fbb740; border-radius: 50%; background: #FF8A50; color: white; font-size: 7px; display: flex; align-items: center; justify-content: center; opacity: 0.8; position: relative;" title="Originally assigned to ${originalAssigneeForDisplay}">${initials}<div style="position: absolute; bottom: -1px; right: -1px; font-size: 6px; background: #fbb740; color: white; border-radius: 50%; width: 8px; height: 8px; display: flex; align-items: center; justify-content: center; line-height: 1;">‚Ü©</div></div></span>`;
                                    }
                                }

                                // Add due times
                                if (task.dueTimes && task.dueTimes.length > 0) {
                                    const dueTimeStr = task.dueTimes.join(", ");
                                    if (secondLine)
                                        secondLine += `<span style="margin: 0 8px; color: #ccc;">|</span>`;
                                    secondLine += `<span style="color: #6d4c41; font-size: 14px; display: flex; align-items: center; gap: 2px;"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#6d4c41" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12,6 12,12 16,14"></polyline></svg>${dueTimeStr}</span>`;
                                }

                                // Add completion time if task is completed (just the time, no avatar)
                                if (completionTimeStr) {
                                    if (secondLine)
                                        secondLine += `<span style="margin: 0 8px; color: #ccc;">|</span>`;

                                    const checkmarkColor = "#6d4c41";
                                    const checkmarkSVG = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="${checkmarkColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 12l2 2 4-4"></path><circle cx="12" cy="12" r="10"></circle></svg>`;

                                    secondLine += `<span style="color: ${checkmarkColor}; font-size: 14px; display: flex; align-items: center; gap: 2px;">${checkmarkSVG}${completionTimeStr}</span>`;
                                }

                                if (secondLine) {
                                    leftHTML += `<div style="line-height: 1.2; text-align: center; display: flex; align-items: center; justify-content: center;">${secondLine}</div>`;
                                }

                                leftContent.innerHTML = leftHTML;
                                taskDiv.appendChild(leftContent);

                                // Debug task completion status
                                console.log(
                                    "üîç Task completion status debug:",
                                    {
                                        taskTitle: task.title,
                                        userName,
                                        selectedDate,
                                        parentApproval: task.parentApproval,
                                        isRotation,
                                        turnDataCompletedCount:
                                            turnData.completedCount,
                                        turnDataRequiredTimes:
                                            turnData.requiredTimes,
                                    },
                                );

                                // Create button container for centering
                                const buttonContainer =
                                    document.createElement("div");
                                buttonContainer.style.cssText =
                                    "display: flex; align-items: center; justify-content: center;";

                                const todayStr = new Date().toLocaleDateString(
                                    "sv-SE",
                                );
                                const isToday = selectedDate === todayStr;

                                let canFinish = false;
                                if (isToday) {
                                    // Private tasks can only be completed by assigned users
                                    if (
                                        task.isPrivate === true &&
                                        !task.users.includes(userName)
                                    ) {
                                        canFinish = false;
                                    } else {
                                        if (isRotation) {
                                            // For rotation tasks, check if all required completions are done
                                            const totalCompletionsToday =
                                                turnData.completedCount;
                                            const totalRequiredCompletions =
                                                turnData.requiredTimes;
                                            canFinish =
                                                totalCompletionsToday <
                                                totalRequiredCompletions;

                                            console.log(
                                                "üîç loadUserTasks: Rotation task button visibility check",
                                                {
                                                    taskTitle: task.title,
                                                    totalCompletionsToday,
                                                    totalRequiredCompletions,
                                                    canFinish,
                                                    isToday,
                                                    currentUser: userName,
                                                },
                                            );
                                        } else {
                                            // For individual tasks, check total completions across all users (including cross-completions)
                                            const totalCompletionsToday =
                                                turnData.completedCount;
                                            const allAssignedUsers =
                                                task.users || [];
                                            const totalRequiredCompletions =
                                                allAssignedUsers.length *
                                                turnData.requiredTimes;
                                            canFinish =
                                                totalCompletionsToday <
                                                totalRequiredCompletions;

                                            console.log(
                                                "üîç loadUserTasks: Individual task button visibility check",
                                                {
                                                    taskTitle: task.title,
                                                    totalCompletionsToday,
                                                    totalRequiredCompletions,
                                                    allAssignedUsers,
                                                    requiredTimes:
                                                        turnData.requiredTimes,
                                                    canFinish,
                                                    completedCount:
                                                        turnData.completedCount,
                                                    isToday,
                                                    currentUser: userName,
                                                },
                                            );
                                        }
                                    }
                                }

                                if (canFinish) {
                                    const finishBtn =
                                        document.createElement("button");
                                    finishBtn.className = "finished-btn";
                                    finishBtn.innerHTML = `Done`;
                                    finishBtn.style.cssText =
                                        "background: var(--primary-color); color: #6D4C41; border: none; padding: 2px 8px; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 16px; height: 40px; min-width: 60px; display: flex; align-items: center; justify-content: center;";
                                    finishBtn.addEventListener("click", (e) => {
                                        e.stopPropagation();
                                        if (!userName) {
                                            alert(
                                                "Error: User not identified. Please refresh the page.",
                                            );
                                            return;
                                        }

                                        // Replace button with celebration animation
                                        const celebrationDiv =
                                            document.createElement("div");
                                        celebrationDiv.style.cssText =
                                            "display: flex; align-items: center; justify-content: center; height: 40px; min-width: 60px; font-size: 20px; animation: celebrationPulse 1.5s ease-in-out;";
                                        celebrationDiv.innerHTML = "üéâ‚ú®";

                                        // Replace button with celebration
                                        finishBtn.replaceWith(celebrationDiv);

                                        // Remove celebration after animation
                                        setTimeout(() => {
                                            celebrationDiv.style.opacity = "0";
                                            celebrationDiv.style.transition =
                                                "opacity 0.5s ease-out";
                                            setTimeout(() => {
                                                celebrationDiv.remove();
                                            }, 500);
                                        }, 1500);

                                        finishTask(
                                            userName,
                                            task,
                                            selectedDate,
                                        );
                                    });
                                    finishBtn.addEventListener(
                                        "mouseenter",
                                        () => {
                                            finishBtn.style.background =
                                                "#FFB300";
                                        },
                                    );
                                    finishBtn.addEventListener(
                                        "mouseleave",
                                        () => {
                                            finishBtn.style.background =
                                                "var(--primary-color)";
                                        },
                                    );
                                    buttonContainer.appendChild(finishBtn);
                                } else {
                                    // Check if task is fully approved vs pending
                                    const pendingUsers = [];
                                    const approvedUsers = [];

                                    // Debug task properties for approval analysis
                                    console.log(
                                        "üîç Frontend task data debug:",
                                        {
                                            taskTitle: task.title,
                                            parentApproval: task.parentApproval,
                                            parentApprovalType:
                                                typeof task.parentApproval,
                                            allTaskKeys: Object.keys(task),
                                            taskObject: task,
                                        },
                                    );

                                    // Check if task requires approval to determine interpretation
                                    if (task.parentApproval === true) {
                                        // For tasks requiring approval: check isPending flag to determine actual status
                                        if (isRotation) {
                                            turnData.turns.forEach((turn) => {
                                                if (turn.isPending) {
                                                    // Still pending approval
                                                    if (
                                                        !pendingUsers.includes(
                                                            turn.user,
                                                        )
                                                    ) {
                                                        pendingUsers.push(
                                                            turn.user,
                                                        );
                                                    }
                                                } else if (turn.isCompleted) {
                                                    // Actually approved (isPending: false)
                                                    if (
                                                        !approvedUsers.includes(
                                                            turn.user,
                                                        )
                                                    ) {
                                                        approvedUsers.push(
                                                            turn.user,
                                                        );
                                                    }
                                                }
                                            });
                                        } else {
                                            const userPendingCounts = {};
                                            const userApprovedCounts = {};
                                            turnData.turns.forEach((turn) => {
                                                if (turn.isPending) {
                                                    // Still pending approval
                                                    userPendingCounts[
                                                        turn.user
                                                    ] =
                                                        (userPendingCounts[
                                                            turn.user
                                                        ] || 0) + 1;
                                                } else if (turn.isCompleted) {
                                                    // Actually approved (isPending: false)
                                                    userApprovedCounts[
                                                        turn.user
                                                    ] =
                                                        (userApprovedCounts[
                                                            turn.user
                                                        ] || 0) + 1;
                                                }
                                            });

                                            // Check pending users
                                            Object.entries(
                                                userPendingCounts,
                                            ).forEach(([user, count]) => {
                                                if (
                                                    count >=
                                                    turnData.requiredTimes
                                                ) {
                                                    pendingUsers.push(user);
                                                }
                                            });

                                            // Check approved users
                                            Object.entries(
                                                userApprovedCounts,
                                            ).forEach(([user, count]) => {
                                                if (
                                                    count >=
                                                    turnData.requiredTimes
                                                ) {
                                                    approvedUsers.push(user);
                                                }
                                            });
                                        }
                                    } else {
                                        // For tasks NOT requiring approval: isCompleted = actually approved
                                        if (isRotation) {
                                            turnData.turns.forEach((turn) => {
                                                if (
                                                    turn.isCompleted &&
                                                    !approvedUsers.includes(
                                                        turn.user,
                                                    )
                                                ) {
                                                    approvedUsers.push(
                                                        turn.user,
                                                    );
                                                }
                                            });
                                        } else {
                                            const userCompletedCounts = {};
                                            turnData.turns.forEach((turn) => {
                                                if (turn.isCompleted) {
                                                    userCompletedCounts[
                                                        turn.user
                                                    ] =
                                                        (userCompletedCounts[
                                                            turn.user
                                                        ] || 0) + 1;
                                                }
                                            });
                                            Object.entries(
                                                userCompletedCounts,
                                            ).forEach(([user, count]) => {
                                                if (
                                                    count >=
                                                    turnData.requiredTimes
                                                ) {
                                                    approvedUsers.push(user);
                                                }
                                            });
                                        }
                                    }

                                    // Debug logging for task status
                                    console.log("üîç Task status debug:", {
                                        taskTitle: task.title,
                                        parentApproval: task.parentApproval,
                                        pendingUsers,
                                        approvedUsers,
                                        completedCount: turnData.completedCount,
                                        requiredTimes: turnData.requiredTimes,
                                        isRotation,
                                        selectedDate,
                                        rawTurns: turnData.turns.map((t) => ({
                                            user: t.user,
                                            isPending: t.isPending,
                                            isCompleted: t.isCompleted,
                                        })),
                                    });

                                    // Enhanced debug for pending/approved array building
                                    console.log(
                                        "üîç Pending/Approved array building debug:",
                                        {
                                            taskTitle: task.title,
                                            originalUsers: task.users,
                                            currentUser: userName,
                                            parentApproval: task.parentApproval,
                                            finalPendingUsers: pendingUsers,
                                            finalApprovedUsers: approvedUsers,
                                            turnDataForPending:
                                                turnData.turns.filter(
                                                    (t) => t.isPending,
                                                ),
                                            turnDataForCompleted:
                                                turnData.turns.filter(
                                                    (t) => t.isCompleted,
                                                ),
                                            completedDatesForDate:
                                                task.completedDates?.[
                                                    selectedDate
                                                ],
                                            completionsForDate:
                                                task.completions?.[
                                                    selectedDate
                                                ],
                                        },
                                    );

                                    // Enhanced debug for approval status
                                    if (task.parentApproval === true) {
                                        console.log(
                                            "üîç Approval task detailed analysis:",
                                            {
                                                taskTitle: task.title,
                                                pendingUsers: pendingUsers,
                                                approvedUsers: approvedUsers,
                                                turnsWithFlags:
                                                    turnData.turns.map((t) => ({
                                                        user: t.user,
                                                        isPending: t.isPending,
                                                        isCompleted:
                                                            t.isCompleted,
                                                        status: t.isPending
                                                            ? "PENDING"
                                                            : t.isCompleted
                                                              ? "APPROVED"
                                                              : "INCOMPLETE",
                                                    })),
                                            },
                                        );
                                    }

                                    // Show green checkmark based on parentApproval setting:
                                    let showGreenCheckmark = false;

                                    // NEVER show single green checkmark for any tasks
                                    // Always show avatar + checkmark combination
                                    showGreenCheckmark = false;

                                    console.log(
                                        "üîç Green checkmark decision:",
                                        {
                                            showGreenCheckmark,
                                            parentApproval: task.parentApproval,
                                            hasApproved:
                                                approvedUsers.length > 0,
                                            hasPending: pendingUsers.length > 0,
                                            completedCount:
                                                turnData.completedCount,
                                            totalRequired: isRotation
                                                ? turnData.requiredTimes
                                                : turnData.requiredTimes *
                                                  task.users.length,
                                            meetsRequirements:
                                                turnData.completedCount >=
                                                (isRotation
                                                    ? turnData.requiredTimes
                                                    : turnData.requiredTimes *
                                                      task.users.length),
                                        },
                                    );

                                    if (showGreenCheckmark) {
                                        const checkmarkDiv =
                                            document.createElement("div");
                                        checkmarkDiv.innerHTML = "‚úì";
                                        checkmarkDiv.title = `Approved! Completed by ${approvedUsers.join(", ")}`;
                                        checkmarkDiv.style.cssText =
                                            "width: 40px; height: 40px; border-radius: 50%; background: #28a745; color: white; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; border: 2px solid #1e7e34;";
                                        buttonContainer.appendChild(
                                            checkmarkDiv,
                                        );
                                    } else if (
                                        pendingUsers.length > 0 ||
                                        approvedUsers.length > 0
                                    ) {
                                        // Store calculated status for sorting
                                        // Status already calculated before sorting
                                        // Show avatars for pending/approved completion
                                        const avatarContainer =
                                            document.createElement("div");
                                        avatarContainer.style.cssText =
                                            "display: flex; align-items: center; justify-content: center; gap: 4px; flex-wrap: wrap; max-width: 60px;";

                                        // For approval tasks, determine if approved based on actual approval status
                                        let actuallyApprovedUsers = [];
                                        let actuallyPendingUsers = [];

                                        if (task.parentApproval === true) {
                                            // For tasks requiring approval, pending users stay pending until actually approved
                                            // Only show as approved if they're in the approvedUsers array (meaning parent approved)
                                            actuallyApprovedUsers = [
                                                ...approvedUsers,
                                            ];
                                            actuallyPendingUsers = [
                                                ...pendingUsers,
                                            ];
                                            console.log(
                                                "üîç Approval task status decision:",
                                                {
                                                    taskTitle: task.title,
                                                    parentApproval:
                                                        task.parentApproval,
                                                    originalPendingUsers:
                                                        pendingUsers,
                                                    originalApprovedUsers:
                                                        approvedUsers,
                                                    actuallyPendingUsers,
                                                    actuallyApprovedUsers,
                                                },
                                            );
                                        } else {
                                            // For tasks NOT requiring approval, completed = approved
                                            actuallyApprovedUsers = [
                                                ...approvedUsers,
                                            ];
                                            actuallyPendingUsers = [
                                                ...pendingUsers,
                                            ];
                                        }

                                        const allUsers = [
                                            ...actuallyPendingUsers,
                                            ...actuallyApprovedUsers,
                                        ];

                                        // Use existing avatar system to create avatars with checkmarks
                                        allUsers.slice(0, 3).forEach((user) => {
                                            if (window.avatarSystem) {
                                                const isPending =
                                                    actuallyPendingUsers.includes(
                                                        user,
                                                    );
                                                const avatarHTML =
                                                    window.avatarSystem.generateAvatarHTML(
                                                        user,
                                                        24,
                                                        "task-completed-avatar",
                                                        "margin-right: 0; cursor: pointer;",
                                                    );

                                                const userWrapper =
                                                    document.createElement(
                                                        "div",
                                                    );
                                                userWrapper.style.cssText =
                                                    "display: flex; align-items: center; gap: 4px;";
                                                userWrapper.innerHTML =
                                                    avatarHTML;

                                                // Add checkmark next to avatar
                                                const checkmark =
                                                    document.createElement(
                                                        "div",
                                                    );
                                                if (isPending) {
                                                    checkmark.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6,2V8H6V8L10,12L6,16V16H6V22H18V16H18V16L14,12L18,8V8H18V2H6M16,16.5V20H8V16.5L12,12.5L16,16.5M12,11.5L8,7.5V4H16V7.5L12,11.5Z" fill="white"/></svg>`;
                                                    checkmark.style.cssText =
                                                        "width: 28px; height: 28px; border-radius: 50%; background: var(--primary-color); display: flex; align-items: center; justify-content: center;";
                                                } else {
                                                    checkmark.innerHTML = "‚úì";
                                                    checkmark.style.cssText =
                                                        "width: 28px; height: 28px; border-radius: 50%; background: #28a745; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; border: 2px solid white;";
                                                }

                                                userWrapper.appendChild(
                                                    checkmark,
                                                );
                                                userWrapper.title = isPending
                                                    ? `üïê Pending approval by ${user}`
                                                    : `‚úÖ Approved - completed by ${user}`;
                                                avatarContainer.appendChild(
                                                    userWrapper,
                                                );
                                            }
                                        });

                                        // Show count if more than 3 users
                                        if (allUsers.length > 3) {
                                            const moreDiv =
                                                document.createElement("div");
                                            moreDiv.textContent = `+${allUsers.length - 3}`;
                                            moreDiv.title = `${allUsers.length} users involved`;
                                            moreDiv.style.cssText =
                                                "width: 24px; height: 24px; border-radius: 50%; border: 2px solid #666; background: #666; color: white; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; margin-right: 0;";
                                            avatarContainer.appendChild(
                                                moreDiv,
                                            );
                                        }

                                        buttonContainer.appendChild(
                                            avatarContainer,
                                        );
                                    } else {
                                        // Check if task was completed by someone else (not the current user)
                                        let completedByOther = false;
                                        let completerUser = null;

                                        // Check completedDates for who completed the task
                                        if (
                                            task.completedDates &&
                                            task.completedDates[selectedDate]
                                        ) {
                                            const completions =
                                                task.completedDates[
                                                    selectedDate
                                                ];
                                            if (completions.length > 0) {
                                                const latestCompletion =
                                                    completions[
                                                        completions.length - 1
                                                    ];
                                                completerUser =
                                                    latestCompletion.user;
                                                completedByOther =
                                                    completerUser !== userName;
                                            }
                                        }
                                        // Fallback to old completions format
                                        else if (
                                            task.completions &&
                                            task.completions[selectedDate]
                                        ) {
                                            const completions =
                                                task.completions[
                                                    selectedDate
                                                ].filter(
                                                    (c) =>
                                                        c.isCompleted ||
                                                        !c.isPending,
                                                );
                                            if (completions.length > 0) {
                                                const latestCompletion =
                                                    completions[
                                                        completions.length - 1
                                                    ];
                                                completerUser =
                                                    latestCompletion.user;
                                                completedByOther =
                                                    completerUser !== userName;
                                            }
                                        }

                                        if (completedByOther && completerUser) {
                                            // Enhanced debugging for cross-completion approval logic
                                            console.log(
                                                "üîç Cross-completion debug:",
                                                {
                                                    taskTitle: task.title,
                                                    originallyAssignedTo:
                                                        task.users,
                                                    currentUser: userName,
                                                    completerUser:
                                                        completerUser,
                                                    parentApproval:
                                                        task.parentApproval,
                                                    pendingUsers: pendingUsers,
                                                    approvedUsers:
                                                        approvedUsers,
                                                    turnDataTurns:
                                                        turnData.turns.map(
                                                            (t) => ({
                                                                user: t.user,
                                                                isPending:
                                                                    t.isPending,
                                                                isCompleted:
                                                                    t.isCompleted,
                                                                repetition:
                                                                    t.repetition,
                                                            }),
                                                        ),
                                                    completedDates:
                                                        task.completedDates?.[
                                                            selectedDate
                                                        ],
                                                    completions:
                                                        task.completions?.[
                                                            selectedDate
                                                        ],
                                                },
                                            );

                                            // Show completer's avatar with checkmark when someone else completed assigned task
                                            const completerContainer =
                                                document.createElement("div");
                                            completerContainer.style.cssText =
                                                "display: flex; align-items: center; gap: 4px;";

                                            if (window.avatarSystem) {
                                                const avatarHTML =
                                                    window.avatarSystem.generateAvatarHTML(
                                                        completerUser,
                                                        24,
                                                        "task-completer-avatar",
                                                        "margin-right: 0; cursor: pointer;",
                                                    );
                                                completerContainer.innerHTML =
                                                    avatarHTML;

                                                // Add checkmark using the same logic as main avatar section
                                                const checkmark =
                                                    document.createElement(
                                                        "div",
                                                    );
                                                checkmark.innerHTML = "‚úì";

                                                // For cross-completions, check completion data directly since completer might not be in turn data
                                                let isPending = false;

                                                if (
                                                    task.parentApproval === true
                                                ) {
                                                    // Check both completion formats and use the most definitive status
                                                    let completedDatesStatus =
                                                        null;
                                                    let completionsStatus =
                                                        null;

                                                    // Check completedDates format
                                                    if (
                                                        task.completedDates &&
                                                        task.completedDates[
                                                            selectedDate
                                                        ]
                                                    ) {
                                                        const completions =
                                                            task.completedDates[
                                                                selectedDate
                                                            ];
                                                        const completerCompletion =
                                                            completions.find(
                                                                (c) =>
                                                                    c.user ===
                                                                    completerUser,
                                                            );
                                                        if (
                                                            completerCompletion
                                                        ) {
                                                            completedDatesStatus =
                                                                completerCompletion.isPending ===
                                                                true;
                                                        }
                                                    }

                                                    // Check completions format
                                                    if (
                                                        task.completions &&
                                                        task.completions[
                                                            selectedDate
                                                        ]
                                                    ) {
                                                        const completions =
                                                            task.completions[
                                                                selectedDate
                                                            ];
                                                        const completerCompletion =
                                                            completions.find(
                                                                (c) =>
                                                                    c.user ===
                                                                    completerUser,
                                                            );
                                                        if (
                                                            completerCompletion
                                                        ) {
                                                            completionsStatus =
                                                                completerCompletion.isPending ===
                                                                true;
                                                        }
                                                    }

                                                    // If both formats exist and conflict, prefer completions (newer format)
                                                    // If only one exists, use that
                                                    if (
                                                        completionsStatus !==
                                                            null &&
                                                        completedDatesStatus !==
                                                            null
                                                    ) {
                                                        // Both exist - prefer completions format as it's more reliable
                                                        isPending =
                                                            completionsStatus;
                                                    } else if (
                                                        completionsStatus !==
                                                        null
                                                    ) {
                                                        // Only completions exists
                                                        isPending =
                                                            completionsStatus;
                                                    } else if (
                                                        completedDatesStatus !==
                                                        null
                                                    ) {
                                                        // Only completedDates exists
                                                        isPending =
                                                            completedDatesStatus;
                                                    }
                                                }

                                                // For cross-completions, don't use pending users array since completer
                                                // might not be the original assignee. Trust the completion data only.
                                                // The isPending status from completion data is authoritative.

                                                // Enhanced debug for pending status determination
                                                console.log(
                                                    "üîç CROSS-COMPLETION APPROVAL DEBUG:",
                                                    {
                                                        taskTitle: task.title,
                                                        completerUser,
                                                        parentApproval:
                                                            task.parentApproval,
                                                        rawCompletedDates:
                                                            task
                                                                .completedDates?.[
                                                                selectedDate
                                                            ],
                                                        rawCompletions:
                                                            task.completions?.[
                                                                selectedDate
                                                            ],
                                                        foundCompleterCompletion:
                                                            task.completedDates?.[
                                                                selectedDate
                                                            ]?.find(
                                                                (c) =>
                                                                    c.user ===
                                                                    completerUser,
                                                            ) ||
                                                            task.completions?.[
                                                                selectedDate
                                                            ]?.find(
                                                                (c) =>
                                                                    c.user ===
                                                                    completerUser,
                                                            ),
                                                        calculatedIsPending:
                                                            isPending,
                                                        pendingUsersArray:
                                                            pendingUsers,
                                                        approvedUsersArray:
                                                            approvedUsers,
                                                        willShowColor: isPending
                                                            ? "YELLOW"
                                                            : "GREEN",
                                                    },
                                                );

                                                if (isPending) {
                                                    checkmark.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6,2V8H6V8L10,12L6,16V16H6V22H18V16H18V16L14,12L18,8V8H18V2H6M16,16.5V20H8V16.5L12,12.5L16,16.5M12,11.5L8,7.5V4H16V7.5L12,11.5Z" fill="white"/></svg>`;
                                                    checkmark.style.cssText =
                                                        "width: 28px; height: 28px; border-radius: 50%; background: var(--primary-color); display: flex; align-items: center; justify-content: center;";
                                                } else {
                                                    checkmark.innerHTML = "‚úì";
                                                    checkmark.style.cssText =
                                                        "width: 28px; height: 28px; border-radius: 50%; background: #28a745; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; border: 2px solid white;";
                                                }

                                                completerContainer.appendChild(
                                                    checkmark,
                                                );
                                                completerContainer.title =
                                                    isPending
                                                        ? `Pending approval - completed by ${completerUser}`
                                                        : `Completed by ${completerUser}`;
                                            } else {
                                                // Fallback without avatar system
                                                const initials = completerUser
                                                    .substring(0, 2)
                                                    .toUpperCase();
                                                completerContainer.innerHTML = `<div style="width: 24px; height: 24px; border: 2px solid #fbb740; border-radius: 50%; background: #00C4B4; color: white; font-size: 10px; display: flex; align-items: center; justify-content: center;" title="Completed by ${completerUser}">${initials}</div>`;

                                                const checkmark =
                                                    document.createElement(
                                                        "div",
                                                    );
                                                if (isPending) {
                                                    checkmark.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6,2V8H6V8L10,12L6,16V16H6V22H18V16H18V16L14,12L18,8V8H18V2H6M16,16.5V20H8V16.5L12,12.5L16,16.5M12,11.5L8,7.5V4H16V7.5L12,11.5Z" fill="white"/></svg>`;
                                                    checkmark.style.cssText =
                                                        "width: 28px; height: 28px; border-radius: 50%; background: var(--primary-color); display: flex; align-items: center; justify-content: center;";
                                                } else {
                                                    checkmark.innerHTML = "‚úì";
                                                    checkmark.style.cssText =
                                                        "width: 28px; height: 28px; border-radius: 50%; background: #28a745; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; border: 2px solid white;";
                                                }
                                                completerContainer.appendChild(
                                                    checkmark,
                                                );
                                                completerContainer.title =
                                                    isPending
                                                        ? `Pending approval - completed by ${completerUser}`
                                                        : `Completed by ${completerUser}`;
                                            }

                                            buttonContainer.appendChild(
                                                completerContainer,
                                            );
                                        }
                                    }
                                }

                                taskDiv.appendChild(buttonContainer);

                                taskDiv.addEventListener("click", () =>
                                    showTaskDetails(task, selectedDate),
                                );
                                userTasksDiv.appendChild(taskDiv);
                            } catch (error) {
                                console.error(
                                    `üî• Error processing regular task ${task.title}:`,
                                    error,
                                );
                                // Continue with next task instead of breaking the entire loop
                            }
                        }
                    }

                    // Load As Needed tasks and add them to the main task list
                    console.log("üêõ ABOUT TO CALL loadAsNeededTasks with:", {
                        userName,
                        selectedDate,
                    });
                    try {
                        await loadAsNeededTasks(
                            userName,
                            selectedDate,
                            userTasksDiv,
                            true,
                        ); // true = only assigned to user
                    } catch (error) {
                        console.error(
                            "üî• Error loading As Needed tasks:",
                            error,
                        );
                    }
                } finally {
                    isLoadingUserTasks = false;
                }
            }

            let isLoadingAsNeeded = false;
            let asNeededCallCounter = 0;

            async function loadAsNeededTasks(
                userName,
                selectedDate,
                userTasksDiv,
                onlyAssigned = false,
            ) {
                asNeededCallCounter++;
                console.log(
                    "üêõ loadAsNeededTasks call #" +
                        asNeededCallCounter +
                        " for:",
                    userName,
                );

                if (isLoadingAsNeeded) {
                    console.log(
                        "üêõ loadAsNeededTasks already running, skipping call #" +
                            asNeededCallCounter,
                    );
                    return;
                }

                isLoadingAsNeeded = true;
                console.log(
                    "üêõ loadAsNeededTasks executing call #" +
                        asNeededCallCounter,
                );

                const adminEmail = localStorage.getItem("currentAdminEmail");

                try {
                    const res = await fetch(
                        `https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&t=${Date.now()}`,
                        { cache: "no-store" },
                    );
                    const data = await res.json();
                    if (!res.ok)
                        throw new Error(data.error || "Failed to fetch tasks");

                    const allTasks = data.tasks || [];
                    const asNeededOnly = allTasks.filter(
                        (t) => t.repeat === "As Needed",
                    );
                    console.log(
                        "üêõ Found",
                        asNeededOnly.length,
                        "As Needed tasks",
                    );

                    // Filter As Needed tasks based on onlyAssigned parameter
                    const asNeededTasks = allTasks.filter((task) => {
                        if (
                            !task ||
                            task.repeat !== "As Needed" ||
                            !task.asNeeded
                        )
                            return false;
                        if (onlyAssigned) {
                            return task.users && task.users.includes(userName); // Only show assigned tasks
                        }
                        // For non-assigned tasks, exclude private ones
                        if (task.users && task.users.includes(userName))
                            return false; // Don't show assigned tasks
                        if (task.isPrivate === true) return false; // Don't show private tasks
                        return true;
                    });

                    // Add As Needed tasks to the main task list
                    console.log(
                        "üêõ Current userTasksDiv children before adding:",
                        userTasksDiv.children.length,
                    );
                    console.log(
                        "üêõ About to add",
                        asNeededTasks.length,
                        "As Needed tasks",
                    );

                    for (const task of asNeededTasks) {
                        console.log("üêõ Adding task:", task.title);
                        const taskDiv = document.createElement("div");
                        taskDiv.className = "task-item";

                        // Style based on activation status
                        if (task.activated) {
                            // Active task - normal appearance with dashed border
                            taskDiv.style.borderColor = "var(--primary-color)";
                            taskDiv.style.borderStyle = "dashed";
                            taskDiv.style.opacity = "1";
                        } else {
                            // Inactive task - dimmed appearance
                            taskDiv.style.borderColor = "#666";
                            taskDiv.style.borderStyle = "dashed";
                            taskDiv.style.opacity = "0.6";
                            taskDiv.style.backgroundColor = "#1F1F23";
                        }

                        let taskHTML = `<strong>${task.title}</strong> <span style="font-size: 12px; color: var(--primary-color);">(As Needed)</span>`;
                        if (task.isPrivate === true) {
                            taskHTML += ` <span style="color: #ff6b6b; font-size: 12px;">üîí Private</span>`;
                        }
                        taskHTML += `<br>`;
                        if (
                            !onlyAssigned &&
                            task.users &&
                            task.users.length > 0
                        ) {
                            taskHTML += `<em style="color: #666;">Originally assigned to: ${task.users.join(", ")}</em><br>`;
                        }

                        if (task.activated) {
                            taskHTML += `Status: Ready<br>`;
                        } else {
                            taskHTML += `Status: <span style="color: #888;">Waiting to be activated</span><br>`;
                        }

                        taskHTML += `Buzz Points: ${task.reward || 0} üçØ (goes to completer)<br>`;
                        if (task.settings) {
                            taskHTML += `Type: ${task.settings}<br>`;
                        }

                        taskDiv.innerHTML = taskHTML;

                        // Only show finish button if task is activated and user can complete it
                        if (task.activated) {
                            let canComplete = true;
                            // Private tasks can only be completed by assigned users
                            if (
                                task.isPrivate === true &&
                                (!task.users || !task.users.includes(userName))
                            ) {
                                canComplete = false;
                            }

                            if (canComplete) {
                                const finishBtn =
                                    document.createElement("button");
                                finishBtn.className = "finished-btn";
                                finishBtn.textContent = `Complete Task (as ${userName})`;
                                finishBtn.addEventListener("click", (e) => {
                                    e.stopPropagation();
                                    if (!userName) {
                                        alert(
                                            "Error: User not identified. Please refresh the page.",
                                        );
                                        return;
                                    }
                                    finishAsNeededTask(
                                        userName,
                                        task,
                                        selectedDate,
                                    );
                                });
                                taskDiv.appendChild(finishBtn);
                            }
                        }

                        taskDiv.addEventListener("click", () =>
                            showTaskDetails(task, selectedDate),
                        );
                        userTasksDiv.appendChild(taskDiv);
                    }
                } catch (err) {
                    console.error("üî• Failed to fetch as needed tasks:", err);
                } finally {
                    isLoadingAsNeeded = false;
                }
            }

            async function finishAsNeededTask(userName, task, selectedDate) {
                const adminEmail = localStorage.getItem("currentAdminEmail");

                console.log(
                    "üîç finishAsNeededTask: Task will be completed by:",
                    userName,
                    "regardless of original assignment",
                );

                // Validation
                if (!userName) {
                    console.error(
                        "üî• finishAsNeededTask: No userName provided",
                    );
                    alert(
                        "Error: User not identified. Please refresh the page.",
                    );
                    return;
                }

                try {
                    const response = await fetch(
                        "https://beemazing1.onrender.com/api/complete-as-needed-task",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                adminEmail: adminEmail,
                                taskTitle: task.title,
                                user: userName, // Who is actually completing the task
                                date: selectedDate,
                                isPrivate: task.isPrivate, // Let backend enforce private task rules
                            }),
                        },
                    );

                    const data = await response.json();
                    if (!response.ok) {
                        console.error(
                            "üî• finishAsNeededTask: Server error details:",
                            {
                                status: response.status,
                                statusText: response.statusText,
                                error: data.error,
                                task: task.title,
                                completer: userName,
                                isPrivate: task.isPrivate,
                            },
                        );
                        throw new Error(
                            data.error || "Failed to complete task",
                        );
                    }

                    // Show success popup and trigger honey rain
                    triggerHoneyRain(task.reward || 0);

                    // Reload the correct tab to reflect changes
                    const myTasksTab = document.getElementById("myTasks");
                    const allTasksTab = document.getElementById("allTasks");

                    if (!myTasksTab.classList.contains("hidden")) {
                        loadUserTasks(userName, selectedDate);
                    } else if (!allTasksTab.classList.contains("hidden")) {
                        loadAllTasks(userName, selectedDate);
                    }
                    loadUserReward(userName);
                } catch (error) {
                    console.error("Error completing as needed task:", error);
                    alert(`Error: ${error.message}`);
                }
            }

            // addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////

            //---------

            async function loadUserReward(userName) {
                const adminEmail = localStorage.getItem("currentAdminEmail");
                try {
                    const response = await fetch(
                        `https://beemazing1.onrender.com/api/rewards?adminEmail=${encodeURIComponent(adminEmail)}`,
                    );
                    const data = await response.json();
                    if (!response.ok)
                        throw new Error(
                            data.error || "Failed to fetch rewards",
                        );
                    const rewards = data.rewards || {};
                    const userReward = rewards[userName] || 0;
                    const rewardElement =
                        document.getElementById("rewardAmount");
                    if (rewardElement) {
                        rewardElement.textContent = userReward;
                    }
                } catch (err) {
                    console.error("Error loading user reward:", err);
                }
            }

            function triggerHoneyRain(rewardAmount) {
                for (let i = 0; i < 50; i++) {
                    const drop = document.createElement("div");
                    drop.className = "honey-drop";
                    drop.style.left = `${Math.random() * 100}vw`;
                    drop.style.animationDelay = `${Math.random() * 0.5}s`;
                    document.body.appendChild(drop);
                    setTimeout(() => drop.remove(), 2000);
                }
                const popup = document.createElement("div");
                popup.className = "reward-popup";
                popup.textContent = `+${rewardAmount} üçØ`;
                document.body.appendChild(popup);
                setTimeout(() => {
                    const rewardElement =
                        document.getElementById("rewardAmount");
                    rewardElement.classList.add("pulse");
                    setTimeout(() => {
                        rewardElement.classList.remove("pulse");
                        popup.remove();
                    }, 1000);
                }, 1000);
            }

            //---------

            // addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////

            function showTaskDetails(
                task,
                selectedDate = new Date().toLocaleDateString("sv-SE"),
            ) {
                const isRotation = task.settings?.includes("Rotation");
                let turnData;

                if (isRotation) {
                    if (typeof mixedTurnData !== "function") {
                        console.error(
                            `mixedTurnData is not defined for task: ${task.title}`,
                        );
                        turnData = {
                            turns: [],
                            completedCount: 0,
                            requiredTimes: 1,
                        };
                    } else {
                        turnData = mixedTurnData(task, selectedDate);
                    }
                } else {
                    if (typeof individualTurnData !== "function") {
                        console.error(
                            `individualTurnData is not defined for task: ${task.title}`,
                        );
                        turnData = {
                            turns: [],
                            completedCount: 0,
                            requiredTimes: 1,
                        };
                    } else {
                        try {
                            turnData = individualTurnData(task, selectedDate);
                        } catch (error) {
                            console.error(
                                `Error in individualTurnData for task ${task.title}:`,
                                error,
                            );
                            turnData = {
                                turns: [],
                                completedCount: 0,
                                requiredTimes: 1,
                            };
                        }
                    }
                }

                const userTurns = turnData.turns.filter(
                    (turn) => turn.user === userName,
                );
                const userTotal = userTurns.reduce(
                    (sum, turn) =>
                        sum + (turn.isCompleted || turn.isPending ? 1 : 0),
                    0,
                );
                const userRequiredTimes = isRotation
                    ? userTurns.length
                    : turnData.requiredTimes;

                // Determine task status and symbol
                let statusSymbol = "";
                let isOverdue = false;
                let isPending = false;
                let isApproved = false;

                // Check if task is overdue
                const now = new Date();
                const currentTime = now.getHours() * 60 + now.getMinutes();
                const currentDate = new Date().toLocaleDateString("sv-SE");

                if (selectedDate === currentDate) {
                    if (task.dueTimes && task.dueTimes.length > 0) {
                        // Tasks with specific due times - check if any due time has passed
                        for (const timeStr of task.dueTimes) {
                            const [hours, minutes] = timeStr
                                .split(":")
                                .map(Number);
                            const dueTime = hours * 60 + minutes;
                            if (currentTime > dueTime) {
                                isOverdue = true;
                                break;
                            }
                        }
                    } else {
                        // Tasks without due times - overdue after midnight if not completed
                        const hasCompletions = turnData.completedCount > 0;
                        if (!hasCompletions && currentTime > 0) {
                            // It's past midnight and task is not completed
                            isOverdue = true;
                        }
                    }
                } else if (selectedDate < currentDate) {
                    // Task is from a previous date and not completed
                    const hasCompletions = turnData.completedCount > 0;
                    if (!hasCompletions) {
                        isOverdue = true;
                    }
                }

                // Check completion status using proper completion data
                const hasCompletions = turnData.completedCount > 0;
                if (hasCompletions && task.parentApproval === true) {
                    // Check pending and approved users using same logic as main code
                    const pendingUsers = [];
                    const approvedUsers = [];

                    // Check ALL completions (including cross-completions)
                    const allCompletions = [];

                    // Get all completions from completedDates format
                    if (
                        task.completedDates &&
                        task.completedDates[selectedDate]
                    ) {
                        allCompletions.push(
                            ...task.completedDates[selectedDate],
                        );
                    }
                    // Fallback to completions format
                    else if (
                        task.completions &&
                        task.completions[selectedDate]
                    ) {
                        allCompletions.push(
                            ...task.completions[selectedDate].filter(
                                (c) => c.isCompleted || !c.isPending,
                            ),
                        );
                    }

                    // Update isPending status from completions data
                    if (task.completions && task.completions[selectedDate]) {
                        const completionsData = task.completions[selectedDate];
                        allCompletions.forEach((completion) => {
                            const matchingCompletion = completionsData.find(
                                (c) => c.user === completion.user,
                            );
                            if (matchingCompletion) {
                                completion.isPending =
                                    matchingCompletion.isPending;
                            }
                        });
                    }

                    // Process all completions
                    allCompletions.forEach((completion) => {
                        const user = completion.user;
                        if (completion.isPending === true) {
                            if (!pendingUsers.includes(user)) {
                                pendingUsers.push(user);
                            }
                        } else {
                            if (!approvedUsers.includes(user)) {
                                approvedUsers.push(user);
                            }
                        }
                    });

                    if (pendingUsers.length > 0 && approvedUsers.length === 0) {
                        isPending = true;
                    } else if (approvedUsers.length > 0) {
                        isApproved = true;
                    }
                } else if (hasCompletions) {
                    // Non-approval tasks are approved when completed
                    isApproved = true;
                }

                // Set status symbol
                if (isOverdue) {
                    statusSymbol =
                        ' <span style="display: inline-flex; align-items: center; justify-content: center; margin-left: 8px; width: 20px; height: 20px; border-radius: 50%; background: #d32f2f; color: white; font-size: 14px; font-weight: bold;">!</span>';
                } else if (isPending) {
                    statusSymbol =
                        ' <span style="display: inline-flex; align-items: center; justify-content: center; margin-left: 8px; width: 20px; height: 20px; border-radius: 50%; background: var(--primary-color);"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6,2V8H6V8L10,12L6,16V16H6V22H18V16H18V16L14,12L18,8V8H18V2H6M16,16.5V20H8V16.5L12,12.5L16,16.5M12,11.5L8,7.5V4H16V7.5L12,11.5Z" fill="white"/></svg></span>';
                } else if (isApproved) {
                    statusSymbol =
                        ' <span style="display: inline-flex; align-items: center; justify-content: center; margin-left: 8px; width: 20px; height: 20px; border-radius: 50%; background: #28a745; color: white; font-size: 14px; font-weight: bold;">‚úì</span>';
                }

                let modalHTML = `<h2>${task.title}${statusSymbol}</h2>`;

                // Check if this is an occurrence task and add master task button
                if (
                    task.originalTitle &&
                    task.occurrence &&
                    task.totalOccurrences
                ) {
                    modalHTML += `<div style="border-bottom: 1px solid var(--primary-color); padding: 3px 0; margin-bottom: 6px; font-size: 12px; line-height: 1;">`;
                    modalHTML += `<strong style="margin: 0; padding: 0; line-height: 1;">This is occurrence ${task.occurrence} of ${task.totalOccurrences}</strong> `;
                    modalHTML += `<button type="button" onclick="showMasterTaskDetails('${task.originalTitle}', '${selectedDate}', ${JSON.stringify(task).replace(/"/g, "&quot;")})" style="
                        margin-left: 8px;
                        padding: 4px 8px;
                        background: var(--primary-color);
                        color: var(--secondary-color);
                        border: none;
                        border-radius: 4px;
                        font-size: 12px;
                        font-weight: 500;
                        cursor: pointer;
                        transition: all 0.2s;
                        vertical-align: middle;
                    " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
                        View Full Task
                    </button>`;
                    modalHTML += `</div>`;
                }

                // Buzz Points
                modalHTML += `<div class="task-info-row"><strong>Buzz Points:</strong> ${task.reward || 0} üçØ</div>`;

                // Status (simple)
                let statusDisplay = "";
                if (isOverdue && !isApproved && !isPending) {
                    statusDisplay = "Overdue";
                } else if (isApproved) {
                    statusDisplay = "Approved";
                } else if (isPending) {
                    statusDisplay = "Pending";
                } else {
                    statusDisplay = "Active";
                }
                modalHTML += `<div class="task-info-row"><strong>Status:</strong> ${statusDisplay}</div>`;

                // Completion Details (separate section)
                let completionTime = "";
                let completerUser = "";

                if (
                    (isApproved || isPending) &&
                    task.completedDates &&
                    task.completedDates[selectedDate] &&
                    task.completedDates[selectedDate].length > 0
                ) {
                    const latestCompletion =
                        task.completedDates[selectedDate][
                            task.completedDates[selectedDate].length - 1
                        ];
                    if (latestCompletion.completedAt) {
                        const completedTimeObj = new Date(
                            latestCompletion.completedAt,
                        );
                        completionTime = completedTimeObj.toLocaleTimeString(
                            "en-US",
                            {
                                hour: "2-digit",
                                minute: "2-digit",
                                hour12: true,
                            },
                        );
                        completerUser = latestCompletion.user;
                    }
                }

                if (completionTime && completerUser) {
                    let avatarHTML = "";
                    if (
                        window.avatarSystem &&
                        typeof window.avatarSystem.generateAvatarHTML ===
                            "function"
                    ) {
                        avatarHTML = window.avatarSystem.generateAvatarHTML(
                            completerUser,
                            24,
                            "completer-avatar",
                            "",
                        );
                    }
                    modalHTML += `<div class="task-info-row"><strong>Completion Details:</strong> ${completionTime} by ${avatarHTML}</div>`;
                }

                // Notes (if present)
                if (task.notes) {
                    modalHTML += `<div class="task-info-row"><strong>Notes:</strong> ${task.notes}</div>`;
                }

                // Room (if present)
                if (task.room) {
                    modalHTML += `<div class="task-info-row"><strong>Room:</strong> ${task.room}</div>`;
                }

                // Frequency (simple)
                let frequencyDisplay = task.repeat || "Daily";
                modalHTML += `<div class="task-info-row"><strong>Frequency:</strong> ${frequencyDisplay}</div>`;

                // Additional Settings (when applicable)
                if (task.repeat && task.repeat !== "One time") {
                    let additionalSettings = [];

                    if (task.repeat === "Daily") {
                        // Check for times per day
                        if (task.timesPerDay && task.timesPerDay > 1) {
                            additionalSettings.push(
                                `${task.timesPerDay} times per day`,
                            );
                        }
                        // Check for specific days of week
                        if (task.daysOfWeek && task.daysOfWeek.length > 0) {
                            if (
                                task.daysOfWeek.includes("All") ||
                                task.daysOfWeek.length === 7
                            ) {
                                additionalSettings.push("All days");
                            } else if (!task.daysOfWeek.includes("Any")) {
                                // Filter out day names that are actually day names
                                const validDays = task.daysOfWeek.filter(
                                    (day) =>
                                        typeof day === "string" &&
                                        [
                                            "Monday",
                                            "Tuesday",
                                            "Wednesday",
                                            "Thursday",
                                            "Friday",
                                            "Saturday",
                                            "Sunday",
                                        ].includes(day),
                                );
                                if (validDays.length > 0) {
                                    const shortDays = validDays.map((day) =>
                                        day.substring(0, 3),
                                    );
                                    additionalSettings.push(
                                        shortDays.join(", "),
                                    );
                                }
                            }
                        }
                    } else if (task.repeat === "Weekly") {
                        // Check for times per week
                        if (task.timesPerWeek && task.timesPerWeek > 1) {
                            additionalSettings.push(
                                `${task.timesPerWeek} times per week`,
                            );
                        }
                        // Check for specific days of week
                        if (task.daysOfWeek && task.daysOfWeek.length > 0) {
                            if (!task.daysOfWeek.includes("Any")) {
                                const validDays = task.daysOfWeek.filter(
                                    (day) =>
                                        typeof day === "string" &&
                                        [
                                            "Monday",
                                            "Tuesday",
                                            "Wednesday",
                                            "Thursday",
                                            "Friday",
                                            "Saturday",
                                            "Sunday",
                                        ].includes(day),
                                );
                                if (validDays.length > 0) {
                                    const shortDays = validDays.map((day) =>
                                        day.substring(0, 3),
                                    );
                                    additionalSettings.push(
                                        shortDays.join(", "),
                                    );
                                }
                            }
                        }
                    } else if (task.repeat === "Monthly") {
                        // Handle new monthly options structure
                        if (task.monthlyOption === "times") {
                            // Check for times per month
                            if (task.timesPerMonth && task.timesPerMonth > 1) {
                                additionalSettings.push(
                                    `${task.timesPerMonth} times per month`,
                                );
                            }

                            // Handle specific days of the month
                            if (
                                task.monthlySchedulingType === "daysOfMonth" &&
                                task.monthlyDaysOfMonth
                            ) {
                                const days = task.monthlyDaysOfMonth.split(",");
                                const dayNames = days.map((day) => {
                                    if (day === "last") return "Last";
                                    const num = parseInt(day);
                                    if (num === 1) return "1st";
                                    if (num === 2) return "2nd";
                                    if (num === 3) return "3rd";
                                    if (num === 21) return "21st";
                                    if (num === 22) return "22nd";
                                    if (num === 23) return "23rd";
                                    if (num === 31) return "31st";
                                    return `${num}th`;
                                });
                                additionalSettings.push(
                                    `Days: ${dayNames.join(", ")}`,
                                );
                            }

                            // Handle specific days of the week patterns
                            if (
                                task.monthlySchedulingType === "daysOfWeek" &&
                                task.monthlyDaysOfWeek
                            ) {
                                const patterns =
                                    task.monthlyDaysOfWeek.split(",");
                                const patternNames = patterns.map((pattern) => {
                                    const [occurrence, weekday] =
                                        pattern.split(":");
                                    const occurrenceNames = {
                                        1: "1st",
                                        2: "2nd",
                                        3: "3rd",
                                        4: "4th",
                                        last: "Last",
                                    };
                                    return `${occurrenceNames[occurrence]} ${weekday}`;
                                });
                                additionalSettings.push(
                                    `Patterns: ${patternNames.join(", ")}`,
                                );
                            }
                        } else if (task.monthlyOption === "interval") {
                            const interval = task.monthInterval || 1;
                            additionalSettings.push(
                                interval === 1
                                    ? "Every month"
                                    : `Every ${interval} months`,
                            );
                        }
                        // Legacy support for old format
                        else if (task.monthlyOption === "specific") {
                            additionalSettings.push(`Day ${task.monthlyDay}`);
                        } else if (
                            task.monthlyOption === "pattern" &&
                            task.monthlyWeek &&
                            task.monthlyWeekday
                        ) {
                            const weekNames = [
                                "First",
                                "Second",
                                "Third",
                                "Fourth",
                                "Last",
                            ];
                            const dayNames = [
                                "Sun",
                                "Mon",
                                "Tue",
                                "Wed",
                                "Thu",
                                "Fri",
                                "Sat",
                            ];
                            additionalSettings.push(
                                `${weekNames[task.monthlyWeek - 1]} ${dayNames[task.monthlyWeekday]}`,
                            );
                        }
                    }

                    if (additionalSettings.length > 0) {
                        modalHTML += `<div class="task-info-row"><strong>Additional Settings:</strong> ${additionalSettings.join(", ")}</div>`;
                    }
                }

                // Date
                const [fromDate, toDate] = (task.date || "").split(" to ");
                let dateDisplay = "";
                if (task.repeat === "Occasional") {
                    dateDisplay = "No fixed date";
                } else if (!fromDate) {
                    dateDisplay = "Unknown";
                } else if (
                    !toDate ||
                    toDate === "3000-01-01" ||
                    toDate === fromDate
                ) {
                    dateDisplay = fromDate;
                } else {
                    dateDisplay = `From ${fromDate} to ${toDate}`;
                }
                modalHTML += `<div class="task-info-row"><strong>Date:</strong> ${dateDisplay}</div>`;

                // Due Time
                if (task.dueTimes && task.dueTimes.length > 0) {
                    modalHTML += `<div class="task-info-row"><strong>Due Time:</strong> ${task.dueTimes.join(", ")}</div>`;
                }

                // Setting
                let settingDisplay = "Individual";
                if (task.settings?.includes("Rotation")) {
                    settingDisplay = "Rotational";
                } else if (task.settings?.includes("Teamwork")) {
                    settingDisplay = "Teamwork";
                }
                modalHTML += `<div class="task-info-row"><strong>Setting:</strong> ${settingDisplay}</div>`;

                // Additional Details for Rotational
                if (task.settings?.includes("Rotation")) {
                    let rotationDetails = [];
                    if (task.fairRotation) {
                        rotationDetails.push("Fair Task Rotation");
                    }
                    if (task.fairRotationTimeBased) {
                        rotationDetails.push("Time-based tie breaking");
                    }
                    if (rotationDetails.length > 0) {
                        modalHTML += `<div class="task-info-row"><strong>Additional Details:</strong> ${rotationDetails.join(", ")}</div>`;
                    }
                }

                // Assigned To (avatars only)
                let assignedDisplay = "";
                if (task.settings?.includes("Teamwork")) {
                    // For teamwork, list all avatars
                    task.users.forEach((user) => {
                        if (
                            window.avatarSystem &&
                            typeof window.avatarSystem.generateAvatarHTML ===
                                "function"
                        ) {
                            assignedDisplay +=
                                window.avatarSystem.generateAvatarHTML(
                                    user,
                                    24,
                                    "assigned-avatar",
                                    "margin-right: 2px;",
                                );
                        }
                    });
                } else if (task.settings?.includes("Rotation")) {
                    // For rotation, show current assignee first, then order
                    const activeTurn = turnData.turns.find(
                        (turn) => !turn.isCompleted && !turn.isPending,
                    );
                    if (activeTurn) {
                        if (
                            window.avatarSystem &&
                            typeof window.avatarSystem.generateAvatarHTML ===
                                "function"
                        ) {
                            assignedDisplay +=
                                window.avatarSystem.generateAvatarHTML(
                                    activeTurn.user,
                                    24,
                                    "current-avatar",
                                    "margin-right: 2px; border: 2px solid var(--primary-color);",
                                );
                        }

                        // Add rotation order
                        const orderedUsers = task.users.slice();
                        const currentIndex = orderedUsers.indexOf(
                            activeTurn.user,
                        );
                        const rotationOrder = [
                            ...orderedUsers.slice(currentIndex + 1),
                            ...orderedUsers.slice(0, currentIndex),
                        ];

                        if (rotationOrder.length > 0) {
                            rotationOrder.forEach((user) => {
                                if (
                                    window.avatarSystem &&
                                    typeof window.avatarSystem
                                        .generateAvatarHTML === "function"
                                ) {
                                    assignedDisplay +=
                                        window.avatarSystem.generateAvatarHTML(
                                            user,
                                            24,
                                            "rotation-avatar",
                                            "margin-right: 2px;",
                                        );
                                }
                            });
                        }
                    } else {
                        // Fallback
                        task.users.forEach((user) => {
                            if (
                                window.avatarSystem &&
                                typeof window.avatarSystem
                                    .generateAvatarHTML === "function"
                            ) {
                                assignedDisplay +=
                                    window.avatarSystem.generateAvatarHTML(
                                        user,
                                        24,
                                        "assigned-avatar",
                                        "margin-right: 2px;",
                                    );
                            }
                        });
                    }
                } else {
                    // For individual, list all assigned users
                    task.users.forEach((user) => {
                        if (
                            window.avatarSystem &&
                            typeof window.avatarSystem.generateAvatarHTML ===
                                "function"
                        ) {
                            assignedDisplay +=
                                window.avatarSystem.generateAvatarHTML(
                                    user,
                                    24,
                                    "assigned-avatar",
                                    "margin-right: 2px;",
                                );
                        }
                    });
                }
                modalHTML += `<div class="task-info-row"><strong>Assigned To:</strong><div class="avatar-container">${assignedDisplay}</div></div>`;

                // Reassigned To (if applicable)
                let reassignedUser = null;
                if (
                    task.tempTurnReplacement &&
                    task.tempTurnReplacement[selectedDate]
                ) {
                    const replacements = task.tempTurnReplacement[selectedDate];
                    for (const [index, replacementUser] of Object.entries(
                        replacements,
                    )) {
                        if (task.users && task.users[parseInt(index)]) {
                            reassignedUser = replacementUser;
                            break;
                        }
                    }
                }

                if (reassignedUser) {
                    let reassignedAvatar = "";
                    if (
                        window.avatarSystem &&
                        typeof window.avatarSystem.generateAvatarHTML ===
                            "function"
                    ) {
                        reassignedAvatar =
                            window.avatarSystem.generateAvatarHTML(
                                reassignedUser,
                                24,
                                "reassigned-avatar",
                                "",
                            );
                    }
                    modalHTML += `<div class="task-info-row"><strong>Reassigned To:</strong><div class="avatar-container">${reassignedAvatar}</div></div>`;
                }

                // Parental Approval
                const approvalDisplay =
                    task.parentApproval === true ? "Yes" : "No";
                modalHTML += `<div class="task-info-row"><strong>Parental Approval:</strong> ${approvalDisplay}</div>`;

                // On-time Completion
                const onTimeDisplay =
                    task.onTimeCompletion === true ? "Yes" : "No";
                modalHTML += `<div class="task-info-row"><strong>On-time Completion:</strong> ${onTimeDisplay}</div>`;

                // Privacy Status
                const privacyDisplay =
                    task.isPrivate === true
                        ? "Private"
                        : "Visible to all users";
                modalHTML += `<div class="task-info-row"><strong>Privacy Status:</strong> ${privacyDisplay}</div>`;

                const modal = document.createElement("div");
                modal.className = "modal";
                modal.innerHTML = `<div class="modal-content">${modalHTML}</div>`;
                document.body.appendChild(modal);

                modal.addEventListener("click", (e) => {
                    if (e.target.classList.contains("modal")) {
                        modal.remove();
                    }
                });
            }

            // Function to show master task details for occurrence tasks
            async function showMasterTaskDetails(
                originalTitle,
                selectedDate,
                currentTask,
            ) {
                // Fetch all tasks to find all occurrences of this task group
                const adminEmail = localStorage.getItem("currentAdminEmail");
                let allDueTimes = [];

                try {
                    const cacheBuster = `t=${Date.now()}&r=${Math.random()}`;
                    const res = await fetch(
                        `https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&${cacheBuster}`,
                        {
                            cache: "no-store",
                            headers: {
                                "Cache-Control":
                                    "no-cache, no-store, must-revalidate",
                                Pragma: "no-cache",
                                Expires: "0",
                            },
                        },
                    );
                    const data = await res.json();
                    if (res.ok && data.tasks) {
                        // Find all occurrences of this task group
                        const occurrences = data.tasks.filter(
                            (t) =>
                                t.originalTitle === originalTitle ||
                                (t.title &&
                                    t.title.startsWith(originalTitle + " - ")),
                        );

                        // Collect all due times from occurrences
                        occurrences.forEach((occurrence) => {
                            if (
                                occurrence.dueTimes &&
                                occurrence.dueTimes.length > 0
                            ) {
                                allDueTimes.push(...occurrence.dueTimes);
                            }
                        });

                        // Sort due times chronologically
                        allDueTimes = [...new Set(allDueTimes)].sort();
                    }
                } catch (err) {
                    console.error(
                        "Failed to fetch tasks for master details:",
                        err,
                    );
                    // Fallback to current task's due times
                    allDueTimes = currentTask.dueTimes || [];
                }

                // Reconstruct master task from the current occurrence task data
                const masterTask = {
                    ...currentTask,
                    title: originalTitle,
                    timesPerDay: currentTask.totalOccurrences || 1,
                    dueTimes:
                        allDueTimes.length > 0
                            ? allDueTimes
                            : currentTask.dueTimes,
                    // Remove occurrence-specific fields
                    occurrence: undefined,
                    totalOccurrences: undefined,
                    originalTitle: undefined,
                };

                // Close current modal
                const existingModal = document.querySelector(".modal");
                if (existingModal) {
                    existingModal.remove();
                }

                // Show master task details
                showTaskDetails(masterTask, selectedDate);
            }

            // addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////

            let monthOffset = 0;

            function generateScrollableDates(monthOffset = 0) {
                const container = document.getElementById("dayScrollContainer");
                container.innerHTML = "";

                const today = new Date();
                today.setDate(1);
                today.setMonth(today.getMonth() + monthOffset);

                const currentMonth = today.getMonth();
                const currentYear = today.getFullYear();
                const daysInMonth = new Date(
                    currentYear,
                    currentMonth + 1,
                    0,
                ).getDate();

                document.getElementById("monthLabel").textContent =
                    today.toLocaleDateString(undefined, {
                        month: "long",
                        year: "numeric",
                    });

                const urlParams = new URLSearchParams(window.location.search);
                const userName = urlParams.get("user");
                const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, "0")}-${String(today.getDate()).padStart(2, "0")}`;
                const dayAbbreviations = [
                    "S",
                    "Mo",
                    "Tu",
                    "We",
                    "Th",
                    "Fr",
                    "St",
                ];

                for (let i = 1; i <= daysInMonth; i++) {
                    const date = new Date(currentYear, currentMonth, i);
                    const dayOfWeek = dayAbbreviations[date.getDay()]; // Get day abbreviation
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;

                    const containerDiv = document.createElement("div");
                    containerDiv.className = "day-container";

                    const label = document.createElement("span");
                    label.className = "day-label";
                    label.textContent = dayOfWeek;

                    const btn = document.createElement("div");
                    btn.className = "day";
                    btn.textContent = i;
                    btn.dataset.date = dateStr;

                    btn.addEventListener("click", () => {
                        document
                            .querySelectorAll(".day")
                            .forEach((d) => d.classList.remove("selected"));
                        btn.classList.add("selected");

                        // Load tasks for the currently active tab
                        const myTasksTab = document.getElementById("myTasks");
                        const allTasksTab = document.getElementById("allTasks");

                        if (!myTasksTab.classList.contains("hidden")) {
                            loadUserTasks(userName, dateStr);
                        } else if (!allTasksTab.classList.contains("hidden")) {
                            loadAllTasks(userName, dateStr);
                        }
                    });

                    const now = new Date();
                    const nowStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")}`;
                    if (dateStr === nowStr) {
                        btn.classList.add("selected");
                        // Load tasks for the currently active tab on page load
                        const myTasksTab = document.getElementById("myTasks");
                        const allTasksTab = document.getElementById("allTasks");

                        if (!myTasksTab.classList.contains("hidden")) {
                            loadUserTasks(userName, dateStr);
                        } else if (!allTasksTab.classList.contains("hidden")) {
                            loadAllTasks(userName, dateStr);
                        }
                    }

                    containerDiv.appendChild(label);
                    containerDiv.appendChild(btn);
                    container.appendChild(containerDiv);
                }

                setTimeout(() => {
                    const selected = document.querySelector(".day.selected");
                    if (selected) {
                        selected.scrollIntoView({
                            behavior: "smooth",
                            inline: "center",
                        });
                    }
                }, 50);
            }

            document
                .getElementById("prevMonth")
                .addEventListener("click", () => {
                    monthOffset--;
                    generateScrollableDates(monthOffset);
                });

            document
                .getElementById("nextMonth")
                .addEventListener("click", () => {
                    monthOffset++;
                    generateScrollableDates(monthOffset);
                });

            document
                .getElementById("scrollLeft")
                .addEventListener("click", () => {
                    document.getElementById("dayScrollContainer").scrollBy({
                        left: -200,
                        behavior: "smooth",
                    });
                });

            document
                .getElementById("scrollRight")
                .addEventListener("click", () => {
                    document.getElementById("dayScrollContainer").scrollBy({
                        left: 200,
                        behavior: "smooth",
                    });
                });

            function adjustContentTop() {
                const header = document.querySelector(".date-header");
                const content = document.querySelector(".content");
                if (header && content) {
                    const headerHeight = header.getBoundingClientRect().height;
                    content.style.top = `${headerHeight}px`;
                }
            }

            function showAdminControlsIfNeeded() {
                const urlParams = new URLSearchParams(window.location.search);
                const currentUser = urlParams.get("user");
                const allUserData =
                    JSON.parse(localStorage.getItem("userData")) || {};
                const currentAdmin = localStorage.getItem("currentAdminEmail");
                const userPermissions =
                    allUserData[currentAdmin]?.permissions || {};
                const isUserAdmin = userPermissions[currentUser] === "Admin";
                const isLoggedInAsAdmin =
                    localStorage.getItem("isAdmin") === "true";
                const changePasswordBtn =
                    document.getElementById("changePasswordBtn");

                if (isUserAdmin && isLoggedInAsAdmin) {
                    changePasswordBtn.style.display = "inline-block";
                    if (!changePasswordBtn.dataset.listenersAdded) {
                        changePasswordBtn.addEventListener("click", () => {
                            const modal = document.getElementById(
                                "changePasswordModal",
                            );
                            modal.style.display = "flex";
                            document.getElementById("newAdminPassword").value =
                                "";
                            document.getElementById("newAdminPassword").focus();
                        });

                        document
                            .getElementById("confirmChangePasswordBtn")
                            .addEventListener("click", () => {
                                const newPassword = document
                                    .getElementById("newAdminPassword")
                                    .value.trim();
                                if (newPassword.length < 4) {
                                    alert(
                                        "Password must be at least 4 characters.",
                                    );
                                    return;
                                }
                                localStorage.setItem(
                                    "adminPassword",
                                    newPassword,
                                );
                                alert("Admin password updated!");
                                document.getElementById(
                                    "changePasswordModal",
                                ).style.display = "none";
                            });

                        document
                            .getElementById("changePasswordModal")
                            .addEventListener("click", (e) => {
                                if (e.target.id === "changePasswordModal") {
                                    document.getElementById(
                                        "changePasswordModal",
                                    ).style.display = "none";
                                }
                            });

                        changePasswordBtn.dataset.listenersAdded = "true";
                    }
                } else {
                    if (changePasswordBtn)
                        changePasswordBtn.style.display = "none";
                }
            }

            // for finish task button video preview
            async function fetchAvatarPath(userName) {
                const adminEmail = localStorage.getItem("currentAdminEmail");
                try {
                    const res = await fetch(
                        `https://beemazing1.onrender.com/get-avatar?adminEmail=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`,
                    );
                    const data = await res.json();
                    if (!data.success || !data.avatar) {
                        throw new Error(data.message || "Avatar not found");
                    }
                    return data.avatar; // returns full path like "/BeeMazing-A1/shared/Avatars/scorpion1.png"
                } catch (err) {
                    console.warn("Could not fetch avatar path:", err);
                    return null;
                }
            }

            // for finish task button video preview

            async function finishTask(currentUser, task, selectedDate) {
                const today =
                    selectedDate || new Date().toISOString().split("T")[0];
                const adminEmail = localStorage.getItem("currentAdminEmail");
                const button = event.target;
                button.disabled = true;

                console.log("üîç finishTask: Starting submission", {
                    currentUser,
                    taskTitle: task.title,
                    selectedDate: today,
                    adminEmail,
                });

                // Validation
                if (!currentUser) {
                    console.error("üî• finishTask: No currentUser provided");
                    button.disabled = false;
                    alert(
                        "Error: User not identified. Please refresh the page.",
                    );
                    return;
                }

                // Try to fetch avatar and derive video path (skip if not available)
                let videoPath = null;
                try {
                    const avatarPath = await fetchAvatarPath(currentUser);
                    const avatarId = avatarPath?.match(/\/([^/]+)\.png$/)?.[1];
                    videoPath = avatarId
                        ? `/BeeMazing-A1/shared/Avatars/Selected/Preview/${avatarId}.mp4`
                        : null;
                } catch (err) {
                    // Avatar not available - continue without video preview
                }

                // Show video overlay if videoPath exists
                if (videoPath) {
                    const overlay = document.getElementById("taskVideoOverlay");
                    const videoEl = document.getElementById("taskAvatarVideo");
                    if (overlay && videoEl) {
                        overlay.style.display = "flex";
                        videoEl.src = videoPath;
                        videoEl.muted = false;
                        videoEl.load();
                        videoEl
                            .play()
                            .catch((err) =>
                                console.warn(
                                    "Could not auto-play preview:",
                                    err,
                                ),
                            );
                        videoEl.onended = () => {
                            overlay.style.display = "none";
                            videoEl.src = "";
                        };
                    }
                }

                // Show submission popup
                const popup = document.createElement("div");
                popup.className = "reward-popup";
                popup.textContent = `Submitting Task...`;
                document.body.appendChild(popup);

                try {
                    const response = await fetch(
                        "https://beemazing1.onrender.com/api/complete-task",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                adminEmail,
                                taskTitle: task.title.trim(),
                                user: currentUser, // Who is actually completing the task
                                date: today,
                                isPrivate: task.isPrivate, // Let backend enforce private task rules
                            }),
                        },
                    );
                    const data = await response.json();
                    if (!response.ok) {
                        console.error("üî• finishTask: Server error details:", {
                            status: response.status,
                            statusText: response.statusText,
                            error: data.error,
                            task: task.title,
                            completer: currentUser,
                            isPrivate: task.isPrivate,
                        });
                        throw new Error(
                            data.error || `HTTP error ${response.status}`,
                        );
                    }

                    console.log("‚úÖ finishTask: Task submitted", data);
                    popup.textContent = `Task Submitted by ${currentUser}! Waiting for Parent Review`;

                    // üîÑ FAIR ROTATION: Trigger recalculation after task completion
                    if (window.onFairRotationTaskCompleted) {
                        console.log(
                            "üîÑ Triggering fair rotation recalculation...",
                        );
                        await window.onFairRotationTaskCompleted(
                            task.title,
                            currentUser,
                            today,
                        );
                    }

                    // Update the specific task's turn display immediately
                    const taskItems = document.querySelectorAll(".task-item");
                    taskItems.forEach((taskItem) => {
                        if (
                            taskItem.querySelector("strong").textContent ===
                            task.title
                        ) {
                            const isRotation =
                                task.settings?.includes("Rotation");
                            if (
                                isRotation &&
                                data.currentTurnIndex !== undefined &&
                                data.nextUser
                            ) {
                                // Update turn information
                                let turnHTML = `<strong>${task.title}</strong><br>`;
                                if (data.nextUser !== "‚Äî") {
                                    const nextTurnIndex =
                                        (data.currentTurnIndex + 1) %
                                        task.users.length;
                                    const nextNextUser =
                                        task.users[nextTurnIndex] || "‚Äî";
                                    turnHTML += `Turn: ${data.nextUser}<br>Next: ${nextNextUser}<br>`;
                                } else {
                                    turnHTML += `<span style="color: green;">Turn: All done!</span><br>`;
                                }
                                turnHTML += `Buzz Points: ${task.reward || 0} üçØ<br>`;
                                // Recalculate progress
                                const turnData = mixedTurnData(task, today);
                                const userTurns = turnData.turns.filter(
                                    (turn) => turn.user === currentUser,
                                );
                                const userTotal = userTurns.reduce(
                                    (sum, turn) =>
                                        sum +
                                        (turn.isCompleted || turn.isPending
                                            ? 1
                                            : 0),
                                    0,
                                );
                                const userRequiredTimes = userTurns.length;
                                turnHTML += `Progress: ${userTotal}/${userRequiredTimes}<br>`;
                                taskItem.innerHTML = turnHTML;

                                // Reattach the Finish Task button if still applicable
                                const isToday =
                                    today ===
                                    new Date().toLocaleDateString("sv-SE");
                                let canFinish = false;
                                if (isToday && userTotal < userRequiredTimes) {
                                    const activeTurn = turnData.turns.find(
                                        (turn) =>
                                            !turn.isCompleted &&
                                            !turn.isPending,
                                    );
                                    canFinish =
                                        activeTurn?.user === currentUser;
                                }
                                if (canFinish) {
                                    const finishBtn =
                                        document.createElement("button");
                                    finishBtn.className = "finished-btn";
                                    finishBtn.textContent = "Finish Task";
                                    finishBtn.addEventListener("click", (e) => {
                                        e.stopPropagation();
                                        finishTask(currentUser, task, today);
                                    });
                                    taskItem.appendChild(finishBtn);
                                }
                            }
                        }
                    });

                    setTimeout(() => {
                        popup.remove();
                        // Refresh the currently active tab
                        const myTasksTab = document.getElementById("myTasks");
                        const allTasksTab = document.getElementById("allTasks");

                        console.log(
                            "üîç finishTask: Refreshing tabs after completion",
                            {
                                myTasksHidden:
                                    myTasksTab.classList.contains("hidden"),
                                allTasksHidden:
                                    allTasksTab.classList.contains("hidden"),
                                taskTitle: task.title,
                            },
                        );

                        if (!myTasksTab.classList.contains("hidden")) {
                            console.log("üîç finishTask: Refreshing My Tasks");
                            // Force refresh with cache busting to ensure fresh data
                            setTimeout(() => {
                                loadUserTasks(currentUser, today);
                            }, 100);
                        } else if (!allTasksTab.classList.contains("hidden")) {
                            console.log("üîç finishTask: Refreshing All Tasks");
                            console.log(
                                "üîç finishTask: Refreshing All Tasks with params",
                                {
                                    currentUser,
                                    today,
                                    completedTask: task.title,
                                },
                            );
                            // Force refresh with cache busting to ensure fresh data
                            setTimeout(() => {
                                loadAllTasks(currentUser, today);
                            }, 100);
                        }
                    }, 2000);
                } catch (err) {
                    console.error("üî• finishTask: Error submitting task", {
                        error: err,
                        message: err.message,
                        task: task.title,
                        completer: currentUser,
                        isPrivate: task.isPrivate,
                    });
                    popup.textContent = `Error: ${err.message}`;
                    popup.style.color = "red";
                    setTimeout(() => {
                        popup.remove();
                        button.disabled = false;
                    }, 3000);
                }
            }

            window.addEventListener("resize", adjustContentTop);
            window.addEventListener("load", adjustContentTop);
            window.addEventListener("storage", (event) => {
                if (
                    event.key === "isAdmin" ||
                    event.key === "userPermissions"
                ) {
                    showAdminControlsIfNeeded();
                }
            });

            // Auto-refresh functionality removed - users can manually refresh to check approval status

            async function loadNotifications(userName) {
                const adminEmail = localStorage.getItem("currentAdminEmail");
                const offerHelpBadge =
                    document.getElementById("offerHelpBadge");
                const needHelpBadge = document.getElementById("needHelpBadge");
                if (!adminEmail || !userName) {
                    console.error(
                        "loadNotifications: Missing adminEmail or userName",
                    );
                    if (offerHelpBadge) offerHelpBadge.style.display = "none";
                    if (needHelpBadge) needHelpBadge.style.display = "none";
                    return;
                }
                try {
                    const res = await fetch(
                        `https://beemazing1.onrender.com/api/notifications?adminEmail=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}&t=${Date.now()}`,
                        {
                            method: "GET",
                            headers: { "Content-Type": "application/json" },
                        },
                    );
                    const data = await res.json();
                    console.log("Load notifications response:", data);
                    if (!res.ok) {
                        throw new Error(
                            data.error || "Failed to fetch notifications",
                        );
                    }
                    const notifications = data.notifications || [];
                    if (notifications.length === 0) {
                        if (offerHelpBadge)
                            offerHelpBadge.style.display = "none";
                        if (needHelpBadge) needHelpBadge.style.display = "none";
                        return;
                    }
                    const offerHelpNotifications = notifications.filter(
                        (n) => n.offerType === "offerHelp",
                    );
                    const needHelpNotifications = notifications.filter(
                        (n) => n.offerType === "needHelp",
                    );
                    const offerHelpCount = offerHelpNotifications.reduce(
                        (sum, n) => sum + n.taskCount,
                        0,
                    );
                    const needHelpCount = needHelpNotifications.reduce(
                        (sum, n) => sum + n.taskCount,
                        0,
                    );
                    if (offerHelpBadge) {
                        if (offerHelpCount > 0) {
                            offerHelpBadge.textContent = `${offerHelpCount}`;
                            offerHelpBadge.style.display = "block";
                        } else {
                            offerHelpBadge.style.display = "none";
                        }
                    }
                    if (needHelpBadge) {
                        if (needHelpCount > 0) {
                            needHelpBadge.textContent = `${needHelpCount}`;
                            needHelpBadge.style.display = "block";
                        } else {
                            needHelpBadge.style.display = "none";
                        }
                    }
                } catch (err) {
                    console.error("Failed to load notifications:", err.message);
                    if (offerHelpBadge) offerHelpBadge.style.display = "none";
                    if (needHelpBadge) needHelpBadge.style.display = "none";
                }
            }
        </script>

        <div
            id="chestVideoOverlay"
            style="
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(10, 10, 10, 0.959); /* darkened more */
                backdrop-filter: blur(5px);
                z-index: 2000;
                justify-content: center;
                align-items: center;
                overflow: hidden;
            "
        >
            <video
                id="chestVideo"
                autoplay
                muted
                playsinline
                style="
                    max-width: 90vw;
                    max-height: 90vh;
                    border-radius: 20px;
                    box-shadow: 0 0 30px rgba(255, 193, 7, 0.6);
                    background: #1a1a1a;
                    display: block;
                "
            >
                <source
                    src="/BeeMazing-A1/mobile/4-Market/LuckyChest/Chest_fixed.mp4"
                    type="video/mp4"
                />
                Your browser does not support the video tag.
            </video>
            <audio id="chestUnlockSound" preload="auto">
                <source
                    src="/BeeMazing-A1/mobile/4-Market/LuckyChest/ChestUnlock.mp3"
                    type="audio/mp3"
                />
                Your browser does not support the audio element.
            </audio>
        </div>

        <div
            id="taskVideoOverlay"
            style="
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.95);
                z-index: 9999;
                justify-content: center;
                align-items: center;
                flex-direction: column;
            "
        >
            <h1
                style="
                    color: gold;
                    font-size: 36px;
                    margin-bottom: 20px;
                    font-family: Orbitron, sans-serif;
                "
            >
                Well Done!
            </h1>
            <video
                id="taskAvatarVideo"
                autoplay
                playsinline
                style="
                    max-width: 90vw;
                    max-height: 70vh;
                    border-radius: 20px;
                    box-shadow: 0 0 30px gold;
                    background: black;
                "
            ></video>
        </div>

        <script>
            // Comprehensive width debugging script
            function debugTabWidths() {
                console.log("üîç COMPREHENSIVE TAB WIDTH DEBUGGING");
                console.log("==========================================");

                // Function to get detailed width info
                function getWidthInfo(element, name) {
                    if (!element) return null;
                    const rect = element.getBoundingClientRect();
                    const computedStyle = window.getComputedStyle(element);
                    return {
                        name: name,
                        width: rect.width,
                        height: rect.height,
                        computedWidth: computedStyle.width,
                        computedHeight: computedStyle.height,
                        paddingLeft: computedStyle.paddingLeft,
                        paddingRight: computedStyle.paddingRight,
                        marginLeft: computedStyle.marginLeft,
                        marginRight: computedStyle.marginRight,
                        boxSizing: computedStyle.boxSizing,
                        display: computedStyle.display,
                        position: computedStyle.position,
                        left: rect.left,
                        right: rect.right,
                    };
                }

                // Test both tabs by making them visible
                const myTasksTab = document.getElementById("myTasks");
                const allTasksTab = document.getElementById("allTasks");
                const userTasksContainer = document.getElementById("userTasks");
                const allTasksContainer =
                    document.getElementById("allTasksList");

                console.log("üìä TESTING MY TASKS TAB");
                console.log("=======================");

                // Show My Tasks tab
                showTab("myTasks");

                // Wait a moment for layout to settle
                setTimeout(() => {
                    const myTasksInfo = getWidthInfo(
                        myTasksTab,
                        "My Tasks Tab",
                    );
                    const userTasksInfo = getWidthInfo(
                        userTasksContainer,
                        "User Tasks Container",
                    );

                    console.log("My Tasks Tab:", myTasksInfo);
                    console.log("User Tasks Container:", userTasksInfo);

                    // Get task items
                    const myTaskItems =
                        userTasksContainer.querySelectorAll(".task-item");
                    console.log(`Found ${myTaskItems.length} My Tasks items`);
                    if (myTaskItems.length > 0) {
                        const firstMyTaskInfo = getWidthInfo(
                            myTaskItems[0],
                            "First My Task Item",
                        );
                        console.log("First My Task Item:", firstMyTaskInfo);
                    }

                    console.log("\nüìä TESTING ALL TASKS TAB");
                    console.log("========================");

                    // Show All Tasks tab
                    showTab("allTasks");

                    setTimeout(() => {
                        const allTasksInfo = getWidthInfo(
                            allTasksTab,
                            "All Tasks Tab",
                        );
                        const allTasksContainerInfo = getWidthInfo(
                            allTasksContainer,
                            "All Tasks Container",
                        );

                        console.log("All Tasks Tab:", allTasksInfo);
                        console.log(
                            "All Tasks Container:",
                            allTasksContainerInfo,
                        );

                        // Get task items
                        const allTaskItems =
                            allTasksContainer.querySelectorAll(".task-item");
                        console.log(
                            `Found ${allTaskItems.length} All Tasks items`,
                        );
                        if (allTaskItems.length > 0) {
                            const firstAllTaskInfo = getWidthInfo(
                                allTaskItems[0],
                                "First All Task Item",
                            );
                            console.log(
                                "First All Task Item:",
                                firstAllTaskInfo,
                            );
                        }

                        console.log("\nüéØ WIDTH COMPARISON SUMMARY");
                        console.log("============================");

                        // Compare widths
                        if (myTasksInfo && allTasksInfo) {
                            const tabWidthDiff =
                                myTasksInfo.width - allTasksInfo.width;
                            console.log(
                                `Tab Width Difference: ${tabWidthDiff}px`,
                            );
                        }

                        if (userTasksInfo && allTasksContainerInfo) {
                            const containerWidthDiff =
                                userTasksInfo.width -
                                allTasksContainerInfo.width;
                            console.log(
                                `Container Width Difference: ${containerWidthDiff}px`,
                            );
                        }

                        // Test task item widths if both exist
                        if (myTaskItems.length > 0 && allTaskItems.length > 0) {
                            const myTaskWidth =
                                myTaskItems[0].getBoundingClientRect().width;
                            const allTaskWidth =
                                allTaskItems[0].getBoundingClientRect().width;
                            const itemWidthDiff = myTaskWidth - allTaskWidth;
                            console.log(
                                `Task Item Width Difference: ${itemWidthDiff}px`,
                            );

                            if (Math.abs(itemWidthDiff) < 1) {
                                console.log(
                                    "‚úÖ Task items have consistent widths!",
                                );
                            } else {
                                console.log(
                                    "‚ùå Task items have different widths",
                                );
                            }
                        }

                        console.log("\nüèÅ DEBUGGING COMPLETE");
                        console.log("====================");
                    }, 500); // Wait for All Tasks to render
                }, 500); // Wait for My Tasks to render
            }

            // Add to window for easy access
            window.debugTabWidths = debugTabWidths;

            console.log(
                "‚úÖ Width debugging script loaded. Run debugTabWidths() to test.",
            );
        </script>
    </body>
</html>
