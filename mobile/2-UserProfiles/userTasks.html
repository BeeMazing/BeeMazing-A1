<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BeeMazing Profile</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/BeeMazing-A1/shared/avatar-styles.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --primary-color: #FFC107;
    --secondary-color: #212121;
    --accent-color: #FFFFFF;
    --light-bg: #FFFFF8; /* light background */
    --text-color: #FFFFFF; /* white text */
            --danger-color: #D32F2F;
            --modal-bg: rgba(33, 33, 33, 0.7);
            --header-height: 68px;
            --footer-height: 70px;
            --border-dark: #444754; /* 👈 Add this if not already present */
            --card-bg: #2A2B32;
            --cayenne-blue: #00B7EB;
        }
        body {
            font-family: 'Poppins', Arial, sans-serif;
            background-color: var(--light-bg);
            color: #6D4C41;
            min-height: 100vh;
            overflow-y: auto;
            padding-bottom: var(--footer-height);
        }
        .header {
    background: linear-gradient(135deg, var(--primary-color), #FFB300);
    padding: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    position: fixed;
    top: 0;
    width: 100%;
    height: var(--header-height);
    z-index: 100;
}

.title {
    font-size: 24px;
    font-weight: 600;
    color: var(--secondary-color);
    letter-spacing: 1px;
}


.content {
    position: absolute;
    top: 0;
    bottom: var(--footer-height);
    width: 100%;
    padding: 20px;
    overflow-y: auto;
    background-color: var(--light-bg); /* <-- Add this */
    background-image: url('data:image/svg+xml,%3Csvg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"%3E%3Ccircle cx="20" cy="20" r="2" fill="%23FFC107" fill-opacity="0.1"/%3E%3C/svg%3E');
    background-repeat: repeat;
    bottom: var(--footer-height);
}

        .profile-card {
            background: #FFFFFF;
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.1);
            padding: 20px;
            text-align: center;
            width: 100%;
            max-width: 480px;
            margin: 0 auto;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .profile-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
        }
        .profile-card h1 {
            font-size: 32px;
            font-weight: 600;
            color: #6D4C41;
            margin-bottom: 15px;
        }
        .profile-card p {
            font-size: 18px;
            color: #6D4C41;
            margin-bottom: 20px;
        }
        .reward-container {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            margin-bottom: 20px;
        }
        #sellButton {
            background: var(--secondary-color);
            color: var(--accent-color);
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-left: 20px;
            transition: background-color 0.3s ease;
        }
        #sellButton:hover {
            background: #424242;
        }
        .task-list {
            margin-top: 20px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }
        .task-item {
            background-color: #FFFFFF;
            color: #6D4C41;
            padding: 16px;
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            position: relative;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.1);
        }

        .task-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
        }
        .finished-btn {
            background: var(--primary-color);
            color: #6D4C41;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s ease;
        }
        .finished-btn:hover {
            background: #FFD54F;
            color: #6D4C41;
        }
       




















        .footer {
    position: fixed;
    bottom: 0;
    width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
    background: var(--secondary-color);
    padding: 10px 0;
    box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
    z-index: 100;
    height: var(--footer-height);
}
.footer a {
    text-decoration: none;
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.3s ease;
}
.footer a:hover {
    transform: scale(1.1);
}
.footer-icon img {
    width: 40px;
    height: 40px;
    filter: invert(100%) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
}
.footer a.active img {
    filter: invert(77%) sepia(88%) saturate(900%) hue-rotate(0deg)
        brightness(100%) contrast(100%) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2)) !important;
}
.footer-icon span {
    font-size: 12px;
    margin-top: 5px;
    font-weight: 600;
}
.footer a.active span {
    color: var(--primary-color);
}
@media (max-width: 600px) {
    .footer-icon img {
        width: 20px;
        height: 20px;
    }
}

.tab-button {
    background-coloor: var(--light-bg) !important;
    color: #6D4C41 !important;
    border: 2px solid var(--primary-color) !important;
    font-weight: 600;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    text-decoration: none;
    opacity: 0.6;
}

.tab-button:hover {
    background-color: rgba(255, 193, 7, 0.1) !important;
    transform: translateY(-1px);
}

.tab-button.active {
    background-color: var(--primary-color) !important;
    color: #6D4C41 !important;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
    opacity: 1;
}

.tab-content.hidden {
    display: none;
}

/* Utility classes for tab layout */
.flex {
    display: flex;
}

.justify-center {
    justify-content: center;
}

.mb-4 {
    margin-bottom: 1rem;
}

.px-4 {
    padding-left: 1rem;
    padding-right: 1rem;
}

.py-2 {
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
}

.rounded-l-lg {
    border-top-left-radius: 0.5rem;
    border-bottom-left-radius: 0.5rem;
}

.rounded-r-lg {
    border-top-right-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
}

.shadow-md {
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}




























        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
        }
        .modal-content, .sell-modal-content {
            background: #2A2B32; /* match task card background */
            color: var(--accent-color); /* white text */
            padding: 25px;
            border-radius: 15px;
            width: 85%;
            max-width: 400px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
            border: 2px solid var(--primary-color);
        }
        .modal-content strong, .sell-modal-content strong {
            color: var(--accent-color); /* white */
            font-weight: 600;
        }
      
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        .honey-drop {
            position: fixed;
            width: 15px;
            height: 20px;
            background: radial-gradient(circle, #FFB300 30%, var(--primary-color) 70%);
            border-radius: 50% 50% 70% 70%;
            animation: rain 1.5s linear forwards;
            z-index: 1001;
            pointer-events: none;
        }
        @keyframes rain {
            0% { transform: translateY(-20vh); opacity: 1; }
            100% { transform: translateY(120vh); opacity: 0.5; }
        }

        @keyframes floatUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            80% { transform: translate(-50%, -70%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -90%) scale(0.8); opacity: 0; }
        }
        .pulse {
            animation: pulse 1s ease-in-out;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        @media (max-width: 480px) {
            .profile-card {
                max-width: 100%;
                padding: 15px;
            }
            .reward-container {
                flex-direction: column;
                gap: 10px;
            }
            #sellButton {
                margin-left: 0;
                width: 100%;
            }
        }









        .date-header {
    background: var(--secondary-color);
    position: fixed; /* <--- change from sticky to fixed */
    top: 0;
    width: 100%;
    z-index: 50;
    padding: 5px 0;
    box-shadow: 0 4px 6px rgba(0,0,0,0.05);
}
.month-nav {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 4px 0;
    font-weight: bold;
    font-size: 18px;
    color: var(--accent-color); /* white text */
}
.month-nav button {
    background: var(--secondary-color); /* dark background */
    border: none;
    color: var(--accent-color);         /* white text */
    padding: 4px 10px;
    font-size: 16px;
    border-radius: 8px;
    margin: 0 8px;
    cursor: pointer;
}


.month-nav button:hover {
    background: var(--primary-color);  /* yellow on hover */
    color: var(--secondary-color);     /* black text */
}




/* Date picker start point */


.day-scroll-wrapper {
    display: flex;
    align-items: center;
    position: relative;
    background: transparent;
    padding: 6px 0;
    overflow: hidden;
}
.day-scroll {
    display: flex;
    overflow-x: auto;
    padding: 6px 10px;
    gap: 8px;
    background: transparent;
    scroll-behavior: smooth;
}
.day-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 38px;
}
.day-label {
    font-size: 10px;
    color: var(--accent-color); /* White text */
    text-align: center;
    margin-bottom: 2px;
    font-weight: 600;
}
.day {
    min-width: 38px;
    width: 38px;
    height: 38px;
    line-height: 38px;
    text-align: center;
    border-radius: 50%;
    background: var(--secondary-color); /* Black bubble */
    color: var(--accent-color); /* White text */
    font-weight: bold;
    cursor: pointer;
    flex-shrink: 0;
    transition: background-color 0.3s, transform 0.2s;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}
.day:hover {
    background: #FFF3CD;
    transform: scale(1.08);
}
.day.selected {
    background: var(--primary-color); /* Yellow when selected */
    color: var(--secondary-color); /* Black text */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
.day-scroll::-webkit-scrollbar {
    display: none;
}





/* Date picker end point */








.scroll-btn {
    background: var(--secondary-color);
    border: none;
    color: var(--accent-color);             /* White arrows */
    font-size: 20px;
    font-weight: bold;
    padding: 5px 10px;
    cursor: pointer;
    border-radius: 10px;
    margin: 0 5px;
}

@media (max-width: 600px) {
    .footer-icon img {
        width: 35px;
        height: 35px;
    }
}









@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}










@keyframes flashBang {
    0% { opacity: 0; }
    20% { opacity: 1; }
    70% { opacity: 1; }
    100% { opacity: 0; }
}

.reward-reveal {
    animation: rewardAppear 0.8s ease-out;
    text-align: center;
    padding-top: 20px;
}



.reward-title {
    font-size: 26px;
    color: var(--primary-color);
    font-weight: 700;
    margin-bottom: 10px;
    animation: floatText 1s ease-out;
}

.reward-description {
    font-size: 16px;
    color: var(--accent-color);
    margin-bottom: 20px;
    animation: floatText 1.2s ease-out;
}

.claim-button {
    background: var(--primary-color);
    color: var(--secondary-color);
    border: none;
    padding: 12px 20px;
    font-size: 16px;
    font-weight: bold;
    border-radius: 10px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.claim-button:hover {
    background-color: #ffd54f;
}

@keyframes rewardAppear {
    0% { transform: scale(0.6); opacity: 0; }
    60% { transform: scale(1.05); opacity: 1; }
    100% { transform: scale(1); }
}

@keyframes rewardPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.15); }
    100% { transform: scale(1); }
}

@keyframes floatText {
    0% { opacity: 0; transform: translateY(20px); }
    100% { opacity: 1; transform: translateY(0); }
}






@keyframes fadeInOverlay {
  0% { opacity: 0; }
  100% { opacity: 1; }
}














@keyframes chestZoomIn {
  0% {
    opacity: 0;
    transform: scale(0.8);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}






#chestVideoOverlay video {
  max-width: 90vw;
  max-height: 90vh;
  border-radius: 20px;
  box-shadow: 0 0 30px rgba(255, 193, 7, 0.6);
  background: #1a1a1a;
  display: block;
  animation: chestZoomIn 0.4s ease-out;
}






#changePasswordBtn {
    background: var(--primary-color);
    color: var(--secondary-color);
    border: none;
    padding: 12px 20px;
    font-size: 16px;
    font-weight: bold;
    border-radius: 10px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    display: inline-block;
    margin-top: 10px;
    margin-bottom: 20px;
}

#changePasswordBtn:hover {
    background-color: #FFD54F;
}




#newAdminPassword {
    padding: 16px;
    font-size: 20px;
    width: 100%;
    margin-top: 18px;
    margin-bottom: 22px;
    border-radius: 10px;
    border: 2px solid var(--primary-color);
    background-color: var(--card-bg);
    color: var(--text-color);
}







#confirmChangePasswordBtn {
    background: var(--secondary-color);
    color: var(--accent-color);
    padding: 12px 20px;
    font-size: 16px;
    font-weight: bold;
    border-radius: 10px;
    cursor: pointer;
    width: 100%;
    transition: background-color 0.3s ease;
}

#confirmChangePasswordBtn:hover {
    background: #424242;
}



.modal-content {
    animation: zoomIn 0.3s ease-out;
}

@keyframes zoomIn {
    0% { transform: scale(0.9); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}




/* Help Center notifications */

#offerHelpBadge, #needHelpBadge {
    display: none;
    position: absolute;
    top: -10px;
    min-width: 20px;
    height: 20px;
    line-height: 20px;
    border-radius: 50%;
    color: #FFFFFF;
    font-size: 12px;
    font-weight: 600;
    text-align: center;
    padding: 0 6px;
}
#offerHelpBadge {
    right: 20px;
    background: var(--cayenne-blue);
}
#needHelpBadge {
    right: -10px;
    background: var(--danger-color);
}
#offerHelpBadge.pulse, #needHelpBadge.pulse {
    animation: pulse 1s ease-in-out infinite;
}
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}


/* Help Center notifications */

    </style>
</head>
<body>

    <div class="date-header">
        <div class="month-nav">
            <button id="prevMonth">&lt;</button>
            <span id="monthLabel">Loading...</span>
            <button id="nextMonth">&gt;</button>
        </div>
        <div class="day-scroll-wrapper">
            <button class="scroll-btn" id="scrollLeft">&lt;</button>
            <div class="day-scroll" id="dayScrollContainer"></div>
            <button class="scroll-btn" id="scrollRight">&gt;</button>
        </div>
    </div>
    

        <div style="padding-top: calc(var(--header-height) + 80px); padding-left: 20px; padding-right: 20px; padding-bottom: 20px;">
            <div class="flex justify-center mb-4">
                <button onclick="showTab('myTasks')" class="tab-button px-4 py-2 rounded-l-lg shadow-md active">My Tasks</button>
                <button onclick="showTab('allTasks')" class="tab-button px-4 py-2 rounded-r-lg shadow-md">All Tasks</button>
            </div>
            
            <div id="myTasks" class="tab-content">
                <div id="userTasks" class="task-list">
                    <!-- My assigned tasks will be displayed here -->
                </div>
            </div>
            
            <div id="allTasks" class="tab-content hidden">
                <div id="allTasksList" class="task-list">
                    <!-- All tasks will be displayed here -->
                </div>
            </div>
        </div>


    <div class="footer">
      <a href="#" id="homeButton" class="footer-icon active" aria-label="Home">
          <img src="/BeeMazing-A1/mobile/1-Home/HomeBtn.png" alt="Home" />
      </a>
      <a href="#" id="tasksButton" class="footer-icon" aria-label="Tasks">
          <img src="/BeeMazing-A1/mobile/1-Home/TasksBtn.png" alt="Tasks" />
      </a>
      <a href="#" id="marketButton" class="footer-icon" aria-label="Market">
          <img src="/BeeMazing-A1/mobile/1-Home/MarketBtn.png" alt="Market" />
      </a>
  </div>
    
    


  <script src="/BeeMazing-A1/shared/taskrotations.js?t=${Date.now()}"></script>


    <script>

document.addEventListener("DOMContentLoaded", () => {
    const urlParams = new URLSearchParams(window.location.search);
    let adminEmail = urlParams.get('admin') || localStorage.getItem("currentAdminEmail");
    userName = urlParams.get('user'); // Set global userName
    const addPoints = Number(urlParams.get('addPoints')) || 0;

    if (adminEmail && adminEmail !== "null") {
        localStorage.setItem("currentAdminEmail", adminEmail);
    }

    if (userName && adminEmail) {
        // Check if user is admin
        const userData = JSON.parse(localStorage.getItem("userData")) || {};
        const permissions = userData[adminEmail]?.permissions || {};
        const isUserAdmin = permissions[userName] === "Admin";

        // Set footer button links
        const basePath = "/BeeMazing-A1/mobile/2-UserProfiles";
        const homeButton = document.getElementById("homeButton");
        const tasksButton = document.getElementById("tasksButton");
        const marketButton = document.getElementById("marketButton");

        if (homeButton) {
            const homePage = isUserAdmin ? "userAdmin.html" : "users.html";
            homeButton.href = `${basePath}/${homePage}?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
        }
        if (tasksButton) {
            tasksButton.href = `${basePath}/userTasks.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
        }
        if (marketButton) {
            marketButton.href = `${basePath}/usermarket.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
        }

        // Set active state
        document.querySelectorAll('.footer a').forEach(link => {
            const currentPath = window.location.pathname.replace(/\/$/, '');
            const linkPath = new URL(link.href, window.location.origin).pathname.replace(/\/$/, '');
            if (currentPath === linkPath) {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });

        loadUserTasks(userName);
        loadUserReward(userName);
        loadNotifications(userName); // Load notifications on page load

        const helpCenterBtn = document.getElementById("helpCenterBtn");
        if (helpCenterBtn) {
            helpCenterBtn.addEventListener("click", async () => {
                localStorage.setItem("lastHelpUser", userName);
                const helpURL = `/BeeMazing-A1/shared/helpCenter.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
                
                // Clear notifications for this user
                try {
                    const res = await fetch("https://beemazing1.onrender.com/api/notifications", {
                        method: "DELETE",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ adminEmail, user: userName })
                    });
                    const data = await res.json();
                    console.log("Clear notifications response:", data);
                    if (!res.ok) {
                        console.warn("Failed to clear notifications:", data.error);
                    }
                } catch (err) {
                    console.error("Error clearing notifications:", err.message);
                }

                window.location.href = helpURL;
            });
        }

        if (addPoints > 0) {
            setTimeout(async () => {
                await updateUserReward(userName, addPoints);
                triggerHoneyRain(addPoints);
                loadUserReward(userName);
            }, 500);
        }
    } else {
        document.getElementById('userTasks').innerHTML = "<p>Error: Missing user or admin email. Please log in again.</p>";
        document.getElementById('userName').textContent = "Error";
    }

    adjustContentTop();
    generateScrollableDates();
    showAdminControlsIfNeeded();
});

function showTab(tabId) {
    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));
    document.getElementById(tabId).classList.remove('hidden');
    document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.remove('active');
    });
    const activeButton = document.querySelector(`button[onclick="showTab('${tabId}')"]`);
    if (activeButton) {
        activeButton.classList.add('active');
    }
    
    // Load appropriate tasks based on selected tab
    const selectedDate = new Date().toLocaleDateString("sv-SE");
    if (userName) {
        if (tabId === 'myTasks') {
            loadUserTasks(userName, selectedDate);
        } else if (tabId === 'allTasks') {
            loadAllTasks(userName, selectedDate);
        }
    }
}



// addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////

let isLoadingUserTasks = false;
let userName = null; // Global userName variable

async function loadAllTasks(userName, selectedDate = new Date().toLocaleDateString("sv-SE")) {
    if (isLoadingUserTasks) {
        console.log("🐛 loadAllTasks already running, skipping");
        return;
    }
    
    isLoadingUserTasks = true;
    
    try {
        const allTasksDiv = document.getElementById("allTasksList");
        allTasksDiv.innerHTML = "<p>Loading tasks...</p>";

        const adminEmail = localStorage.getItem("currentAdminEmail");
        let tasks = [];

        try {
            const res = await fetch(`https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&t=${Date.now()}`, { cache: "no-store" });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || "Failed to fetch tasks");
            tasks = data.tasks || [];
        } catch (err) {
            console.error("Failed to fetch tasks from server:", err);
            allTasksDiv.innerHTML = "<p>Failed to load tasks. Please try again later.</p>";
            return;
        }

        // Show only tasks NOT originally assigned to current user AND not private
        const otherTasks = filterTasksForDate(tasks, selectedDate).filter(task => {
            if (!task || !task.users || !task.title || !task.date) return false;
            
            if (task.users.includes(userName)) return false; // Don't show tasks assigned to current user
            if (task.isPrivate === true) return false; // Don't show private tasks
            return true;
        });

        allTasksDiv.innerHTML = "";
        
        // Add informational message about all tasks
        const infoDiv = document.createElement("div");
        infoDiv.style.cssText = "background: #2a2a3e; border: 1px solid var(--primary-color); border-radius: 8px; padding: 12px; margin-bottom: 16px; font-size: 14px; color: #fff; text-align: center;";
        infoDiv.innerHTML = `
            <strong>🐝 All Tasks:</strong> Public tasks assigned to other members<br>
            <em style="color: var(--primary-color);">Complete any of these and get the buzz points! 🍯</em><br>
            <small style="color: #888;">Currently logged in as: ${userName || 'Unknown'}</small>
        `;
        allTasksDiv.appendChild(infoDiv);
        
        if (otherTasks.length === 0) {
            allTasksDiv.innerHTML += "<p>No other tasks available for this date.</p>";
        } else {
            for (const task of otherTasks) {
                try {
                    const taskDiv = document.createElement("div");
                    taskDiv.className = "task-item";

                    const isRotation = task.settings?.includes("Rotation");
                    let turnData;

                    if (isRotation) {
                        if (typeof mixedTurnData !== 'function') {
                            console.error(`mixedTurnData is not defined for task: ${task.title}`);
                            turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
                        } else {
                            try {
                                turnData = mixedTurnData(task, selectedDate);
                            } catch (error) {
                                console.error(`Error in mixedTurnData for task ${task.title}:`, error);
                                turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
                            }
                        }
                    } else {
                        if (typeof individualTurnData !== 'function') {
                            console.error(`individualTurnData is not defined for task: ${task.title}`);
                            turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
                        } else {
                            try {
                                turnData = individualTurnData(task, selectedDate);
                            } catch (error) {
                                console.error(`Error in individualTurnData for task ${task.title}:`, error);
                                turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
                            }
                        }
                    }

                    let taskHTML = `<strong>${task.title}</strong><br>`;
                    taskHTML += `<em style="color: #666;">Originally assigned to: ${task.users.join(', ')}</em><br>`;

                    if (isRotation) {
                        const activeTurn = turnData.turns.find(turn => !turn.isCompleted && !turn.isPending);
                        if (activeTurn) {
                            const nextTurnIndex = (activeTurn.index + 1) % task.users.length;
                            const nextUser = turnData.turns.find(t => t.index === nextTurnIndex)?.user || task.users[nextTurnIndex] || "—";
                            taskHTML += `Current Turn: ${activeTurn.user}<br>Next: ${nextUser}<br>`;
                        } else {
                            taskHTML += `<span style="color: green;">Turn: All done!</span><br>`;
                        }
                    }

                    taskHTML += `Buzz Points: ${task.reward || 0} 🍯 (goes to completer)<br>`;
                    
                    // Show total progress for other users' tasks
                    const totalCompleted = turnData.turns.reduce((sum, turn) => sum + (turn.isCompleted || turn.isPending ? 1 : 0), 0);
                    const totalRequired = isRotation ? turnData.turns.length : (turnData.requiredTimes * task.users.length);
                    taskHTML += `Total Progress: ${totalCompleted}/${totalRequired}<br>`;

                    taskDiv.innerHTML = taskHTML;

                    const todayStr = new Date().toLocaleDateString("sv-SE");
                    const isToday = selectedDate === todayStr;

                    let canFinish = false;
                    if (isToday) {
                        // Private tasks can only be completed by assigned users
                        if (task.isPrivate === true && !task.users.includes(userName)) {
                            canFinish = false;
                        } else {
                            if (isRotation) {
                                // For rotation tasks, anyone can complete if there's an active turn
                                const activeTurn = turnData.turns.find(turn => !turn.isCompleted && !turn.isPending);
                                canFinish = !!activeTurn;
                            } else {
                                // For individual tasks, anyone can complete if not all instances are done
                                const totalCompleted = turnData.turns.reduce((sum, turn) => sum + (turn.isCompleted || turn.isPending ? 1 : 0), 0);
                                const totalRequired = turnData.requiredTimes * task.users.length;
                                canFinish = totalCompleted < totalRequired;
                                
                                console.log("🔍 loadAllTasks: All Tasks completion debug", {
                                    taskTitle: task.title,
                                    totalCompleted,
                                    totalRequired,
                                    canFinish,
                                    turnData: turnData.turns,
                                    pendingTurns: turnData.turns.filter(turn => turn.isPending),
                                    completedTurns: turnData.turns.filter(turn => turn.isCompleted)
                                });
                            }
                        }
                    }

                    if (canFinish) {
                        const finishBtn = document.createElement("button");
                        finishBtn.className = "finished-btn";
                        finishBtn.textContent = `Complete Task (as ${userName})`;
                        finishBtn.addEventListener("click", (e) => {
                            e.stopPropagation();
                            if (!userName) {
                                alert("Error: User not identified. Please refresh the page.");
                                return;
                            }
                            finishTask(userName, task, selectedDate);
                        });
                        taskDiv.appendChild(finishBtn);
                    }

                    taskDiv.addEventListener("click", () => showTaskDetails(task, selectedDate));
                    allTasksDiv.appendChild(taskDiv);
                } catch (error) {
                    console.error(`🔥 Error processing task ${task.title}:`, error);
                }
            }
        }
        
        // Load As Needed tasks not assigned to current user
        try {
            await loadAsNeededTasks(userName, selectedDate, allTasksDiv, false); // false = only non-assigned tasks
        } catch (error) {
            console.error("🔥 Error loading As Needed tasks:", error);
        }
        
    } finally {
        isLoadingUserTasks = false;
    }
}

async function loadUserTasks(userName, selectedDate = new Date().toLocaleDateString("sv-SE")) {
    if (isLoadingUserTasks) {
        console.log("🐛 loadUserTasks already running, skipping");
        return;
    }
    
    isLoadingUserTasks = true;
    
    try {
        const userTasksDiv = document.getElementById("userTasks");
        userTasksDiv.innerHTML = "<p>Loading tasks...</p>";

        const adminEmail = localStorage.getItem("currentAdminEmail");
        let tasks = [];

        try {
            const res = await fetch(`https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&t=${Date.now()}`, { cache: "no-store" });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || "Failed to fetch tasks");
            tasks = data.tasks || [];

            console.log("loadUserTasks tasks:", tasks.map(t => ({
                title: t.title,
                date: t.date,
                daysOfWeek: t.daysOfWeek,
                specificDays: t.specificDays,
                users: t.users
            })));
        } catch (err) {
            console.error("Failed to fetch tasks from server:", err);
            userTasksDiv.innerHTML = "<p>Failed to load tasks. Please try again later.</p>";
            return;
        }

        const userTasks = filterTasksForDate(tasks, selectedDate).filter(task => {
            if (!task || !task.users || !task.title || !task.date) return false;
            return task.users.includes(userName); // Show only tasks assigned to current user
        });

        userTasksDiv.innerHTML = "";
        
        // Add informational message about the new system
        const infoDiv = document.createElement("div");
        infoDiv.style.cssText = "background: #2a2a3e; border: 1px solid var(--primary-color); border-radius: 8px; padding: 12px; margin-bottom: 16px; font-size: 14px; color: #fff; text-align: center;";
        infoDiv.innerHTML = `
            <strong>🐝 My Tasks:</strong> Your originally assigned tasks<br>
            <em style="color: var(--primary-color);">Anyone can complete your public tasks • Private tasks 🔒 only you can complete</em><br>
            <small style="color: #888;">Currently logged in as: ${userName || 'Unknown'}</small>
        `;
        userTasksDiv.appendChild(infoDiv);
        
        if (userTasks.length === 0) {
            userTasksDiv.innerHTML += "<p>No tasks assigned to you for this date.</p>";
        } else {
            for (const task of userTasks) {
                try {
                    const taskDiv = document.createElement("div");
                    taskDiv.className = "task-item";

                    const isRotation = task.settings?.includes("Rotation");
                    let turnData;

                    if (isRotation) {
                        if (typeof mixedTurnData !== 'function') {
                            console.error(`mixedTurnData is not defined for task: ${task.title}`);
                            turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
                        } else {
                            try {
                                turnData = mixedTurnData(task, selectedDate);
                            } catch (error) {
                                console.error(`Error in mixedTurnData for task ${task.title}:`, error);
                                turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
                            }
                        }
                    } else {
                        if (typeof individualTurnData !== 'function') {
                            console.error(`individualTurnData is not defined for task: ${task.title}`);
                            turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
                        } else {
                            try {
                                turnData = individualTurnData(task, selectedDate);
                            } catch (error) {
                                console.error(`Error in individualTurnData for task ${task.title}:`, error);
                                turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
                            }
                        }
                    }

                    const userTurns = turnData.turns.filter(turn => turn.user === userName);
                    const userTotal = userTurns.reduce((sum, turn) => sum + (turn.isCompleted || turn.isPending ? 1 : 0), 0);
                    const userRequiredTimes = isRotation ? userTurns.length : turnData.requiredTimes;
                    const isCompleted = userTotal >= userRequiredTimes;

                    let taskHTML = `<strong>${task.title}</strong>`;
                    if (task.isPrivate === true) {
                        taskHTML += ` <span style="color: #ff6b6b; font-size: 12px;">🔒 Private</span>`;
                    }
                    taskHTML += `<br>`;
                    if (task.users.length > 1) {
                        taskHTML += `<em style="color: #666;">Assigned to: ${task.users.join(', ')}</em><br>`;
                    }

                    if (isRotation) {
                        const activeTurn = turnData.turns.find(turn => !turn.isCompleted && !turn.isPending);
                        if (activeTurn) {
                            const nextTurnIndex = (activeTurn.index + 1) % task.users.length;
                            const nextUser = turnData.turns.find(t => t.index === nextTurnIndex)?.user || task.users[nextTurnIndex] || "—";
                            taskHTML += `Current Turn: ${activeTurn.user}<br>Next: ${nextUser}<br>`;
                        } else {
                            taskHTML += `<span style="color: green;">Turn: All done!</span><br>`;
                        }
                    }

                    taskHTML += `Buzz Points: ${task.reward || 0} 🍯 (goes to completer)<br>`;
                    
                    // Show progress for the current user vs. total task progress
                    const totalCompleted = turnData.turns.reduce((sum, turn) => sum + (turn.isCompleted || turn.isPending ? 1 : 0), 0);
                    const totalRequired = turnData.requiredTimes * task.users.length;
                    
                    console.log("🔍 loadUserTasks: My Tasks completion debug", {
                        taskTitle: task.title,
                        userTotal,
                        userRequiredTimes,
                        totalCompleted,
                        totalRequired,
                        turnData: turnData.turns,
                        isCompleted
                    });
                    
                    taskHTML += `Your Progress: ${userTotal}/${userRequiredTimes}<br>`;
                    taskHTML += `Total Progress: ${totalCompleted}/${totalRequired}<br>`;

                    taskDiv.innerHTML = taskHTML;

                    const todayStr = new Date().toLocaleDateString("sv-SE");
                    const isToday = selectedDate === todayStr;

                    let canFinish = false;
                    if (isToday) {
                        // Private tasks can only be completed by assigned users
                        if (task.isPrivate === true && !task.users.includes(userName)) {
                            canFinish = false;
                        } else {
                            if (isRotation) {
                                // For rotation tasks, anyone can complete if there's an active turn
                                const activeTurn = turnData.turns.find(turn => !turn.isCompleted && !turn.isPending);
                                canFinish = !!activeTurn;
                            } else {
                                // For individual tasks, check if there are still incomplete instances
                                const totalCompleted = turnData.turns.reduce((sum, turn) => sum + (turn.isCompleted || turn.isPending ? 1 : 0), 0);
                                const totalRequired = turnData.requiredTimes * task.users.length;
                                canFinish = totalCompleted < totalRequired;
                            }
                        }
                    }

                    if (canFinish) {
                        const finishBtn = document.createElement("button");
                        finishBtn.className = "finished-btn";
                        finishBtn.textContent = `Complete Task (as ${userName})`;
                        finishBtn.addEventListener("click", (e) => {
                            e.stopPropagation();
                            if (!userName) {
                                alert("Error: User not identified. Please refresh the page.");
                                return;
                            }
                            finishTask(userName, task, selectedDate); // userName is whoever is currently logged in
                        });
                        taskDiv.appendChild(finishBtn);
                    }

                    taskDiv.addEventListener("click", () => showTaskDetails(task, selectedDate));
                    userTasksDiv.appendChild(taskDiv);
                } catch (error) {
                    console.error(`🔥 Error processing regular task ${task.title}:`, error);
                    // Continue with next task instead of breaking the entire loop
                }
            }
        }
        
        // Load As Needed tasks and add them to the main task list
        console.log("🐛 ABOUT TO CALL loadAsNeededTasks with:", { userName, selectedDate });
        try {
            await loadAsNeededTasks(userName, selectedDate, userTasksDiv, true); // true = only assigned to user
        } catch (error) {
            console.error("🔥 Error loading As Needed tasks:", error);
        }
        
    } finally {
        isLoadingUserTasks = false;
    }
}

let isLoadingAsNeeded = false;
let asNeededCallCounter = 0;

async function loadAsNeededTasks(userName, selectedDate, userTasksDiv, onlyAssigned = false) {
    asNeededCallCounter++;
    console.log("🐛 loadAsNeededTasks call #" + asNeededCallCounter + " for:", userName);
    
    if (isLoadingAsNeeded) {
        console.log("🐛 loadAsNeededTasks already running, skipping call #" + asNeededCallCounter);
        return;
    }
    
    isLoadingAsNeeded = true;
    console.log("🐛 loadAsNeededTasks executing call #" + asNeededCallCounter);
    
    const adminEmail = localStorage.getItem("currentAdminEmail");



    try {
        const res = await fetch(`https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&t=${Date.now()}`, { cache: "no-store" });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || "Failed to fetch tasks");
        
        const allTasks = data.tasks || [];
        const asNeededOnly = allTasks.filter(t => t.repeat === "As Needed");
        console.log("🐛 Found", asNeededOnly.length, "As Needed tasks");
        
        // Filter As Needed tasks based on onlyAssigned parameter
        const asNeededTasks = allTasks.filter(task => {
            if (!task || task.repeat !== "As Needed" || !task.asNeeded) return false;
            if (onlyAssigned) {
                return task.users && task.users.includes(userName); // Only show assigned tasks
            }
            // For non-assigned tasks, exclude private ones
            if (task.users && task.users.includes(userName)) return false; // Don't show assigned tasks
            if (task.isPrivate === true) return false; // Don't show private tasks
            return true;
        });

        // Add As Needed tasks to the main task list
        console.log("🐛 Current userTasksDiv children before adding:", userTasksDiv.children.length);
        console.log("🐛 About to add", asNeededTasks.length, "As Needed tasks");
        
        for (const task of asNeededTasks) {
            console.log("🐛 Adding task:", task.title);
            const taskDiv = document.createElement("div");
            taskDiv.className = "task-item";
            
            // Style based on activation status
            if (task.activated) {
                // Active task - normal appearance with dashed border
                taskDiv.style.borderColor = "var(--primary-color)";
                taskDiv.style.borderStyle = "dashed";
                taskDiv.style.opacity = "1";
            } else {
                // Inactive task - dimmed appearance
                taskDiv.style.borderColor = "#666";
                taskDiv.style.borderStyle = "dashed";
                taskDiv.style.opacity = "0.6";
                taskDiv.style.backgroundColor = "#1F1F23";
            }

            let taskHTML = `<strong>${task.title}</strong> <span style="font-size: 12px; color: var(--primary-color);">(As Needed)</span>`;
            if (task.isPrivate === true) {
                taskHTML += ` <span style="color: #ff6b6b; font-size: 12px;">🔒 Private</span>`;
            }
            taskHTML += `<br>`;
            if (!onlyAssigned && task.users && task.users.length > 0) {
                taskHTML += `<em style="color: #666;">Originally assigned to: ${task.users.join(', ')}</em><br>`;
            }
            
            if (task.activated) {
                taskHTML += `Status: Ready<br>`;
            } else {
                taskHTML += `Status: <span style="color: #888;">Waiting to be activated</span><br>`;
            }
            
            taskHTML += `Buzz Points: ${task.reward || 0} 🍯 (goes to completer)<br>`;
            if (task.settings) {
                taskHTML += `Type: ${task.settings}<br>`;
            }

            taskDiv.innerHTML = taskHTML;

            // Only show finish button if task is activated and user can complete it
            if (task.activated) {
                let canComplete = true;
                // Private tasks can only be completed by assigned users
                if (task.isPrivate === true && (!task.users || !task.users.includes(userName))) {
                    canComplete = false;
                }
                
                if (canComplete) {
                    const finishBtn = document.createElement("button");
                    finishBtn.className = "finished-btn";
                    finishBtn.textContent = `Complete Task (as ${userName})`;
                    finishBtn.addEventListener("click", (e) => {
                        e.stopPropagation();
                        if (!userName) {
                            alert("Error: User not identified. Please refresh the page.");
                            return;
                        }
                        finishAsNeededTask(userName, task, selectedDate);
                    });
                    taskDiv.appendChild(finishBtn);
                }
            }

            taskDiv.addEventListener("click", () => showTaskDetails(task, selectedDate));
            userTasksDiv.appendChild(taskDiv);
        }
    } catch (err) {
        console.error("🔥 Failed to fetch as needed tasks:", err);
    } finally {
        isLoadingAsNeeded = false;
    }
}

async function finishAsNeededTask(userName, task, selectedDate) {
    const adminEmail = localStorage.getItem("currentAdminEmail");
    
    console.log("🔍 finishAsNeededTask: Task will be completed by:", userName, "regardless of original assignment");
    
    // Validation
    if (!userName) {
        console.error("🔥 finishAsNeededTask: No userName provided");
        alert("Error: User not identified. Please refresh the page.");
        return;
    }
    
    try {
        console.log("🔍 finishAsNeededTask: Task completion by:", {
            taskTitle: task.title,
            completer: userName,
            isPrivate: task.isPrivate
        });
        
        const response = await fetch("https://beemazing1.onrender.com/api/complete-as-needed-task", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                adminEmail: adminEmail,
                taskTitle: task.title,
                user: userName, // Who is actually completing the task
                date: selectedDate,
                isPrivate: task.isPrivate // Let backend enforce private task rules
            })
        });

        const data = await response.json();
        if (!response.ok) {
            console.error("🔥 finishAsNeededTask: Server error details:", {
                status: response.status,
                statusText: response.statusText,
                error: data.error,
                task: task.title,
                completer: userName,
                isPrivate: task.isPrivate
            });
            throw new Error(data.error || "Failed to complete task");
        }

        // Show success popup and trigger honey rain
        triggerHoneyRain(task.reward || 0);
        
        // Reload user tasks to reflect changes
        loadUserTasks(userName, selectedDate);
        loadUserReward(userName);

    } catch (error) {
        console.error("Error completing as needed task:", error);
        alert(`Error: ${error.message}`);
    }
}





// addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////



//---------

        async function loadUserReward(userName) {
          const adminEmail = localStorage.getItem("currentAdminEmail");
          try {
            const response = await fetch(`https://beemazing1.onrender.com/api/rewards?adminEmail=${encodeURIComponent(adminEmail)}`);
            const data = await response.json();
            if (!response.ok) throw new Error(data.error || "Failed to fetch rewards");
            const rewards = data.rewards || {};
            const userReward = rewards[userName] || 0;
            const rewardElement = document.getElementById("rewardAmount");
            if (rewardElement) {
              rewardElement.textContent = userReward;
            }
          } catch (err) {
            console.error("Error loading user reward:", err);
          }
        }
        
        



        function triggerHoneyRain(rewardAmount) {
          for (let i = 0; i < 50; i++) {
            const drop = document.createElement("div");
            drop.className = "honey-drop";
            drop.style.left = `${Math.random() * 100}vw`;
            drop.style.animationDelay = `${Math.random() * 0.5}s`;
            document.body.appendChild(drop);
            setTimeout(() => drop.remove(), 2000);
          }
          const popup = document.createElement("div");
          popup.className = "reward-popup";
          popup.textContent = `+${rewardAmount} 🍯`;
          document.body.appendChild(popup);
          setTimeout(() => {
            const rewardElement = document.getElementById("rewardAmount");
            rewardElement.classList.add("pulse");
            setTimeout(() => {
              rewardElement.classList.remove("pulse");
              popup.remove();
            }, 1000);
          }, 1000);
        }
        


//---------








// addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////


function showTaskDetails(task, selectedDate = new Date().toLocaleDateString("sv-SE")) {
    const isRotation = task.settings?.includes("Rotation");
    let turnData;

    if (isRotation) {
        if (typeof mixedTurnData !== 'function') {
            console.error(`mixedTurnData is not defined for task: ${task.title}`);
            turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
        } else {
            turnData = mixedTurnData(task, selectedDate);
        }
    } else {
        if (typeof individualTurnData !== 'function') {
            console.error(`individualTurnData is not defined for task: ${task.title}`);
            turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
        } else {
          try {
            turnData = individualTurnData(task, selectedDate);
          } catch (error) {
            console.error(`Error in individualTurnData for task ${task.title}:`, error);
            turnData = { turns: [], completedCount: 0, requiredTimes: 1 };
          }
        }
    }

    const userTurns = turnData.turns.filter(turn => turn.user === userName);
    const userTotal = userTurns.reduce((sum, turn) => sum + (turn.isCompleted || turn.isPending ? 1 : 0), 0);
    const userRequiredTimes = isRotation ? userTurns.length : turnData.requiredTimes;

    let modalHTML = `<strong>Title:</strong> ${task.title}<br>`;
    if (task.notes) modalHTML += `<strong>Notes:</strong> ${task.notes}<br>`;
    if (task.room) modalHTML += `<strong>Room:</strong> ${task.room}<br>`;
    modalHTML += `<strong>Reward:</strong> ${task.reward || 0} 🍯<br>`;
    modalHTML += `<strong>Repeat:</strong> ${task.repeat || "Daily"}<br>`;
    const [fromDate, toDate] = (task.date || "").split(" to ");
    if (!fromDate) {
        modalHTML += `<strong>Date:</strong> Unknown<br>`;
    } else if (!toDate || toDate === "3000-01-01" || toDate === fromDate) {
        modalHTML += `<strong>Date:</strong> ${fromDate}<br>`;
    } else {
        modalHTML += `<strong>Date:</strong> ${fromDate} to ${toDate}<br>`;
    }

    modalHTML += `<strong>Originally Assigned To:</strong> ${task.users.join(", ")}<br>`;
    modalHTML += `<strong>Privacy:</strong> ${task.isPrivate === true ? '🔒 Private (hidden from other users)' : '🌐 Public (visible to all users)'}<br>`;
    modalHTML += `<strong>Can Be Completed By:</strong> ${task.isPrivate === true ? 'Only assigned users' : 'Anyone 🐝'}<br>`;
    modalHTML += `<strong>Buzz Points Go To:</strong> Whoever completes it<br>`;
    
    if (isRotation) {
        modalHTML += `<strong>Rotation:</strong> Yes<br>`;
        const activeTurn = turnData.turns.find(turn => !turn.isCompleted && !turn.isPending);
        if (activeTurn) {
            const nextTurnIndex = (activeTurn.index + 1) % task.users.length;
            const nextUser = turnData.turns.find(t => t.index === nextTurnIndex)?.user || task.users[nextTurnIndex] || "—";
            modalHTML += `<strong>Current Turn:</strong> ${activeTurn.user}<br>`;
            modalHTML += `<strong>Next:</strong> ${nextUser}<br>`;
        } else {
            modalHTML += `<strong>All turns completed!</strong><br>`;
        }
    }

    const totalCompleted = turnData.turns.reduce((sum, turn) => sum + (turn.isCompleted || turn.isPending ? 1 : 0), 0);
    const totalRequired = isRotation ? turnData.turns.length : (turnData.requiredTimes * task.users.length);
    
    if (task.users.includes(userName)) {
        modalHTML += `<strong>Your Progress:</strong> ${userTotal}/${userRequiredTimes}<br>`;
    } else {
        modalHTML += `<strong>Your Progress:</strong> 0/0 (not originally assigned)<br>`;
    }
    modalHTML += `<strong>Total Progress:</strong> ${totalCompleted}/${totalRequired}<br>`;

    const modal = document.createElement("div");
    modal.className = "modal";
    modal.innerHTML = `<div class="modal-content">${modalHTML}</div>`;
    document.body.appendChild(modal);

    modal.addEventListener("click", (e) => {
        if (e.target.classList.contains("modal")) {
            modal.remove();
        }
    });
}

// addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////












        let monthOffset = 0;
        




        function generateScrollableDates(monthOffset = 0) {
    const container = document.getElementById("dayScrollContainer");
    container.innerHTML = "";

    const today = new Date();
    today.setDate(1);
    today.setMonth(today.getMonth() + monthOffset);

    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
    const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();

    document.getElementById("monthLabel").textContent = today.toLocaleDateString(undefined, {
        month: 'long',
        year: 'numeric'
    });

    const urlParams = new URLSearchParams(window.location.search);
    const userName = urlParams.get('user');
    const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
    const dayAbbreviations = ["S", "Mo", "Tu", "We", "Th", "Fr", "St"];

    for (let i = 1; i <= daysInMonth; i++) {
        const date = new Date(currentYear, currentMonth, i);
        const dayOfWeek = dayAbbreviations[date.getDay()]; // Get day abbreviation
        const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

        const containerDiv = document.createElement("div");
        containerDiv.className = "day-container";

        const label = document.createElement("span");
        label.className = "day-label";
        label.textContent = dayOfWeek;

        const btn = document.createElement("div");
        btn.className = "day";
        btn.textContent = i;
        btn.dataset.date = dateStr;

        btn.addEventListener("click", () => {
            document.querySelectorAll(".day").forEach(d => d.classList.remove("selected"));
            btn.classList.add("selected");
            
            // Load tasks for the currently active tab
            const myTasksTab = document.getElementById("myTasks");
            const allTasksTab = document.getElementById("allTasks");
            
            if (!myTasksTab.classList.contains("hidden")) {
                loadUserTasks(userName, dateStr);
            } else if (!allTasksTab.classList.contains("hidden")) {
                loadAllTasks(userName, dateStr);
            }
        });

        const now = new Date();
        const nowStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
        if (dateStr === nowStr) {
            btn.classList.add("selected");
            // Load tasks for the currently active tab on page load
            const myTasksTab = document.getElementById("myTasks");
            const allTasksTab = document.getElementById("allTasks");
            
            if (!myTasksTab.classList.contains("hidden")) {
                loadUserTasks(userName, dateStr);
            } else if (!allTasksTab.classList.contains("hidden")) {
                loadAllTasks(userName, dateStr);
            }
        }

        containerDiv.appendChild(label);
        containerDiv.appendChild(btn);
        container.appendChild(containerDiv);
    }

    setTimeout(() => {
        const selected = document.querySelector(".day.selected");
        if (selected) {
            selected.scrollIntoView({ behavior: "smooth", inline: "center" });
        }
    }, 50);
}








        document.getElementById("prevMonth").addEventListener("click", () => {
          monthOffset--;
          generateScrollableDates(monthOffset);
        });
        
        document.getElementById("nextMonth").addEventListener("click", () => {
          monthOffset++;
          generateScrollableDates(monthOffset);
        });
        
        document.getElementById("scrollLeft").addEventListener("click", () => {
          document.getElementById("dayScrollContainer").scrollBy({
            left: -200,
            behavior: "smooth"
          });
        });
        
        document.getElementById("scrollRight").addEventListener("click", () => {
          document.getElementById("dayScrollContainer").scrollBy({
            left: 200,
            behavior: "smooth"
          });
        });
        







        function adjustContentTop() {
          const header = document.querySelector(".date-header");
          const content = document.querySelector(".content");
          if (header && content) {
            const headerHeight = header.getBoundingClientRect().height;
            content.style.top = `${headerHeight}px`;
          }
        }
        
        function showAdminControlsIfNeeded() {
          const urlParams = new URLSearchParams(window.location.search);
          const currentUser = urlParams.get('user');
          const allUserData = JSON.parse(localStorage.getItem("userData")) || {};
          const currentAdmin = localStorage.getItem("currentAdminEmail");
          const userPermissions = allUserData[currentAdmin]?.permissions || {};
          const isUserAdmin = userPermissions[currentUser] === "Admin";
          const isLoggedInAsAdmin = localStorage.getItem("isAdmin") === "true";
          const changePasswordBtn = document.getElementById("changePasswordBtn");
        
          if (isUserAdmin && isLoggedInAsAdmin) {
            changePasswordBtn.style.display = "inline-block";
            if (!changePasswordBtn.dataset.listenersAdded) {
              changePasswordBtn.addEventListener("click", () => {
                const modal = document.getElementById("changePasswordModal");
                modal.style.display = "flex";
                document.getElementById("newAdminPassword").value = "";
                document.getElementById("newAdminPassword").focus();
              });
        
              document.getElementById("confirmChangePasswordBtn").addEventListener("click", () => {
                const newPassword = document.getElementById("newAdminPassword").value.trim();
                if (newPassword.length < 4) {
                  alert("Password must be at least 4 characters.");
                  return;
                }
                localStorage.setItem("adminPassword", newPassword);
                alert("Admin password updated!");
                document.getElementById("changePasswordModal").style.display = "none";
              });
        
              document.getElementById("changePasswordModal").addEventListener("click", (e) => {
                if (e.target.id === "changePasswordModal") {
                  document.getElementById("changePasswordModal").style.display = "none";
                }
              });
        
              changePasswordBtn.dataset.listenersAdded = "true";
            }
          } else {
            if (changePasswordBtn) changePasswordBtn.style.display = "none";
          }
        }
        
        


// for finish task button video preview
async function fetchAvatarPath(userName) {
  const adminEmail = localStorage.getItem("currentAdminEmail");
  try {
    const res = await fetch(`https://beemazing1.onrender.com/get-avatar?adminEmail=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`);
    const data = await res.json();
    if (!data.success || !data.avatar) {
      throw new Error(data.message || "Avatar not found");
    }
    return data.avatar; // returns full path like "/BeeMazing-A1/shared/Avatars/scorpion1.png"
  } catch (err) {
    console.warn("Could not fetch avatar path:", err);
    return null;
  }
}



// for finish task button video preview






async function finishTask(currentUser, task, selectedDate) {
  const today = selectedDate || new Date().toISOString().split("T")[0];
  const adminEmail = localStorage.getItem("currentAdminEmail");
  const button = event.target;
  button.disabled = true;

  console.log("🔍 finishTask: Starting submission", { currentUser, taskTitle: task.title, selectedDate: today, adminEmail });
  console.log("🔍 finishTask: Task will be completed by:", currentUser, "regardless of original assignment");
  
  // Validation
  if (!currentUser) {
    console.error("🔥 finishTask: No currentUser provided");
    button.disabled = false;
    alert("Error: User not identified. Please refresh the page.");
    return;
  }

  // Try to fetch avatar and derive video path (skip if not available)
  let videoPath = null;
  try {
    const avatarPath = await fetchAvatarPath(currentUser);
    const avatarId = avatarPath?.match(/\/([^/]+)\.png$/)?.[1];
    videoPath = avatarId ? `/BeeMazing-A1/shared/Avatars/Selected/Preview/${avatarId}.mp4` : null;
  } catch (err) {
    // Avatar not available - continue without video preview
    console.log("🔍 finishTask: Avatar not available for", currentUser, "- skipping video preview");
  }

  // Show video overlay if videoPath exists
  if (videoPath) {
    const overlay = document.getElementById("taskVideoOverlay");
    const videoEl = document.getElementById("taskAvatarVideo");
    if (overlay && videoEl) {
      overlay.style.display = "flex";
      videoEl.src = videoPath;
      videoEl.muted = false;
      videoEl.load();
      videoEl.play().catch(err => console.warn("Could not auto-play preview:", err));
      videoEl.onended = () => {
        overlay.style.display = "none";
        videoEl.src = "";
      };
    }
  }

  // Show submission popup
  const popup = document.createElement("div");
  popup.className = "reward-popup";
  popup.textContent = `Submitting Task...`;
  document.body.appendChild(popup);

  try {
    console.log("🔍 finishTask: Task completion by:", {
      taskTitle: task.title,
      completer: currentUser,
      isPrivate: task.isPrivate
    });
    
    const response = await fetch("https://beemazing1.onrender.com/api/complete-task", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ 
        adminEmail, 
        taskTitle: task.title.trim(), 
        user: currentUser, // Who is actually completing the task
        date: today,
        isPrivate: task.isPrivate // Let backend enforce private task rules
      })
    });
    const data = await response.json();
    if (!response.ok) {
      console.error("🔥 finishTask: Server error details:", {
        status: response.status,
        statusText: response.statusText,
        error: data.error,
        task: task.title,
        completer: currentUser,
        isPrivate: task.isPrivate
      });
      throw new Error(data.error || `HTTP error ${response.status}`);
    }

    console.log("✅ finishTask: Task submitted", data);
    popup.textContent = `Task Submitted by ${currentUser}! Waiting for Parent Review`;

    // Update the specific task's turn display immediately
    const taskItems = document.querySelectorAll(".task-item");
    taskItems.forEach(taskItem => {
      if (taskItem.querySelector("strong").textContent === task.title) {
        const isRotation = task.settings?.includes("Rotation");
        if (isRotation && data.currentTurnIndex !== undefined && data.nextUser) {
          // Update turn information
          let turnHTML = `<strong>${task.title}</strong><br>`;
          if (data.nextUser !== "—") {
            const nextTurnIndex = (data.currentTurnIndex + 1) % task.users.length;
            const nextNextUser = task.users[nextTurnIndex] || "—";
            turnHTML += `Turn: ${data.nextUser}<br>Next: ${nextNextUser}<br>`;
          } else {
            turnHTML += `<span style="color: green;">Turn: All done!</span><br>`;
          }
          turnHTML += `Buzz Points: ${task.reward || 0} 🍯<br>`;
          // Recalculate progress
          const turnData = mixedTurnData(task, today);
          const userTurns = turnData.turns.filter(turn => turn.user === currentUser);
          const userTotal = userTurns.reduce((sum, turn) => sum + (turn.isCompleted || turn.isPending ? 1 : 0), 0);
          const userRequiredTimes = userTurns.length;
          turnHTML += `Progress: ${userTotal}/${userRequiredTimes}<br>`;
          taskItem.innerHTML = turnHTML;

          // Reattach the Finish Task button if still applicable
          const isToday = today === new Date().toLocaleDateString("sv-SE");
          let canFinish = false;
          if (isToday && userTotal < userRequiredTimes) {
            const activeTurn = turnData.turns.find(turn => !turn.isCompleted && !turn.isPending);
            canFinish = activeTurn?.user === currentUser;
          }
          if (canFinish) {
            const finishBtn = document.createElement("button");
            finishBtn.className = "finished-btn";
            finishBtn.textContent = "Finish Task";
            finishBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              finishTask(currentUser, task, today);
            });
            taskItem.appendChild(finishBtn);
          }
        }
      }
    });

    setTimeout(() => {
      popup.remove();
      loadUserTasks(currentUser, today); // Full refresh to ensure consistency
    }, 2000);
  } catch (err) {
    console.error("🔥 finishTask: Error submitting task", {
      error: err,
      message: err.message,
      task: task.title,
      completer: currentUser,
      isPrivate: task.isPrivate
    });
    popup.textContent = `Error: ${err.message}`;
    popup.style.color = "red";
    setTimeout(() => {
      popup.remove();
      button.disabled = false;
    }, 3000);
  }
}









        
        window.addEventListener("resize", adjustContentTop);
        window.addEventListener("load", adjustContentTop);
        window.addEventListener("storage", (event) => {
          if (event.key === "isAdmin" || event.key === "userPermissions") {
            showAdminControlsIfNeeded();
          }
        });






        async function loadNotifications(userName) {
    const adminEmail = localStorage.getItem("currentAdminEmail");
    const offerHelpBadge = document.getElementById("offerHelpBadge");
    const needHelpBadge = document.getElementById("needHelpBadge");
    if (!adminEmail || !userName) {
        console.error("loadNotifications: Missing adminEmail or userName");
        if (offerHelpBadge) offerHelpBadge.style.display = "none";
        if (needHelpBadge) needHelpBadge.style.display = "none";
        return;
    }
    try {
        const res = await fetch(`https://beemazing1.onrender.com/api/notifications?adminEmail=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}&t=${Date.now()}`, {
            method: "GET",
            headers: { "Content-Type": "application/json" }
        });
        const data = await res.json();
        console.log("Load notifications response:", data);
        if (!res.ok) {
            throw new Error(data.error || "Failed to fetch notifications");
        }
        const notifications = data.notifications || [];
        if (notifications.length === 0) {
            if (offerHelpBadge) offerHelpBadge.style.display = "none";
            if (needHelpBadge) needHelpBadge.style.display = "none";
            return;
        }
        const offerHelpNotifications = notifications.filter(n => n.offerType === "offerHelp");
        const needHelpNotifications = notifications.filter(n => n.offerType === "needHelp");
        const offerHelpCount = offerHelpNotifications.reduce((sum, n) => sum + n.taskCount, 0);
        const needHelpCount = needHelpNotifications.reduce((sum, n) => sum + n.taskCount, 0);
        if (offerHelpBadge) {
            if (offerHelpCount > 0) {
                offerHelpBadge.textContent = `${offerHelpCount}`;
                offerHelpBadge.style.display = "block";
            } else {
                offerHelpBadge.style.display = "none";
            }
        }
        if (needHelpBadge) {
            if (needHelpCount > 0) {
                needHelpBadge.textContent = `${needHelpCount}`;
                needHelpBadge.style.display = "block";
            } else {
                needHelpBadge.style.display = "none";
            }
        }
    } catch (err) {
        console.error("Failed to load notifications:", err.message);
        if (offerHelpBadge) offerHelpBadge.style.display = "none";
        if (needHelpBadge) needHelpBadge.style.display = "none";
    }
}




        </script>

    <script src="/BeeMazing-A1/shared/avatar-system.js"></script>







<div id="chestVideoOverlay" style="
    display:none;
    position:fixed;
    top:0; left:0;
    width:100%; height:100%;
    background: rgba(10, 10, 10, 0.959); /* darkened more */
backdrop-filter: blur(5px);
    z-index:2000;
    justify-content:center;
    align-items:center;
    overflow: hidden;
">
<video id="chestVideo"
autoplay
muted
playsinline
style="
    max-width: 90vw;
    max-height: 90vh;
    border-radius: 20px;
    box-shadow: 0 0 30px rgba(255, 193, 7, 0.6);
    background: #1a1a1a;
    display: block;
">
<source src="/BeeMazing-A1/mobile/4-Market/LuckyChest/Chest_fixed.mp4" type="video/mp4" />
Your browser does not support the video tag.
</video>
<audio id="chestUnlockSound" preload="auto">
    <source src="/BeeMazing-A1/mobile/4-Market/LuckyChest/ChestUnlock.mp3" type="audio/mp3" />
    Your browser does not support the audio element.
</audio>


</div>




<div id="taskVideoOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:9999; justify-content:center; align-items:center; flex-direction:column;">
  <h1 style="color: gold; font-size: 36px; margin-bottom: 20px; font-family: Orbitron, sans-serif;">Well Done!</h1>
  <video id="taskAvatarVideo" autoplay playsinline style="max-width:90vw; max-height:70vh; border-radius:20px; box-shadow: 0 0 30px gold; background: black;"></video>
</div>



</body>
</html>