<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>BeeMazing Profile</title>
        <link
            href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap"
            rel="stylesheet"
        />
        <link rel="stylesheet" href="/BeeMazing-A1/shared/avatar-styles.css" />
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            :root {
                --primary-color: #ffc107;
                --secondary-color: #212121;
                --accent-color: #ffffff;
                --light-bg: #fffff8; /* light background */
                --text-color: #ffffff; /* white text */
                --danger-color: #d32f2f;
                --modal-bg: rgba(33, 33, 33, 0.7);
                --header-height: 68px;
                --footer-height: 70px;
                --border-dark: #444754; /* 👈 Add this if not already present */
                --card-bg: #2a2b32;
                --cayenne-blue: #00b7eb;
            }
            body {
                font-family: "Poppins", Arial, sans-serif;
                background-color: var(--light-bg);
                color: #6d4c41;
                min-height: 100vh;
                overflow-y: auto;
                padding-bottom: var(--footer-height);
            }
            .header {
                background: linear-gradient(
                    135deg,
                    var(--primary-color),
                    #ffb300
                );
                padding: 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
                position: fixed;
                top: 0;
                width: 100%;
                height: var(--header-height);
                z-index: 100;
            }

            .title {
                font-size: 24px;
                font-weight: 600;
                color: var(--secondary-color);
                letter-spacing: 1px;
            }

            .content {
                position: absolute;
                top: 0;
                bottom: var(--footer-height);
                width: 100%;
                padding: 20px;
                overflow-y: auto;
                background-color: var(--light-bg); /* <-- Add this */
                background-image: url('data:image/svg+xml,%3Csvg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"%3E%3Ccircle cx="20" cy="20" r="2" fill="%23FFC107" fill-opacity="0.1"/%3E%3C/svg%3E');
                background-repeat: repeat;
                bottom: var(--footer-height);
            }

            .profile-card {
                background: #ffffff;
                border: 2px solid var(--primary-color);
                border-radius: 12px;
                box-shadow: 0 2px 8px rgba(255, 193, 7, 0.1);
                padding: 20px;
                text-align: center;
                width: 100%;
                max-width: 480px;
                margin: 0 auto;
                transition:
                    transform 0.3s ease,
                    box-shadow 0.3s ease;
            }
            .profile-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
            }
            .profile-card h1 {
                font-size: 32px;
                font-weight: 600;
                color: #6d4c41;
                margin-bottom: 15px;
            }
            .profile-card p {
                font-size: 18px;
                color: #6d4c41;
                margin-bottom: 20px;
            }
            .reward-container {
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 20px;
                margin-bottom: 20px;
            }
            #sellButton {
                background: var(--secondary-color);
                color: var(--accent-color);
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                margin-left: 20px;
                transition: background-color 0.3s ease;
            }
            #sellButton:hover {
                background: #424242;
            }
            .task-list {
                margin-top: 20px;
                display: grid;
                grid-template-columns: 1fr;
                gap: 15px;
            }
            .task-item {
                background-color: #ffffff;
                color: #6d4c41;
                padding: 16px;
                border: 2px solid var(--primary-color);
                border-radius: 12px;
                margin-bottom: 12px;
                cursor: pointer;
                position: relative;
                transition:
                    transform 0.3s ease,
                    box-shadow 0.3s ease;
                box-shadow: 0 2px 8px rgba(255, 193, 7, 0.1);
            }

            .task-item:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
            }
            .finished-btn {
                background: var(--primary-color);
                color: #6d4c41;
                border: none;
                padding: 12px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                margin-top: 10px;
                transition: background-color 0.3s ease;
            }
            .finished-btn:hover {
                background: #ffd54f;
                color: #6d4c41;
            }

            .footer {
                position: fixed;
                bottom: 0;
                width: 100%;
                display: flex;
                justify-content: space-around;
                align-items: center;
                background: var(--secondary-color);
                padding: 10px 0;
                box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
                z-index: 100;
                height: var(--footer-height);
            }
            .footer a {
                text-decoration: none;
                color: var(--text-color);
                display: flex;
                flex-direction: column;
                align-items: center;
                transition: transform 0.3s ease;
            }
            .footer a:hover {
                transform: scale(1.1);
            }
            .footer-icon img {
                width: 40px;
                height: 40px;
                filter: invert(100%) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
            }
            .footer a.active img {
                filter: invert(77%) sepia(88%) saturate(900%) hue-rotate(0deg)
                    brightness(100%) contrast(100%)
                    drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2)) !important;
            }
            .footer-icon span {
                font-size: 12px;
                margin-top: 5px;
                font-weight: 600;
            }
            .footer a.active span {
                color: var(--primary-color);
            }
            @media (max-width: 600px) {
                .footer-icon img {
                    width: 20px;
                    height: 20px;
                }
            }

            .tab-button {
                background-coloor: var(--light-bg) !important;
                color: #6d4c41 !important;
                border: 2px solid var(--primary-color) !important;
                font-weight: 600;
                font-size: 1.2rem;
                transition: all 0.3s ease;
                text-decoration: none;
                opacity: 0.6;
            }

            .tab-button:hover {
                background-color: rgba(255, 193, 7, 0.1) !important;
                transform: translateY(-1px);
            }

            .tab-button.active {
                background-color: var(--primary-color) !important;
                color: #6d4c41 !important;
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
                opacity: 1;
            }

            .tab-content.hidden {
                display: none;
            }

            /* Utility classes for tab layout */
            .flex {
                display: flex;
            }

            .justify-center {
                justify-content: center;
            }

            .mb-4 {
                margin-bottom: 1rem;
            }

            .px-4 {
                padding-left: 1rem;
                padding-right: 1rem;
            }

            .py-2 {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
            }

            .rounded-l-lg {
                border-top-left-radius: 0.5rem;
                border-bottom-left-radius: 0.5rem;
            }

            .rounded-r-lg {
                border-top-right-radius: 0.5rem;
                border-bottom-right-radius: 0.5rem;
            }

            .shadow-md {
                box-shadow:
                    0 4px 6px -1px rgba(0, 0, 0, 0.1),
                    0 2px 4px -1px rgba(0, 0, 0, 0.06);
            }

            .modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: var(--modal-bg);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                animation: fadeIn 0.3s ease-out;
            }
            .modal-content,
            .sell-modal-content {
                background: #2a2b32; /* match task card background */
                color: var(--accent-color); /* white text */
                padding: 25px;
                border-radius: 15px;
                width: 85%;
                max-width: 400px;
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
                border: 2px solid var(--primary-color);
            }
            .modal-content strong,
            .sell-modal-content strong {
                color: var(--accent-color); /* white */
                font-weight: 600;
            }

            @keyframes fadeIn {
                0% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }
            .honey-drop {
                position: fixed;
                width: 15px;
                height: 20px;
                background: radial-gradient(
                    circle,
                    #ffb300 30%,
                    var(--primary-color) 70%
                );
                border-radius: 50% 50% 70% 70%;
                animation: rain 1.5s linear forwards;
                z-index: 1001;
                pointer-events: none;
            }
            @keyframes rain {
                0% {
                    transform: translateY(-20vh);
                    opacity: 1;
                }
                100% {
                    transform: translateY(120vh);
                    opacity: 0.5;
                }
            }

            @keyframes floatUp {
                0% {
                    transform: translate(-50%, -50%) scale(0.5);
                    opacity: 0;
                }
                20% {
                    transform: translate(-50%, -50%) scale(1);
                    opacity: 1;
                }
                80% {
                    transform: translate(-50%, -70%) scale(1);
                    opacity: 1;
                }
                100% {
                    transform: translate(-50%, -90%) scale(0.8);
                    opacity: 0;
                }
            }
            .pulse {
                animation: pulse 1s ease-in-out;
            }
            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.2);
                }
                100% {
                    transform: scale(1);
                }
            }
            @media (max-width: 480px) {
                .profile-card {
                    max-width: 100%;
                    padding: 15px;
                }
                .reward-container {
                    flex-direction: column;
                    gap: 10px;
                }
                #sellButton {
                    margin-left: 0;
                    width: 100%;
                }
            }

            .date-header {
                background: var(--secondary-color);
                position: fixed; /* <--- change from sticky to fixed */
                top: 0;
                width: 100%;
                z-index: 50;
                padding: 5px 0;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            }
            .month-nav {
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 4px 0;
                font-weight: bold;
                font-size: 18px;
                color: var(--accent-color); /* white text */
            }
            .month-nav button {
                background: var(--secondary-color); /* dark background */
                border: none;
                color: var(--accent-color); /* white text */
                padding: 4px 10px;
                font-size: 16px;
                border-radius: 8px;
                margin: 0 8px;
                cursor: pointer;
            }

            .month-nav button:hover {
                background: var(--primary-color); /* yellow on hover */
                color: var(--secondary-color); /* black text */
            }

            /* Date picker start point */

            .day-scroll-wrapper {
                display: flex;
                align-items: center;
                position: relative;
                background: transparent;
                padding: 6px 0;
                overflow: hidden;
            }
            .day-scroll {
                display: flex;
                overflow-x: auto;
                padding: 6px 10px;
                gap: 8px;
                background: transparent;
                scroll-behavior: smooth;
            }
            .day-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                min-width: 38px;
            }
            .day-label {
                font-size: 10px;
                color: var(--accent-color); /* White text */
                text-align: center;
                margin-bottom: 2px;
                font-weight: 600;
            }
            .day {
                min-width: 38px;
                width: 38px;
                height: 38px;
                line-height: 38px;
                text-align: center;
                border-radius: 50%;
                background: var(--secondary-color); /* Black bubble */
                color: var(--accent-color); /* White text */
                font-weight: bold;
                cursor: pointer;
                flex-shrink: 0;
                transition:
                    background-color 0.3s,
                    transform 0.2s;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            }
            .day:hover {
                background: #fff3cd;
                transform: scale(1.08);
            }
            .day.selected {
                background: var(--primary-color); /* Yellow when selected */
                color: var(--secondary-color); /* Black text */
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            }
            .day-scroll::-webkit-scrollbar {
                display: none;
            }

            @keyframes celebrationPulse {
                0% {
                    transform: scale(1);
                    opacity: 1;
                }
                50% {
                    transform: scale(1.3);
                    opacity: 0.8;
                }
                100% {
                    transform: scale(1);
                    opacity: 1;
                }
            }

            /* Date picker end point */

            .scroll-btn {
                background: var(--secondary-color);
                border: none;
                color: var(--accent-color); /* White arrows */
                font-size: 20px;
                font-weight: bold;
                padding: 5px 10px;
                cursor: pointer;
                border-radius: 10px;
                margin: 0 5px;
            }

            @media (max-width: 600px) {
                .footer-icon img {
                    width: 35px;
                    height: 35px;
                }
            }

            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.1);
                }
                100% {
                    transform: scale(1);
                }
            }

            @keyframes flashBang {
                0% {
                    opacity: 0;
                }
                20% {
                    opacity: 1;
                }
                70% {
                    opacity: 1;
                }
                100% {
                    opacity: 0;
                }
            }

            .reward-reveal {
                animation: rewardAppear 0.8s ease-out;
                text-align: center;
                padding-top: 20px;
            }

            .reward-title {
                font-size: 26px;
                color: var(--primary-color);
                font-weight: 700;
                margin-bottom: 10px;
                animation: floatText 1s ease-out;
            }

            .reward-description {
                font-size: 16px;
                color: var(--accent-color);
                margin-bottom: 20px;
                animation: floatText 1.2s ease-out;
            }

            .claim-button {
                background: var(--primary-color);
                color: var(--secondary-color);
                border: none;
                padding: 12px 20px;
                font-size: 16px;
                font-weight: bold;
                border-radius: 10px;
                cursor: pointer;
                transition: background-color 0.3s ease;
            }

            .claim-button:hover {
                background-color: #ffd54f;
            }

            @keyframes rewardAppear {
                0% {
                    transform: scale(0.6);
                    opacity: 0;
                }
                60% {
                    transform: scale(1.05);
                    opacity: 1;
                }
                100% {
                    transform: scale(1);
                }
            }

            @keyframes rewardPulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.15);
                }
                100% {
                    transform: scale(1);
                }
            }

            @keyframes floatText {
                0% {
                    opacity: 0;
                    transform: translateY(20px);
                }
                100% {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            @keyframes fadeInOverlay {
                0% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }

            @keyframes chestZoomIn {
                0% {
                    opacity: 0;
                    transform: scale(0.8);
                }
                100% {
                    opacity: 1;
                    transform: scale(1);
                }
            }

            #chestVideoOverlay video {
                max-width: 90vw;
                max-height: 90vh;
                border-radius: 20px;
                box-shadow: 0 0 30px rgba(255, 193, 7, 0.6);
                background: #1a1a1a;
                display: block;
                animation: chestZoomIn 0.4s ease-out;
            }

            #changePasswordBtn {
                background: var(--primary-color);
                color: var(--secondary-color);
                border: none;
                padding: 12px 20px;
                font-size: 16px;
                font-weight: bold;
                border-radius: 10px;
                cursor: pointer;
                transition: background-color 0.3s ease;
                display: inline-block;
                margin-top: 10px;
                margin-bottom: 20px;
            }

            #changePasswordBtn:hover {
                background-color: #ffd54f;
            }

            #newAdminPassword {
                padding: 16px;
                font-size: 20px;
                width: 100%;
                margin-top: 18px;
                margin-bottom: 22px;
                border-radius: 10px;
                border: 2px solid var(--primary-color);
                background-color: var(--card-bg);
                color: var(--text-color);
            }

            #confirmChangePasswordBtn {
                background: var(--secondary-color);
                color: var(--accent-color);
                padding: 12px 20px;
                font-size: 16px;
                font-weight: bold;
                border-radius: 10px;
                cursor: pointer;
                width: 100%;
                transition: background-color 0.3s ease;
            }

            #confirmChangePasswordBtn:hover {
                background: #424242;
            }

            .modal-content {
                animation: zoomIn 0.3s ease-out;
            }

            @keyframes zoomIn {
                0% {
                    transform: scale(0.9);
                    opacity: 0;
                }
                100% {
                    transform: scale(1);
                    opacity: 1;
                }
            }

            /* Help Center notifications */

            #offerHelpBadge,
            #needHelpBadge {
                display: none;
                position: absolute;
                top: -10px;
                min-width: 20px;
                height: 20px;
                line-height: 20px;
                border-radius: 50%;
                color: #ffffff;
                font-size: 12px;
                font-weight: 600;
                text-align: center;
                padding: 0 6px;
            }
            #offerHelpBadge {
                right: 20px;
                background: var(--cayenne-blue);
            }
            #needHelpBadge {
                right: -10px;
                background: var(--danger-color);
            }
            #offerHelpBadge.pulse,
            #needHelpBadge.pulse {
                animation: pulse 1s ease-in-out infinite;
            }
            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.2);
                }
                100% {
                    transform: scale(1);
                }
            }

            /* Help Center notifications */
        </style>
    </head>
    <body>
        <div class="date-header">
            <div class="month-nav">
                <button id="prevMonth">&lt;</button>
                <span id="monthLabel">Loading...</span>
                <button id="nextMonth">&gt;</button>
            </div>
            <div class="day-scroll-wrapper">
                <button class="scroll-btn" id="scrollLeft">&lt;</button>
                <div class="day-scroll" id="dayScrollContainer"></div>
                <button class="scroll-btn" id="scrollRight">&gt;</button>
            </div>
        </div>

        <div
            style="
                padding-top: calc(var(--header-height) + 80px);
                padding-left: 20px;
                padding-right: 20px;
                padding-bottom: 20px;
            "
        >
            <div class="flex justify-center mb-4">
                <button
                    onclick="showTab('myTasks')"
                    class="tab-button px-4 py-2 rounded-l-lg shadow-md active"
                >
                    My Tasks
                </button>
                <button
                    onclick="showTab('allTasks')"
                    class="tab-button px-4 py-2 rounded-r-lg shadow-md"
                >
                    All Tasks
                </button>
            </div>

            <div id="myTasks" class="tab-content">
                <div id="userTasks" class="task-list">
                    <!-- My assigned tasks will be displayed here -->
                </div>
            </div>

            <div id="allTasks" class="tab-content hidden">
                <div id="allTasksList" class="task-list">
                    <!-- All tasks will be displayed here -->
                </div>
            </div>
        </div>

        <div class="footer">
            <a
                href="#"
                id="homeButton"
                class="footer-icon active"
                aria-label="Home"
            >
                <img src="/BeeMazing-A1/mobile/1-Home/HomeBtn.png" alt="Home" />
            </a>
            <a href="#" id="tasksButton" class="footer-icon" aria-label="Tasks">
                <img
                    src="/BeeMazing-A1/mobile/1-Home/TasksBtn.png"
                    alt="Tasks"
                />
            </a>
            <a
                href="#"
                id="marketButton"
                class="footer-icon"
                aria-label="Market"
            >
                <img
                    src="/BeeMazing-A1/mobile/1-Home/MarketBtn.png"
                    alt="Market"
                />
            </a>
        </div>

        <script src="/BeeMazing-A1/shared/taskrotations.js?t=${Date.now()}"></script>

        <script>
            document.addEventListener("DOMContentLoaded", () => {
                const urlParams = new URLSearchParams(window.location.search);
                let adminEmail =
                    urlParams.get("admin") ||
                    localStorage.getItem("currentAdminEmail");
                userName = urlParams.get("user"); // Set global userName
                const addPoints = Number(urlParams.get("addPoints")) || 0;

                if (adminEmail && adminEmail !== "null") {
                    localStorage.setItem("currentAdminEmail", adminEmail);
                }

                if (userName && adminEmail) {
                    // Check if user is admin
                    const userData =
                        JSON.parse(localStorage.getItem("userData")) || {};
                    const permissions = userData[adminEmail]?.permissions || {};
                    const isUserAdmin = permissions[userName] === "Admin";

                    // Set footer button links
                    const basePath = "/BeeMazing-A1/mobile/2-UserProfiles";
                    const homeButton = document.getElementById("homeButton");
                    const tasksButton = document.getElementById("tasksButton");
                    const marketButton =
                        document.getElementById("marketButton");

                    if (homeButton) {
                        const homePage = isUserAdmin
                            ? "userAdmin.html"
                            : "users.html";
                        homeButton.href = `${basePath}/${homePage}?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
                    }
                    if (tasksButton) {
                        tasksButton.href = `${basePath}/userTasks.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
                    }
                    if (marketButton) {
                        marketButton.href = `${basePath}/usermarket.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
                    }

                    // Set active state
                    document.querySelectorAll(".footer a").forEach((link) => {
                        const currentPath = window.location.pathname.replace(
                            /\/$/,
                            "",
                        );
                        const linkPath = new URL(
                            link.href,
                            window.location.origin,
                        ).pathname.replace(/\/$/, "");
                        if (currentPath === linkPath) {
                            link.classList.add("active");
                        } else {
                            link.classList.remove("active");
                        }
                    });

                    loadUserTasks(userName);
                    loadUserReward(userName);
                    loadNotifications(userName); // Load notifications on page load

                    const helpCenterBtn =
                        document.getElementById("helpCenterBtn");
                    if (helpCenterBtn) {
                        helpCenterBtn.addEventListener("click", async () => {
                            localStorage.setItem("lastHelpUser", userName);
                            const helpURL = `/BeeMazing-A1/shared/helpCenter.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;

                            // Clear notifications for this user
                            try {
                                const res = await fetch(
                                    "https://beemazing1.onrender.com/api/notifications",
                                    {
                                        method: "DELETE",
                                        headers: {
                                            "Content-Type": "application/json",
                                        },
                                        body: JSON.stringify({
                                            adminEmail,
                                            user: userName,
                                        }),
                                    },
                                );
                                const data = await res.json();
                                console.log(
                                    "Clear notifications response:",
                                    data,
                                );
                                if (!res.ok) {
                                    console.warn(
                                        "Failed to clear notifications:",
                                        data.error,
                                    );
                                }
                            } catch (err) {
                                console.error(
                                    "Error clearing notifications:",
                                    err.message,
                                );
                            }

                            window.location.href = helpURL;
                        });
                    }

                    if (addPoints > 0) {
                        setTimeout(async () => {
                            await updateUserReward(userName, addPoints);
                            triggerHoneyRain(addPoints);
                            loadUserReward(userName);
                        }, 500);
                    }
                } else {
                    document.getElementById("userTasks").innerHTML =
                        "<p>Error: Missing user or admin email. Please log in again.</p>";
                    document.getElementById("userName").textContent = "Error";
                }

                adjustContentTop();
                generateScrollableDates();
                showAdminControlsIfNeeded();
            });

            function showTab(tabId) {
                document
                    .querySelectorAll(".tab-content")
                    .forEach((tab) => tab.classList.add("hidden"));
                document.getElementById(tabId).classList.remove("hidden");
                document.querySelectorAll(".tab-button").forEach((button) => {
                    button.classList.remove("active");
                });
                const activeButton = document.querySelector(
                    `button[onclick="showTab('${tabId}')"]`,
                );
                if (activeButton) {
                    activeButton.classList.add("active");
                }

                // Load appropriate tasks based on selected tab
                const selectedDate = new Date().toLocaleDateString("sv-SE");
                if (userName) {
                    if (tabId === "myTasks") {
                        loadUserTasks(userName, selectedDate);
                    } else if (tabId === "allTasks") {
                        loadAllTasks(userName, selectedDate);
                    }
                }
            }

            // addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////

            let isLoadingUserTasks = false;
            let userName = null; // Global userName variable

            async function loadAllTasks(
                userName,
                selectedDate = new Date().toLocaleDateString("sv-SE"),
            ) {
                if (isLoadingUserTasks) {
                    console.log("🐛 loadAllTasks already running, skipping");
                    return;
                }

                isLoadingUserTasks = true;

                try {
                    const allTasksDiv = document.getElementById("allTasksList");
                    allTasksDiv.innerHTML = "<p>Loading tasks...</p>";

                    const adminEmail =
                        localStorage.getItem("currentAdminEmail");
                    let tasks = [];

                    try {
                        // Add random parameter to ensure fresh data after task completion
                        const cacheBuster = `t=${Date.now()}&r=${Math.random()}`;
                        const res = await fetch(
                            `https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&${cacheBuster}`,
                            {
                                cache: "no-store",
                                headers: {
                                    "Cache-Control":
                                        "no-cache, no-store, must-revalidate",
                                    Pragma: "no-cache",
                                    Expires: "0",
                                },
                            },
                        );
                        const data = await res.json();
                        if (!res.ok)
                            throw new Error(
                                data.error || "Failed to fetch tasks",
                            );
                        tasks = data.tasks || [];
                        console.log(
                            "🔍 loadAllTasks: Fetched fresh task data",
                            { taskCount: tasks.length, cacheBuster },
                        );
                    } catch (err) {
                        console.error(
                            "Failed to fetch tasks from server:",
                            err,
                        );
                        allTasksDiv.innerHTML =
                            "<p>Failed to load tasks. Please try again later.</p>";
                        return;
                    }

                    // Show only tasks NOT originally assigned to current user AND not private
                    const otherTasks = filterTasksForDate(
                        tasks,
                        selectedDate,
                    ).filter((task) => {
                        if (!task || !task.users || !task.title || !task.date)
                            return false;

                        if (task.users.includes(userName)) return false; // Don't show tasks assigned to current user
                        if (task.isPrivate === true) return false; // Don't show private tasks
                        return true;
                    });

                    allTasksDiv.innerHTML = "";

                    // Add informational message about all tasks
                    const infoDiv = document.createElement("div");
                    infoDiv.style.cssText =
                        "background: #2a2a3e; border: 1px solid var(--primary-color); border-radius: 8px; padding: 12px; margin-bottom: 16px; font-size: 14px; color: #fff; text-align: center;";
                    infoDiv.innerHTML = `
            <strong>🐝 All Tasks:</strong> Public tasks assigned to other members<br>
            <em style="color: var(--primary-color);">Complete any of these and get the buzz points! 🍯</em><br>
            <small style="color: #888;">Currently logged in as: ${userName || "Unknown"}</small>
        `;
                    allTasksDiv.appendChild(infoDiv);

                    if (otherTasks.length === 0) {
                        allTasksDiv.innerHTML +=
                            "<p>No other tasks available for this date.</p>";
                    } else {
                        for (const task of otherTasks) {
                            try {
                                const taskDiv = document.createElement("div");
                                taskDiv.className = "task-item";

                                const isRotation =
                                    task.settings?.includes("Rotation");
                                let turnData;

                                if (isRotation) {
                                    if (typeof mixedTurnData !== "function") {
                                        console.error(
                                            `mixedTurnData is not defined for task: ${task.title}`,
                                        );
                                        turnData = {
                                            turns: [],
                                            completedCount: 0,
                                            requiredTimes: 1,
                                        };
                                    } else {
                                        try {
                                            turnData = mixedTurnData(
                                                task,
                                                selectedDate,
                                            );
                                        } catch (error) {
                                            console.error(
                                                `Error in mixedTurnData for task ${task.title}:`,
                                                error,
                                            );
                                            turnData = {
                                                turns: [],
                                                completedCount: 0,
                                                requiredTimes: 1,
                                            };
                                        }
                                    }
                                } else {
                                    if (
                                        typeof individualTurnData !== "function"
                                    ) {
                                        console.error(
                                            `individualTurnData is not defined for task: ${task.title}`,
                                        );
                                        turnData = {
                                            turns: [],
                                            completedCount: 0,
                                            requiredTimes: 1,
                                        };
                                    } else {
                                        try {
                                            turnData = individualTurnData(
                                                task,
                                                selectedDate,
                                            );
                                        } catch (error) {
                                            console.error(
                                                `Error in individualTurnData for task ${task.title}:`,
                                                error,
                                            );
                                            turnData = {
                                                turns: [],
                                                completedCount: 0,
                                                requiredTimes: 1,
                                            };
                                        }
                                    }
                                }

                                let taskHTML = `<strong>${task.title}</strong><br>`;
                                taskHTML += `<em style="color: #666;">Originally assigned to: ${task.users.join(", ")}</em><br>`;

                                if (isRotation) {
                                    // Check if all required turns are completed for today
                                    const totalCompletionsToday =
                                        turnData.completedCount;
                                    const totalRequiredCompletions =
                                        turnData.requiredTimes;

                                    if (
                                        totalCompletionsToday >=
                                        totalRequiredCompletions
                                    ) {
                                        taskHTML += `<span style="color: green;">Turn: All done!</span><br>`;
                                    } else {
                                        const activeTurn = turnData.turns.find(
                                            (turn) =>
                                                !turn.isCompleted &&
                                                !turn.isPending,
                                        );
                                        if (activeTurn) {
                                            const nextTurnIndex =
                                                (activeTurn.index + 1) %
                                                task.users.length;
                                            const nextUser =
                                                turnData.turns.find(
                                                    (t) =>
                                                        t.index ===
                                                        nextTurnIndex,
                                                )?.user ||
                                                task.users[nextTurnIndex] ||
                                                "—";
                                            taskHTML += `Current Turn: ${activeTurn.user}<br>Next: ${nextUser}<br>`;
                                        } else {
                                            taskHTML += `<span style="color: orange;">Turn: Pending review</span><br>`;
                                        }
                                    }
                                }

                                taskHTML += `Buzz Points: ${task.reward || 0} 🍯 (goes to completer)<br>`;

                                // Add due times if available
                                if (task.dueTimes && task.dueTimes.length > 0) {
                                    const dueTimeStr = task.dueTimes.join(", ");
                                    taskHTML += `<span style="color: #6d4c41; font-size: 15px; display: inline-flex; align-items: center; gap: 4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#6d4c41" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12,6 12,12 16,14"></polyline></svg>Due: ${dueTimeStr}</span><br>`;
                                }

                                // Check if task is completed by current user and show completion time
                                console.log(
                                    "🔍 [All Tasks] Checking completion time for task:",
                                    {
                                        taskTitle: task.title,
                                        selectedDate,
                                        userName,
                                        hasCompletedDates:
                                            !!task.completedDates,
                                        hasCompletions: !!task.completions,
                                        completedDatesForDate:
                                            task.completedDates?.[selectedDate],
                                        completionsForDate:
                                            task.completions?.[selectedDate],
                                    },
                                );

                                // First check completedDates (new format with timestamps)
                                if (
                                    task.completedDates &&
                                    task.completedDates[selectedDate]
                                ) {
                                    const userCompletions = task.completedDates[
                                        selectedDate
                                    ].filter((c) => c.user === userName);
                                    console.log(
                                        "🔍 [All Tasks] Found completedDates entries for user:",
                                        userCompletions,
                                    );
                                    if (userCompletions.length > 0) {
                                        const latestCompletion =
                                            userCompletions[
                                                userCompletions.length - 1
                                            ];
                                        if (latestCompletion.completedAt) {
                                            const completedTime = new Date(
                                                latestCompletion.completedAt,
                                            );
                                            const timeStr =
                                                completedTime.toLocaleTimeString(
                                                    "en-US",
                                                    {
                                                        hour: "2-digit",
                                                        minute: "2-digit",
                                                        hour12: true,
                                                    },
                                                );
                                            taskHTML += `<span style="color: #28a745; font-size: 15px; display: inline-flex; align-items: center; gap: 4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#28a745" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 12l2 2 4-4"></path><circle cx="12" cy="12" r="10"></circle></svg>Completed at ${timeStr}</span><br>`;
                                            console.log(
                                                "🔍 [All Tasks] Set completion time from completedDates:",
                                                timeStr,
                                            );
                                        }
                                    }
                                }
                                // Fallback to old completions format (may not have timestamps)
                                else if (
                                    task.completions &&
                                    task.completions[selectedDate]
                                ) {
                                    const userCompletions = task.completions[
                                        selectedDate
                                    ].filter(
                                        (c) =>
                                            c.user === userName &&
                                            (c.isCompleted || !c.isPending),
                                    );
                                    console.log(
                                        "🔍 [All Tasks] Found completions entries for user:",
                                        userCompletions,
                                    );
                                    if (userCompletions.length > 0) {
                                        const latestCompletion =
                                            userCompletions[
                                                userCompletions.length - 1
                                            ];
                                        if (latestCompletion.completedAt) {
                                            const completedTime = new Date(
                                                latestCompletion.completedAt,
                                            );
                                            const timeStr =
                                                completedTime.toLocaleTimeString(
                                                    "en-US",
                                                    {
                                                        hour: "2-digit",
                                                        minute: "2-digit",
                                                        hour12: true,
                                                    },
                                                );
                                            taskHTML += `<span style="color: #28a745; font-size: 15px; display: inline-flex; align-items: center; gap: 4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#28a745" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 12l2 2 4-4"></path><circle cx="12" cy="12" r="10"></circle></svg>Completed at ${timeStr}</span><br>`;
                                            console.log(
                                                "🔍 [All Tasks] Set completion time from completions:",
                                                timeStr,
                                            );
                                        } else {
                                            console.log(
                                                "🔍 [All Tasks] Completion found but no timestamp available",
                                            );
                                        }
                                    }
                                }

                                // Show total progress for other users' tasks
                                // Use the global completedCount which includes all completions + pending
                                const totalCompletionsToday =
                                    turnData.completedCount;
                                const totalRequired = isRotation
                                    ? turnData.requiredTimes
                                    : turnData.requiredTimes *
                                      task.users.length;
                                taskHTML += `Total Progress: ${totalCompletionsToday}/${totalRequired}<br>`;

                                taskDiv.innerHTML = taskHTML;

                                const todayStr = new Date().toLocaleDateString(
                                    "sv-SE",
                                );
                                const isToday = selectedDate === todayStr;

                                let canFinish = false;
                                if (isToday) {
                                    // Private tasks can only be completed by assigned users
                                    if (
                                        task.isPrivate === true &&
                                        !task.users.includes(userName)
                                    ) {
                                        canFinish = false;
                                    } else {
                                        if (isRotation) {
                                            // For rotation tasks in All Tasks, check if there are incomplete turns
                                            // Use the global completedCount which includes all completions + pending
                                            const totalCompletionsToday =
                                                turnData.completedCount;
                                            const totalRequiredCompletions =
                                                turnData.requiredTimes;

                                            // Task can be completed if not all required completions are done
                                            canFinish =
                                                totalCompletionsToday <
                                                totalRequiredCompletions;

                                            console.log(
                                                "🔍 loadAllTasks: Rotation task button visibility check",
                                                {
                                                    taskTitle: task.title,
                                                    totalCompletionsToday,
                                                    totalRequiredCompletions,
                                                    canFinish,
                                                    isToday,
                                                    isPrivate: task.isPrivate,
                                                    currentUser: userName,
                                                },
                                            );
                                        } else {
                                            // For individual tasks in All Tasks, check total completions across all users
                                            // Use the global completedCount which includes all completions + pending
                                            const totalCompletionsToday =
                                                turnData.completedCount;

                                            // Calculate total required completions for all assigned users
                                            const allAssignedUsers =
                                                task.users || [];
                                            const totalRequiredCompletions =
                                                allAssignedUsers.length *
                                                turnData.requiredTimes;

                                            // Task can be completed if not all required completions are done
                                            canFinish =
                                                totalCompletionsToday <
                                                totalRequiredCompletions;

                                            console.log(
                                                "🔍 loadAllTasks: Individual task button visibility check",
                                                {
                                                    taskTitle: task.title,
                                                    totalCompletionsToday,
                                                    totalRequiredCompletions,
                                                    allAssignedUsers,
                                                    requiredTimes:
                                                        turnData.requiredTimes,
                                                    canFinish,
                                                    completedCount:
                                                        turnData.completedCount,
                                                    isToday,
                                                    isPrivate: task.isPrivate,
                                                    currentUser: userName,
                                                },
                                            );
                                        }
                                    }
                                }

                                if (canFinish) {
                                    const finishBtn =
                                        document.createElement("button");
                                    finishBtn.className = "finished-btn";
                                    finishBtn.textContent = `Complete Task (as ${userName})`;
                                    finishBtn.addEventListener("click", (e) => {
                                        e.stopPropagation();
                                        if (!userName) {
                                            alert(
                                                "Error: User not identified. Please refresh the page.",
                                            );
                                            return;
                                        }
                                        finishTask(
                                            userName,
                                            task,
                                            selectedDate,
                                        );
                                    });
                                    taskDiv.appendChild(finishBtn);
                                }

                                taskDiv.addEventListener("click", () =>
                                    showTaskDetails(task, selectedDate),
                                );
                                allTasksDiv.appendChild(taskDiv);
                            } catch (error) {
                                console.error(
                                    `🔥 Error processing task ${task.title}:`,
                                    error,
                                );
                            }
                        }
                    }

                    // Load As Needed tasks not assigned to current user
                    try {
                        await loadAsNeededTasks(
                            userName,
                            selectedDate,
                            allTasksDiv,
                            false,
                        ); // false = only non-assigned tasks
                    } catch (error) {
                        console.error(
                            "🔥 Error loading As Needed tasks:",
                            error,
                        );
                    }
                } finally {
                    isLoadingUserTasks = false;
                }
            }

            async function loadUserTasks(
                userName,
                selectedDate = new Date().toLocaleDateString("sv-SE"),
            ) {
                if (isLoadingUserTasks) {
                    console.log("🐛 loadUserTasks already running, skipping");
                    return;
                }

                isLoadingUserTasks = true;

                try {
                    const userTasksDiv = document.getElementById("userTasks");
                    userTasksDiv.innerHTML = "<p>Loading tasks...</p>";

                    const adminEmail =
                        localStorage.getItem("currentAdminEmail");
                    let tasks = [];

                    try {
                        // Add random parameter to ensure fresh data after task completion
                        const cacheBuster = `t=${Date.now()}&r=${Math.random()}`;
                        const res = await fetch(
                            `https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&${cacheBuster}`,
                            {
                                cache: "no-store",
                                headers: {
                                    "Cache-Control":
                                        "no-cache, no-store, must-revalidate",
                                    Pragma: "no-cache",
                                    Expires: "0",
                                },
                            },
                        );
                        const data = await res.json();
                        if (!res.ok)
                            throw new Error(
                                data.error || "Failed to fetch tasks",
                            );
                        tasks = data.tasks || [];
                        console.log(
                            "🔍 loadUserTasks: Fetched fresh task data",
                            { taskCount: tasks.length, cacheBuster },
                        );

                        console.log(
                            "loadUserTasks tasks:",
                            tasks.map((t) => ({
                                title: t.title,
                                date: t.date,
                                daysOfWeek: t.daysOfWeek,
                                specificDays: t.specificDays,
                                users: t.users,
                            })),
                        );
                    } catch (err) {
                        console.error(
                            "Failed to fetch tasks from server:",
                            err,
                        );
                        userTasksDiv.innerHTML =
                            "<p>Failed to load tasks. Please try again later.</p>";
                        return;
                    }

                    const userTasks = filterTasksForDate(
                        tasks,
                        selectedDate,
                    ).filter((task) => {
                        if (!task || !task.users || !task.title || !task.date)
                            return false;
                        return task.users.includes(userName); // Show only tasks assigned to current user
                    });

                    // Sort tasks: incomplete → pending approval → approved
                    userTasks.sort((a, b) => {
                        const getTaskStatus = (task) => {
                            const isRotation =
                                task.settings?.includes("Rotation");
                            let turnData;

                            if (isRotation) {
                                turnData =
                                    typeof mixedTurnData === "function"
                                        ? mixedTurnData(task, selectedDate)
                                        : {
                                              turns: [],
                                              completedCount: 0,
                                              requiredTimes: 1,
                                          };
                            } else {
                                turnData =
                                    typeof individualTurnData === "function"
                                        ? individualTurnData(task, selectedDate)
                                        : {
                                              turns: [],
                                              completedCount: 0,
                                              requiredTimes: 1,
                                          };
                            }

                            const totalRequiredCompletions = isRotation
                                ? turnData.requiredTimes
                                : turnData.requiredTimes * task.users.length;

                            const todayStr = new Date().toLocaleDateString(
                                "sv-SE",
                            );
                            const isToday = selectedDate === todayStr;

                            let canFinish = false;
                            if (isToday) {
                                if (
                                    task.isPrivate === true &&
                                    !task.users.includes(userName)
                                ) {
                                    canFinish = false;
                                } else {
                                    canFinish =
                                        turnData.completedCount <
                                        totalRequiredCompletions;
                                }
                            }

                            if (canFinish) return "incomplete";

                            const hasSubmissions = turnData.completedCount > 0;
                            if (!hasSubmissions) return "incomplete";

                            if (task.parentApproval === true) {
                                const isFullyCompleted =
                                    turnData.completedCount >=
                                    totalRequiredCompletions;
                                return isFullyCompleted
                                    ? "approved"
                                    : "pending";
                            } else {
                                return "approved";
                            }
                        };

                        const getTaskPriority = (task, status) => {
                            if (status === "incomplete") {
                                // Parse due times for sorting
                                if (task.dueTimes && task.dueTimes.length > 0) {
                                    const now = new Date();
                                    const currentTime =
                                        now.getHours() * 60 + now.getMinutes();

                                    let earliestDueTime = Infinity;
                                    let hasOverdue = false;

                                    task.dueTimes.forEach((timeStr) => {
                                        const [hours, minutes] = timeStr
                                            .split(":")
                                            .map(Number);
                                        const dueTime = hours * 60 + minutes;

                                        if (dueTime < currentTime) {
                                            hasOverdue = true;
                                        }

                                        if (dueTime < earliestDueTime) {
                                            earliestDueTime = dueTime;
                                        }
                                    });

                                    if (hasOverdue) return 0; // Overdue tasks at very top
                                    return earliestDueTime;
                                } else {
                                    return 10000; // Tasks without due time go after all timed tasks
                                }
                            }
                            return 0;
                        };

                        const statusA = getTaskStatus(a);
                        const statusB = getTaskStatus(b);

                        // Primary sort by status
                        const statusOrder = {
                            incomplete: 1,
                            pending: 2,
                            approved: 3,
                        };
                        if (statusOrder[statusA] !== statusOrder[statusB]) {
                            return statusOrder[statusA] - statusOrder[statusB];
                        }

                        // Secondary sort by priority within status
                        const priorityA = getTaskPriority(a, statusA);
                        const priorityB = getTaskPriority(b, statusB);

                        return priorityA - priorityB;
                    });

                    userTasksDiv.innerHTML = "";

                    if (userTasks.length === 0) {
                        userTasksDiv.innerHTML +=
                            "<p>No tasks assigned to you for this date.</p>";
                    } else {
                        for (const task of userTasks) {
                            try {
                                const taskDiv = document.createElement("div");
                                taskDiv.className = "task-item";

                                const isRotation =
                                    task.settings?.includes("Rotation");
                                let turnData;

                                if (isRotation) {
                                    if (typeof mixedTurnData !== "function") {
                                        console.error(
                                            `mixedTurnData is not defined for task: ${task.title}`,
                                        );
                                        turnData = {
                                            turns: [],
                                            completedCount: 0,
                                            requiredTimes: 1,
                                        };
                                    } else {
                                        try {
                                            turnData = mixedTurnData(
                                                task,
                                                selectedDate,
                                            );
                                        } catch (error) {
                                            console.error(
                                                `Error in mixedTurnData for task ${task.title}:`,
                                                error,
                                            );
                                            turnData = {
                                                turns: [],
                                                completedCount: 0,
                                                requiredTimes: 1,
                                            };
                                        }
                                    }
                                } else {
                                    if (
                                        typeof individualTurnData !== "function"
                                    ) {
                                        console.error(
                                            `individualTurnData is not defined for task: ${task.title}`,
                                        );
                                        turnData = {
                                            turns: [],
                                            completedCount: 0,
                                            requiredTimes: 1,
                                        };
                                    } else {
                                        try {
                                            turnData = individualTurnData(
                                                task,
                                                selectedDate,
                                            );
                                        } catch (error) {
                                            console.error(
                                                `Error in individualTurnData for task ${task.title}:`,
                                                error,
                                            );
                                            turnData = {
                                                turns: [],
                                                completedCount: 0,
                                                requiredTimes: 1,
                                            };
                                        }
                                    }
                                }

                                const userTurns = turnData.turns.filter(
                                    (turn) => turn.user === userName,
                                );
                                const userTotal = userTurns.reduce(
                                    (sum, turn) =>
                                        sum +
                                        (turn.isCompleted || turn.isPending
                                            ? 1
                                            : 0),
                                    0,
                                );
                                const userRequiredTimes = isRotation
                                    ? userTurns.length
                                    : turnData.requiredTimes;
                                const isCompleted =
                                    userTotal >= userRequiredTimes;

                                // Create main container with flexbox layout
                                taskDiv.style.cssText =
                                    "display: flex !important; justify-content: space-between; align-items: center; padding: 8px 15px !important; min-height: 56px; background-color: #FFFFFF; color: #6D4C41; border: 2px solid var(--primary-color); border-radius: 12px; margin-bottom: 12px; cursor: pointer; transition: transform 0.3s ease, box-shadow 0.3s ease; box-shadow: 0 2px 8px rgba(255, 193, 7, 0.1);";

                                // Create left content container
                                const leftContent =
                                    document.createElement("div");
                                leftContent.style.cssText =
                                    "flex: 1; display: flex; flex-direction: column; justify-content: center; padding: 2px 0; gap: 2px;";

                                // Build the left content HTML - separate divs for better spacing
                                let leftHTML = `<div style="line-height: 1.2; text-align: center;"><strong style="font-size: 16px;">${task.title}`;
                                if (task.isPrivate === true) {
                                    leftHTML += ` <span style="color: #ff6b6b; font-size: 13px;">🔒 Private</span>`;
                                }
                                leftHTML += `</strong></div>`;

                                // Second line with reward, due time, and completion time
                                let secondLine = "";
                                if (task.reward && task.reward > 0) {
                                    secondLine += `<span style="color: var(--primary-color); font-weight: 600; font-size: 15px;">${task.reward} 🍯</span>`;
                                }

                                // Check if task is completed and show completion time
                                let completionTimeStr = "";

                                console.log(
                                    "🔍 Checking completion time for task:",
                                    {
                                        taskTitle: task.title,
                                        selectedDate,
                                        userName,
                                        hasCompletedDates:
                                            !!task.completedDates,
                                        hasCompletions: !!task.completions,
                                        completedDatesForDate:
                                            task.completedDates?.[selectedDate],
                                        completionsForDate:
                                            task.completions?.[selectedDate],
                                    },
                                );

                                // First check completedDates (new format with timestamps)
                                if (
                                    task.completedDates &&
                                    task.completedDates[selectedDate]
                                ) {
                                    const userCompletions = task.completedDates[
                                        selectedDate
                                    ].filter((c) => c.user === userName);
                                    console.log(
                                        "🔍 Found completedDates entries for user:",
                                        userCompletions,
                                    );
                                    if (userCompletions.length > 0) {
                                        const latestCompletion =
                                            userCompletions[
                                                userCompletions.length - 1
                                            ];
                                        if (latestCompletion.completedAt) {
                                            const completedTime = new Date(
                                                latestCompletion.completedAt,
                                            );
                                            const timeStr =
                                                completedTime.toLocaleTimeString(
                                                    "en-US",
                                                    {
                                                        hour: "2-digit",
                                                        minute: "2-digit",
                                                        hour12: true,
                                                    },
                                                );
                                            completionTimeStr = `<span style="color: #28a745; font-size: 15px; display: flex; align-items: center; gap: 4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#28a745" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 12l2 2 4-4"></path><circle cx="12" cy="12" r="10"></circle></svg>Completed at ${timeStr}</span>`;
                                            console.log(
                                                "🔍 Set completion time from completedDates:",
                                                timeStr,
                                            );
                                        }
                                    }
                                }
                                // Fallback to old completions format (may not have timestamps)
                                else if (
                                    task.completions &&
                                    task.completions[selectedDate]
                                ) {
                                    const userCompletions = task.completions[
                                        selectedDate
                                    ].filter(
                                        (c) =>
                                            c.user === userName &&
                                            (c.isCompleted || !c.isPending),
                                    );
                                    console.log(
                                        "🔍 Found completions entries for user:",
                                        userCompletions,
                                    );
                                    if (userCompletions.length > 0) {
                                        const latestCompletion =
                                            userCompletions[
                                                userCompletions.length - 1
                                            ];
                                        if (latestCompletion.completedAt) {
                                            const completedTime = new Date(
                                                latestCompletion.completedAt,
                                            );
                                            const timeStr =
                                                completedTime.toLocaleTimeString(
                                                    "en-US",
                                                    {
                                                        hour: "2-digit",
                                                        minute: "2-digit",
                                                        hour12: true,
                                                    },
                                                );
                                            completionTimeStr = `<span style="color: #28a745; font-size: 15px; display: flex; align-items: center; gap: 4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#28a745" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 12l2 2 4-4"></path><circle cx="12" cy="12" r="10"></circle></svg>Completed at ${timeStr}</span>`;
                                            console.log(
                                                "🔍 Set completion time from completions:",
                                                timeStr,
                                            );
                                        } else {
                                            console.log(
                                                "🔍 Completion found but no timestamp available",
                                            );
                                        }
                                    }
                                }

                                if (task.dueTimes && task.dueTimes.length > 0) {
                                    const dueTimeStr = task.dueTimes.join(", ");
                                    if (secondLine)
                                        secondLine += `<span style="margin: 0 20px; color: #ccc;">|</span>`;
                                    secondLine += `<span style="color: #6d4c41; font-size: 15px; display: flex; align-items: center; gap: 4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#6d4c41" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12,6 12,12 16,14"></polyline></svg>${dueTimeStr}</span>`;
                                }

                                // Add completion time if task is completed
                                if (completionTimeStr) {
                                    if (secondLine)
                                        secondLine += `<span style="margin: 0 20px; color: #ccc;">|</span>`;
                                    secondLine += completionTimeStr;
                                }
                                if (secondLine) {
                                    leftHTML += `<div style="line-height: 1.2; text-align: center; display: flex; align-items: center; justify-content: center;">${secondLine}</div>`;
                                }

                                leftContent.innerHTML = leftHTML;
                                taskDiv.appendChild(leftContent);

                                // Debug task completion status
                                console.log(
                                    "🔍 Task completion status debug:",
                                    {
                                        taskTitle: task.title,
                                        userName,
                                        selectedDate,
                                        parentApproval: task.parentApproval,
                                        isRotation,
                                        turnDataCompletedCount:
                                            turnData.completedCount,
                                        turnDataRequiredTimes:
                                            turnData.requiredTimes,
                                    },
                                );

                                // Create button container for centering
                                const buttonContainer =
                                    document.createElement("div");
                                buttonContainer.style.cssText =
                                    "display: flex; align-items: center; justify-content: center;";

                                const todayStr = new Date().toLocaleDateString(
                                    "sv-SE",
                                );
                                const isToday = selectedDate === todayStr;

                                let canFinish = false;
                                if (isToday) {
                                    // Private tasks can only be completed by assigned users
                                    if (
                                        task.isPrivate === true &&
                                        !task.users.includes(userName)
                                    ) {
                                        canFinish = false;
                                    } else {
                                        if (isRotation) {
                                            // For rotation tasks, check if all required completions are done
                                            const totalCompletionsToday =
                                                turnData.completedCount;
                                            const totalRequiredCompletions =
                                                turnData.requiredTimes;
                                            canFinish =
                                                totalCompletionsToday <
                                                totalRequiredCompletions;

                                            console.log(
                                                "🔍 loadUserTasks: Rotation task button visibility check",
                                                {
                                                    taskTitle: task.title,
                                                    totalCompletionsToday,
                                                    totalRequiredCompletions,
                                                    canFinish,
                                                    isToday,
                                                    currentUser: userName,
                                                },
                                            );
                                        } else {
                                            // For individual tasks, check total completions across all users (including cross-completions)
                                            const totalCompletionsToday =
                                                turnData.completedCount;
                                            const allAssignedUsers =
                                                task.users || [];
                                            const totalRequiredCompletions =
                                                allAssignedUsers.length *
                                                turnData.requiredTimes;
                                            canFinish =
                                                totalCompletionsToday <
                                                totalRequiredCompletions;

                                            console.log(
                                                "🔍 loadUserTasks: Individual task button visibility check",
                                                {
                                                    taskTitle: task.title,
                                                    totalCompletionsToday,
                                                    totalRequiredCompletions,
                                                    allAssignedUsers,
                                                    requiredTimes:
                                                        turnData.requiredTimes,
                                                    canFinish,
                                                    completedCount:
                                                        turnData.completedCount,
                                                    isToday,
                                                    currentUser: userName,
                                                },
                                            );
                                        }
                                    }
                                }

                                if (canFinish) {
                                    const finishBtn =
                                        document.createElement("button");
                                    finishBtn.className = "finished-btn";
                                    finishBtn.innerHTML = `Done`;
                                    finishBtn.style.cssText =
                                        "background: var(--primary-color); color: #6D4C41; border: none; padding: 6px 12px; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 16px; height: 40px; min-width: 60px; display: flex; align-items: center; justify-content: center;";
                                    finishBtn.addEventListener("click", (e) => {
                                        e.stopPropagation();
                                        if (!userName) {
                                            alert(
                                                "Error: User not identified. Please refresh the page.",
                                            );
                                            return;
                                        }

                                        // Replace button with celebration animation
                                        const celebrationDiv =
                                            document.createElement("div");
                                        celebrationDiv.style.cssText =
                                            "display: flex; align-items: center; justify-content: center; height: 40px; min-width: 60px; font-size: 20px; animation: celebrationPulse 1.5s ease-in-out;";
                                        celebrationDiv.innerHTML = "🎉✨";

                                        // Replace button with celebration
                                        finishBtn.replaceWith(celebrationDiv);

                                        // Remove celebration after animation
                                        setTimeout(() => {
                                            celebrationDiv.style.opacity = "0";
                                            celebrationDiv.style.transition =
                                                "opacity 0.5s ease-out";
                                            setTimeout(() => {
                                                celebrationDiv.remove();
                                            }, 500);
                                        }, 1500);

                                        finishTask(
                                            userName,
                                            task,
                                            selectedDate,
                                        );
                                    });
                                    finishBtn.addEventListener(
                                        "mouseenter",
                                        () => {
                                            finishBtn.style.background =
                                                "#FFB300";
                                        },
                                    );
                                    finishBtn.addEventListener(
                                        "mouseleave",
                                        () => {
                                            finishBtn.style.background =
                                                "var(--primary-color)";
                                        },
                                    );
                                    buttonContainer.appendChild(finishBtn);
                                } else {
                                    // Check if task is fully approved vs pending
                                    const pendingUsers = [];
                                    const approvedUsers = [];

                                    // Debug task properties for approval analysis
                                    console.log(
                                        "🔍 Frontend task data debug:",
                                        {
                                            taskTitle: task.title,
                                            parentApproval: task.parentApproval,
                                            parentApprovalType:
                                                typeof task.parentApproval,
                                            allTaskKeys: Object.keys(task),
                                            taskObject: task,
                                        },
                                    );

                                    // Check if task requires approval to determine interpretation
                                    if (task.parentApproval === true) {
                                        // For tasks requiring approval: check isPending flag to determine actual status
                                        if (isRotation) {
                                            turnData.turns.forEach((turn) => {
                                                if (turn.isPending) {
                                                    // Still pending approval
                                                    if (
                                                        !pendingUsers.includes(
                                                            turn.user,
                                                        )
                                                    ) {
                                                        pendingUsers.push(
                                                            turn.user,
                                                        );
                                                    }
                                                } else if (turn.isCompleted) {
                                                    // Actually approved (isPending: false)
                                                    if (
                                                        !approvedUsers.includes(
                                                            turn.user,
                                                        )
                                                    ) {
                                                        approvedUsers.push(
                                                            turn.user,
                                                        );
                                                    }
                                                }
                                            });
                                        } else {
                                            const userPendingCounts = {};
                                            const userApprovedCounts = {};
                                            turnData.turns.forEach((turn) => {
                                                if (turn.isPending) {
                                                    // Still pending approval
                                                    userPendingCounts[
                                                        turn.user
                                                    ] =
                                                        (userPendingCounts[
                                                            turn.user
                                                        ] || 0) + 1;
                                                } else if (turn.isCompleted) {
                                                    // Actually approved (isPending: false)
                                                    userApprovedCounts[
                                                        turn.user
                                                    ] =
                                                        (userApprovedCounts[
                                                            turn.user
                                                        ] || 0) + 1;
                                                }
                                            });

                                            // Check pending users
                                            Object.entries(
                                                userPendingCounts,
                                            ).forEach(([user, count]) => {
                                                if (
                                                    count >=
                                                    turnData.requiredTimes
                                                ) {
                                                    pendingUsers.push(user);
                                                }
                                            });

                                            // Check approved users
                                            Object.entries(
                                                userApprovedCounts,
                                            ).forEach(([user, count]) => {
                                                if (
                                                    count >=
                                                    turnData.requiredTimes
                                                ) {
                                                    approvedUsers.push(user);
                                                }
                                            });
                                        }
                                    } else {
                                        // For tasks NOT requiring approval: isCompleted = actually approved
                                        if (isRotation) {
                                            turnData.turns.forEach((turn) => {
                                                if (
                                                    turn.isCompleted &&
                                                    !approvedUsers.includes(
                                                        turn.user,
                                                    )
                                                ) {
                                                    approvedUsers.push(
                                                        turn.user,
                                                    );
                                                }
                                            });
                                        } else {
                                            const userCompletedCounts = {};
                                            turnData.turns.forEach((turn) => {
                                                if (turn.isCompleted) {
                                                    userCompletedCounts[
                                                        turn.user
                                                    ] =
                                                        (userCompletedCounts[
                                                            turn.user
                                                        ] || 0) + 1;
                                                }
                                            });
                                            Object.entries(
                                                userCompletedCounts,
                                            ).forEach(([user, count]) => {
                                                if (
                                                    count >=
                                                    turnData.requiredTimes
                                                ) {
                                                    approvedUsers.push(user);
                                                }
                                            });
                                        }
                                    }

                                    // Debug logging for task status
                                    console.log("🔍 Task status debug:", {
                                        taskTitle: task.title,
                                        parentApproval: task.parentApproval,
                                        pendingUsers,
                                        approvedUsers,
                                        completedCount: turnData.completedCount,
                                        requiredTimes: turnData.requiredTimes,
                                        isRotation,
                                        selectedDate,
                                        rawTurns: turnData.turns.map((t) => ({
                                            user: t.user,
                                            isPending: t.isPending,
                                            isCompleted: t.isCompleted,
                                        })),
                                    });

                                    // Enhanced debug for approval status
                                    if (task.parentApproval === true) {
                                        console.log(
                                            "🔍 Approval task detailed analysis:",
                                            {
                                                taskTitle: task.title,
                                                pendingUsers: pendingUsers,
                                                approvedUsers: approvedUsers,
                                                turnsWithFlags:
                                                    turnData.turns.map((t) => ({
                                                        user: t.user,
                                                        isPending: t.isPending,
                                                        isCompleted:
                                                            t.isCompleted,
                                                        status: t.isPending
                                                            ? "PENDING"
                                                            : t.isCompleted
                                                              ? "APPROVED"
                                                              : "INCOMPLETE",
                                                    })),
                                            },
                                        );
                                    }

                                    // Show green checkmark based on parentApproval setting:
                                    let showGreenCheckmark = false;

                                    // NEVER show single green checkmark for any tasks
                                    // Always show avatar + checkmark combination
                                    showGreenCheckmark = false;

                                    console.log(
                                        "🔍 Green checkmark decision:",
                                        {
                                            showGreenCheckmark,
                                            parentApproval: task.parentApproval,
                                            hasApproved:
                                                approvedUsers.length > 0,
                                            hasPending: pendingUsers.length > 0,
                                            completedCount:
                                                turnData.completedCount,
                                            totalRequired: isRotation
                                                ? turnData.requiredTimes
                                                : turnData.requiredTimes *
                                                  task.users.length,
                                            meetsRequirements:
                                                turnData.completedCount >=
                                                (isRotation
                                                    ? turnData.requiredTimes
                                                    : turnData.requiredTimes *
                                                      task.users.length),
                                        },
                                    );

                                    if (showGreenCheckmark) {
                                        const checkmarkDiv =
                                            document.createElement("div");
                                        checkmarkDiv.innerHTML = "✓";
                                        checkmarkDiv.title = `Approved! Completed by ${approvedUsers.join(", ")}`;
                                        checkmarkDiv.style.cssText =
                                            "width: 40px; height: 40px; border-radius: 50%; background: #28a745; color: white; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; border: 2px solid #1e7e34;";
                                        buttonContainer.appendChild(
                                            checkmarkDiv,
                                        );
                                    } else if (
                                        pendingUsers.length > 0 ||
                                        approvedUsers.length > 0
                                    ) {
                                        // Show avatars for pending/approved completion
                                        const avatarContainer =
                                            document.createElement("div");
                                        avatarContainer.style.cssText =
                                            "display: flex; align-items: center; justify-content: center; gap: 4px; flex-wrap: wrap; max-width: 60px;";

                                        // For approval tasks, determine if approved based on actual approval status
                                        let actuallyApprovedUsers = [];
                                        let actuallyPendingUsers = [];

                                        if (task.parentApproval === true) {
                                            // For tasks requiring approval, pending users stay pending until actually approved
                                            // Only show as approved if they're in the approvedUsers array (meaning parent approved)
                                            actuallyApprovedUsers = [
                                                ...approvedUsers,
                                            ];
                                            actuallyPendingUsers = [
                                                ...pendingUsers,
                                            ];
                                            console.log(
                                                "🔍 Approval task status decision:",
                                                {
                                                    taskTitle: task.title,
                                                    parentApproval:
                                                        task.parentApproval,
                                                    originalPendingUsers:
                                                        pendingUsers,
                                                    originalApprovedUsers:
                                                        approvedUsers,
                                                    actuallyPendingUsers,
                                                    actuallyApprovedUsers,
                                                },
                                            );
                                        } else {
                                            // For tasks NOT requiring approval, completed = approved
                                            actuallyApprovedUsers = [
                                                ...approvedUsers,
                                            ];
                                            actuallyPendingUsers = [
                                                ...pendingUsers,
                                            ];
                                        }

                                        const allUsers = [
                                            ...actuallyPendingUsers,
                                            ...actuallyApprovedUsers,
                                        ];

                                        // Use existing avatar system to create avatars with checkmarks
                                        allUsers.slice(0, 3).forEach((user) => {
                                            if (window.avatarSystem) {
                                                const isPending =
                                                    actuallyPendingUsers.includes(
                                                        user,
                                                    );
                                                const avatarHTML =
                                                    window.avatarSystem.generateAvatarHTML(
                                                        user,
                                                        24,
                                                        "task-completed-avatar",
                                                        "margin-right: 0; cursor: pointer;",
                                                    );

                                                const userWrapper =
                                                    document.createElement(
                                                        "div",
                                                    );
                                                userWrapper.style.cssText =
                                                    "display: flex; align-items: center; gap: 4px;";
                                                userWrapper.innerHTML =
                                                    avatarHTML;

                                                // Add checkmark next to avatar
                                                const checkmark =
                                                    document.createElement(
                                                        "div",
                                                    );
                                                checkmark.innerHTML = "✓";
                                                checkmark.style.cssText =
                                                    isPending
                                                        ? "width: 28px; height: 28px; border-radius: 50%; background: #FFC107; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; border: 2px solid white;"
                                                        : "width: 28px; height: 28px; border-radius: 50%; background: #28a745; color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; border: 2px solid white;";

                                                userWrapper.appendChild(
                                                    checkmark,
                                                );
                                                userWrapper.title = isPending
                                                    ? `Pending approval by ${user}`
                                                    : `Approved - completed by ${user}`;
                                                avatarContainer.appendChild(
                                                    userWrapper,
                                                );
                                            }
                                        });

                                        // Show count if more than 3 users
                                        if (allUsers.length > 3) {
                                            const moreDiv =
                                                document.createElement("div");
                                            moreDiv.textContent = `+${allUsers.length - 3}`;
                                            moreDiv.title = `${allUsers.length} users involved`;
                                            moreDiv.style.cssText =
                                                "width: 24px; height: 24px; border-radius: 50%; border: 2px solid #666; background: #666; color: white; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; margin-right: 0;";
                                            avatarContainer.appendChild(
                                                moreDiv,
                                            );
                                        }

                                        buttonContainer.appendChild(
                                            avatarContainer,
                                        );
                                    }
                                }

                                taskDiv.appendChild(buttonContainer);

                                taskDiv.addEventListener("click", () =>
                                    showTaskDetails(task, selectedDate),
                                );
                                userTasksDiv.appendChild(taskDiv);
                            } catch (error) {
                                console.error(
                                    `🔥 Error processing regular task ${task.title}:`,
                                    error,
                                );
                                // Continue with next task instead of breaking the entire loop
                            }
                        }
                    }

                    // Load As Needed tasks and add them to the main task list
                    console.log("🐛 ABOUT TO CALL loadAsNeededTasks with:", {
                        userName,
                        selectedDate,
                    });
                    try {
                        await loadAsNeededTasks(
                            userName,
                            selectedDate,
                            userTasksDiv,
                            true,
                        ); // true = only assigned to user
                    } catch (error) {
                        console.error(
                            "🔥 Error loading As Needed tasks:",
                            error,
                        );
                    }
                } finally {
                    isLoadingUserTasks = false;
                }
            }

            let isLoadingAsNeeded = false;
            let asNeededCallCounter = 0;

            async function loadAsNeededTasks(
                userName,
                selectedDate,
                userTasksDiv,
                onlyAssigned = false,
            ) {
                asNeededCallCounter++;
                console.log(
                    "🐛 loadAsNeededTasks call #" +
                        asNeededCallCounter +
                        " for:",
                    userName,
                );

                if (isLoadingAsNeeded) {
                    console.log(
                        "🐛 loadAsNeededTasks already running, skipping call #" +
                            asNeededCallCounter,
                    );
                    return;
                }

                isLoadingAsNeeded = true;
                console.log(
                    "🐛 loadAsNeededTasks executing call #" +
                        asNeededCallCounter,
                );

                const adminEmail = localStorage.getItem("currentAdminEmail");

                try {
                    const res = await fetch(
                        `https://beemazing1.onrender.com/api/tasks?adminEmail=${encodeURIComponent(adminEmail)}&t=${Date.now()}`,
                        { cache: "no-store" },
                    );
                    const data = await res.json();
                    if (!res.ok)
                        throw new Error(data.error || "Failed to fetch tasks");

                    const allTasks = data.tasks || [];
                    const asNeededOnly = allTasks.filter(
                        (t) => t.repeat === "As Needed",
                    );
                    console.log(
                        "🐛 Found",
                        asNeededOnly.length,
                        "As Needed tasks",
                    );

                    // Filter As Needed tasks based on onlyAssigned parameter
                    const asNeededTasks = allTasks.filter((task) => {
                        if (
                            !task ||
                            task.repeat !== "As Needed" ||
                            !task.asNeeded
                        )
                            return false;
                        if (onlyAssigned) {
                            return task.users && task.users.includes(userName); // Only show assigned tasks
                        }
                        // For non-assigned tasks, exclude private ones
                        if (task.users && task.users.includes(userName))
                            return false; // Don't show assigned tasks
                        if (task.isPrivate === true) return false; // Don't show private tasks
                        return true;
                    });

                    // Add As Needed tasks to the main task list
                    console.log(
                        "🐛 Current userTasksDiv children before adding:",
                        userTasksDiv.children.length,
                    );
                    console.log(
                        "🐛 About to add",
                        asNeededTasks.length,
                        "As Needed tasks",
                    );

                    for (const task of asNeededTasks) {
                        console.log("🐛 Adding task:", task.title);
                        const taskDiv = document.createElement("div");
                        taskDiv.className = "task-item";

                        // Style based on activation status
                        if (task.activated) {
                            // Active task - normal appearance with dashed border
                            taskDiv.style.borderColor = "var(--primary-color)";
                            taskDiv.style.borderStyle = "dashed";
                            taskDiv.style.opacity = "1";
                        } else {
                            // Inactive task - dimmed appearance
                            taskDiv.style.borderColor = "#666";
                            taskDiv.style.borderStyle = "dashed";
                            taskDiv.style.opacity = "0.6";
                            taskDiv.style.backgroundColor = "#1F1F23";
                        }

                        let taskHTML = `<strong>${task.title}</strong> <span style="font-size: 12px; color: var(--primary-color);">(As Needed)</span>`;
                        if (task.isPrivate === true) {
                            taskHTML += ` <span style="color: #ff6b6b; font-size: 12px;">🔒 Private</span>`;
                        }
                        taskHTML += `<br>`;
                        if (
                            !onlyAssigned &&
                            task.users &&
                            task.users.length > 0
                        ) {
                            taskHTML += `<em style="color: #666;">Originally assigned to: ${task.users.join(", ")}</em><br>`;
                        }

                        if (task.activated) {
                            taskHTML += `Status: Ready<br>`;
                        } else {
                            taskHTML += `Status: <span style="color: #888;">Waiting to be activated</span><br>`;
                        }

                        taskHTML += `Buzz Points: ${task.reward || 0} 🍯 (goes to completer)<br>`;
                        if (task.settings) {
                            taskHTML += `Type: ${task.settings}<br>`;
                        }

                        taskDiv.innerHTML = taskHTML;

                        // Only show finish button if task is activated and user can complete it
                        if (task.activated) {
                            let canComplete = true;
                            // Private tasks can only be completed by assigned users
                            if (
                                task.isPrivate === true &&
                                (!task.users || !task.users.includes(userName))
                            ) {
                                canComplete = false;
                            }

                            if (canComplete) {
                                const finishBtn =
                                    document.createElement("button");
                                finishBtn.className = "finished-btn";
                                finishBtn.textContent = `Complete Task (as ${userName})`;
                                finishBtn.addEventListener("click", (e) => {
                                    e.stopPropagation();
                                    if (!userName) {
                                        alert(
                                            "Error: User not identified. Please refresh the page.",
                                        );
                                        return;
                                    }
                                    finishAsNeededTask(
                                        userName,
                                        task,
                                        selectedDate,
                                    );
                                });
                                taskDiv.appendChild(finishBtn);
                            }
                        }

                        taskDiv.addEventListener("click", () =>
                            showTaskDetails(task, selectedDate),
                        );
                        userTasksDiv.appendChild(taskDiv);
                    }
                } catch (err) {
                    console.error("🔥 Failed to fetch as needed tasks:", err);
                } finally {
                    isLoadingAsNeeded = false;
                }
            }

            async function finishAsNeededTask(userName, task, selectedDate) {
                const adminEmail = localStorage.getItem("currentAdminEmail");

                console.log(
                    "🔍 finishAsNeededTask: Task will be completed by:",
                    userName,
                    "regardless of original assignment",
                );

                // Validation
                if (!userName) {
                    console.error(
                        "🔥 finishAsNeededTask: No userName provided",
                    );
                    alert(
                        "Error: User not identified. Please refresh the page.",
                    );
                    return;
                }

                try {
                    const response = await fetch(
                        "https://beemazing1.onrender.com/api/complete-as-needed-task",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                adminEmail: adminEmail,
                                taskTitle: task.title,
                                user: userName, // Who is actually completing the task
                                date: selectedDate,
                                isPrivate: task.isPrivate, // Let backend enforce private task rules
                            }),
                        },
                    );

                    const data = await response.json();
                    if (!response.ok) {
                        console.error(
                            "🔥 finishAsNeededTask: Server error details:",
                            {
                                status: response.status,
                                statusText: response.statusText,
                                error: data.error,
                                task: task.title,
                                completer: userName,
                                isPrivate: task.isPrivate,
                            },
                        );
                        throw new Error(
                            data.error || "Failed to complete task",
                        );
                    }

                    // Show success popup and trigger honey rain
                    triggerHoneyRain(task.reward || 0);

                    // Reload the correct tab to reflect changes
                    const myTasksTab = document.getElementById("myTasks");
                    const allTasksTab = document.getElementById("allTasks");

                    if (!myTasksTab.classList.contains("hidden")) {
                        loadUserTasks(userName, selectedDate);
                    } else if (!allTasksTab.classList.contains("hidden")) {
                        loadAllTasks(userName, selectedDate);
                    }
                    loadUserReward(userName);
                } catch (error) {
                    console.error("Error completing as needed task:", error);
                    alert(`Error: ${error.message}`);
                }
            }

            // addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////

            //---------

            async function loadUserReward(userName) {
                const adminEmail = localStorage.getItem("currentAdminEmail");
                try {
                    const response = await fetch(
                        `https://beemazing1.onrender.com/api/rewards?adminEmail=${encodeURIComponent(adminEmail)}`,
                    );
                    const data = await response.json();
                    if (!response.ok)
                        throw new Error(
                            data.error || "Failed to fetch rewards",
                        );
                    const rewards = data.rewards || {};
                    const userReward = rewards[userName] || 0;
                    const rewardElement =
                        document.getElementById("rewardAmount");
                    if (rewardElement) {
                        rewardElement.textContent = userReward;
                    }
                } catch (err) {
                    console.error("Error loading user reward:", err);
                }
            }

            function triggerHoneyRain(rewardAmount) {
                for (let i = 0; i < 50; i++) {
                    const drop = document.createElement("div");
                    drop.className = "honey-drop";
                    drop.style.left = `${Math.random() * 100}vw`;
                    drop.style.animationDelay = `${Math.random() * 0.5}s`;
                    document.body.appendChild(drop);
                    setTimeout(() => drop.remove(), 2000);
                }
                const popup = document.createElement("div");
                popup.className = "reward-popup";
                popup.textContent = `+${rewardAmount} 🍯`;
                document.body.appendChild(popup);
                setTimeout(() => {
                    const rewardElement =
                        document.getElementById("rewardAmount");
                    rewardElement.classList.add("pulse");
                    setTimeout(() => {
                        rewardElement.classList.remove("pulse");
                        popup.remove();
                    }, 1000);
                }, 1000);
            }

            //---------

            // addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////

            function showTaskDetails(
                task,
                selectedDate = new Date().toLocaleDateString("sv-SE"),
            ) {
                const isRotation = task.settings?.includes("Rotation");
                let turnData;

                if (isRotation) {
                    if (typeof mixedTurnData !== "function") {
                        console.error(
                            `mixedTurnData is not defined for task: ${task.title}`,
                        );
                        turnData = {
                            turns: [],
                            completedCount: 0,
                            requiredTimes: 1,
                        };
                    } else {
                        turnData = mixedTurnData(task, selectedDate);
                    }
                } else {
                    if (typeof individualTurnData !== "function") {
                        console.error(
                            `individualTurnData is not defined for task: ${task.title}`,
                        );
                        turnData = {
                            turns: [],
                            completedCount: 0,
                            requiredTimes: 1,
                        };
                    } else {
                        try {
                            turnData = individualTurnData(task, selectedDate);
                        } catch (error) {
                            console.error(
                                `Error in individualTurnData for task ${task.title}:`,
                                error,
                            );
                            turnData = {
                                turns: [],
                                completedCount: 0,
                                requiredTimes: 1,
                            };
                        }
                    }
                }

                const userTurns = turnData.turns.filter(
                    (turn) => turn.user === userName,
                );
                const userTotal = userTurns.reduce(
                    (sum, turn) =>
                        sum + (turn.isCompleted || turn.isPending ? 1 : 0),
                    0,
                );
                const userRequiredTimes = isRotation
                    ? userTurns.length
                    : turnData.requiredTimes;

                let modalHTML = `<strong>Title:</strong> ${task.title}<br>`;
                if (task.notes)
                    modalHTML += `<strong>Notes:</strong> ${task.notes}<br>`;
                if (task.room)
                    modalHTML += `<strong>Room:</strong> ${task.room}<br>`;
                modalHTML += `<strong>Reward:</strong> ${task.reward || 0} 🍯<br>`;
                modalHTML += `<strong>Repeat:</strong> ${task.repeat || "Daily"}<br>`;
                const [fromDate, toDate] = (task.date || "").split(" to ");
                if (!fromDate) {
                    modalHTML += `<strong>Date:</strong> Unknown<br>`;
                } else if (
                    !toDate ||
                    toDate === "3000-01-01" ||
                    toDate === fromDate
                ) {
                    modalHTML += `<strong>Date:</strong> ${fromDate}<br>`;
                } else {
                    modalHTML += `<strong>Date:</strong> ${fromDate} to ${toDate}<br>`;
                }

                modalHTML += `<strong>Originally Assigned To:</strong> ${task.users.join(", ")}<br>`;
                modalHTML += `<strong>Privacy:</strong> ${task.isPrivate === true ? "🔒 Private (hidden from other users)" : "🌐 Public (visible to all users)"}<br>`;
                modalHTML += `<strong>Can Be Completed By:</strong> ${task.isPrivate === true ? "Only assigned users" : "Anyone 🐝"}<br>`;
                modalHTML += `<strong>Buzz Points Go To:</strong> Whoever completes it<br>`;

                if (isRotation) {
                    modalHTML += `<strong>Rotation:</strong> Yes<br>`;
                    const activeTurn = turnData.turns.find(
                        (turn) => !turn.isCompleted && !turn.isPending,
                    );
                    if (activeTurn) {
                        const nextTurnIndex =
                            (activeTurn.index + 1) % task.users.length;
                        const nextUser =
                            turnData.turns.find(
                                (t) => t.index === nextTurnIndex,
                            )?.user ||
                            task.users[nextTurnIndex] ||
                            "—";
                        modalHTML += `<strong>Current Turn:</strong> ${activeTurn.user}<br>`;
                        modalHTML += `<strong>Next:</strong> ${nextUser}<br>`;
                    } else {
                        modalHTML += `<strong>All turns completed!</strong><br>`;
                    }
                }

                const totalCompleted = turnData.turns.reduce(
                    (sum, turn) =>
                        sum + (turn.isCompleted || turn.isPending ? 1 : 0),
                    0,
                );
                const totalRequired = isRotation
                    ? turnData.turns.length
                    : turnData.requiredTimes * task.users.length;

                if (task.users.includes(userName)) {
                    modalHTML += `<strong>Your Progress:</strong> ${userTotal}/${userRequiredTimes}<br>`;
                } else {
                    modalHTML += `<strong>Your Progress:</strong> 0/0 (not originally assigned)<br>`;
                }
                modalHTML += `<strong>Total Progress:</strong> ${totalCompleted}/${totalRequired}<br>`;

                const modal = document.createElement("div");
                modal.className = "modal";
                modal.innerHTML = `<div class="modal-content">${modalHTML}</div>`;
                document.body.appendChild(modal);

                modal.addEventListener("click", (e) => {
                    if (e.target.classList.contains("modal")) {
                        modal.remove();
                    }
                });
            }

            // addtasks.html Settings: Rotation //////////////////////////////////////////////////////////////////////////////////////////

            let monthOffset = 0;

            function generateScrollableDates(monthOffset = 0) {
                const container = document.getElementById("dayScrollContainer");
                container.innerHTML = "";

                const today = new Date();
                today.setDate(1);
                today.setMonth(today.getMonth() + monthOffset);

                const currentMonth = today.getMonth();
                const currentYear = today.getFullYear();
                const daysInMonth = new Date(
                    currentYear,
                    currentMonth + 1,
                    0,
                ).getDate();

                document.getElementById("monthLabel").textContent =
                    today.toLocaleDateString(undefined, {
                        month: "long",
                        year: "numeric",
                    });

                const urlParams = new URLSearchParams(window.location.search);
                const userName = urlParams.get("user");
                const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, "0")}-${String(today.getDate()).padStart(2, "0")}`;
                const dayAbbreviations = [
                    "S",
                    "Mo",
                    "Tu",
                    "We",
                    "Th",
                    "Fr",
                    "St",
                ];

                for (let i = 1; i <= daysInMonth; i++) {
                    const date = new Date(currentYear, currentMonth, i);
                    const dayOfWeek = dayAbbreviations[date.getDay()]; // Get day abbreviation
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;

                    const containerDiv = document.createElement("div");
                    containerDiv.className = "day-container";

                    const label = document.createElement("span");
                    label.className = "day-label";
                    label.textContent = dayOfWeek;

                    const btn = document.createElement("div");
                    btn.className = "day";
                    btn.textContent = i;
                    btn.dataset.date = dateStr;

                    btn.addEventListener("click", () => {
                        document
                            .querySelectorAll(".day")
                            .forEach((d) => d.classList.remove("selected"));
                        btn.classList.add("selected");

                        // Load tasks for the currently active tab
                        const myTasksTab = document.getElementById("myTasks");
                        const allTasksTab = document.getElementById("allTasks");

                        if (!myTasksTab.classList.contains("hidden")) {
                            loadUserTasks(userName, dateStr);
                        } else if (!allTasksTab.classList.contains("hidden")) {
                            loadAllTasks(userName, dateStr);
                        }
                    });

                    const now = new Date();
                    const nowStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")}`;
                    if (dateStr === nowStr) {
                        btn.classList.add("selected");
                        // Load tasks for the currently active tab on page load
                        const myTasksTab = document.getElementById("myTasks");
                        const allTasksTab = document.getElementById("allTasks");

                        if (!myTasksTab.classList.contains("hidden")) {
                            loadUserTasks(userName, dateStr);
                        } else if (!allTasksTab.classList.contains("hidden")) {
                            loadAllTasks(userName, dateStr);
                        }
                    }

                    containerDiv.appendChild(label);
                    containerDiv.appendChild(btn);
                    container.appendChild(containerDiv);
                }

                setTimeout(() => {
                    const selected = document.querySelector(".day.selected");
                    if (selected) {
                        selected.scrollIntoView({
                            behavior: "smooth",
                            inline: "center",
                        });
                    }
                }, 50);
            }

            document
                .getElementById("prevMonth")
                .addEventListener("click", () => {
                    monthOffset--;
                    generateScrollableDates(monthOffset);
                });

            document
                .getElementById("nextMonth")
                .addEventListener("click", () => {
                    monthOffset++;
                    generateScrollableDates(monthOffset);
                });

            document
                .getElementById("scrollLeft")
                .addEventListener("click", () => {
                    document.getElementById("dayScrollContainer").scrollBy({
                        left: -200,
                        behavior: "smooth",
                    });
                });

            document
                .getElementById("scrollRight")
                .addEventListener("click", () => {
                    document.getElementById("dayScrollContainer").scrollBy({
                        left: 200,
                        behavior: "smooth",
                    });
                });

            function adjustContentTop() {
                const header = document.querySelector(".date-header");
                const content = document.querySelector(".content");
                if (header && content) {
                    const headerHeight = header.getBoundingClientRect().height;
                    content.style.top = `${headerHeight}px`;
                }
            }

            function showAdminControlsIfNeeded() {
                const urlParams = new URLSearchParams(window.location.search);
                const currentUser = urlParams.get("user");
                const allUserData =
                    JSON.parse(localStorage.getItem("userData")) || {};
                const currentAdmin = localStorage.getItem("currentAdminEmail");
                const userPermissions =
                    allUserData[currentAdmin]?.permissions || {};
                const isUserAdmin = userPermissions[currentUser] === "Admin";
                const isLoggedInAsAdmin =
                    localStorage.getItem("isAdmin") === "true";
                const changePasswordBtn =
                    document.getElementById("changePasswordBtn");

                if (isUserAdmin && isLoggedInAsAdmin) {
                    changePasswordBtn.style.display = "inline-block";
                    if (!changePasswordBtn.dataset.listenersAdded) {
                        changePasswordBtn.addEventListener("click", () => {
                            const modal = document.getElementById(
                                "changePasswordModal",
                            );
                            modal.style.display = "flex";
                            document.getElementById("newAdminPassword").value =
                                "";
                            document.getElementById("newAdminPassword").focus();
                        });

                        document
                            .getElementById("confirmChangePasswordBtn")
                            .addEventListener("click", () => {
                                const newPassword = document
                                    .getElementById("newAdminPassword")
                                    .value.trim();
                                if (newPassword.length < 4) {
                                    alert(
                                        "Password must be at least 4 characters.",
                                    );
                                    return;
                                }
                                localStorage.setItem(
                                    "adminPassword",
                                    newPassword,
                                );
                                alert("Admin password updated!");
                                document.getElementById(
                                    "changePasswordModal",
                                ).style.display = "none";
                            });

                        document
                            .getElementById("changePasswordModal")
                            .addEventListener("click", (e) => {
                                if (e.target.id === "changePasswordModal") {
                                    document.getElementById(
                                        "changePasswordModal",
                                    ).style.display = "none";
                                }
                            });

                        changePasswordBtn.dataset.listenersAdded = "true";
                    }
                } else {
                    if (changePasswordBtn)
                        changePasswordBtn.style.display = "none";
                }
            }

            // for finish task button video preview
            async function fetchAvatarPath(userName) {
                const adminEmail = localStorage.getItem("currentAdminEmail");
                try {
                    const res = await fetch(
                        `https://beemazing1.onrender.com/get-avatar?adminEmail=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`,
                    );
                    const data = await res.json();
                    if (!data.success || !data.avatar) {
                        throw new Error(data.message || "Avatar not found");
                    }
                    return data.avatar; // returns full path like "/BeeMazing-A1/shared/Avatars/scorpion1.png"
                } catch (err) {
                    console.warn("Could not fetch avatar path:", err);
                    return null;
                }
            }

            // for finish task button video preview

            async function finishTask(currentUser, task, selectedDate) {
                const today =
                    selectedDate || new Date().toISOString().split("T")[0];
                const adminEmail = localStorage.getItem("currentAdminEmail");
                const button = event.target;
                button.disabled = true;

                console.log("🔍 finishTask: Starting submission", {
                    currentUser,
                    taskTitle: task.title,
                    selectedDate: today,
                    adminEmail,
                });

                // Validation
                if (!currentUser) {
                    console.error("🔥 finishTask: No currentUser provided");
                    button.disabled = false;
                    alert(
                        "Error: User not identified. Please refresh the page.",
                    );
                    return;
                }

                // Try to fetch avatar and derive video path (skip if not available)
                let videoPath = null;
                try {
                    const avatarPath = await fetchAvatarPath(currentUser);
                    const avatarId = avatarPath?.match(/\/([^/]+)\.png$/)?.[1];
                    videoPath = avatarId
                        ? `/BeeMazing-A1/shared/Avatars/Selected/Preview/${avatarId}.mp4`
                        : null;
                } catch (err) {
                    // Avatar not available - continue without video preview
                }

                // Show video overlay if videoPath exists
                if (videoPath) {
                    const overlay = document.getElementById("taskVideoOverlay");
                    const videoEl = document.getElementById("taskAvatarVideo");
                    if (overlay && videoEl) {
                        overlay.style.display = "flex";
                        videoEl.src = videoPath;
                        videoEl.muted = false;
                        videoEl.load();
                        videoEl
                            .play()
                            .catch((err) =>
                                console.warn(
                                    "Could not auto-play preview:",
                                    err,
                                ),
                            );
                        videoEl.onended = () => {
                            overlay.style.display = "none";
                            videoEl.src = "";
                        };
                    }
                }

                // Show submission popup
                const popup = document.createElement("div");
                popup.className = "reward-popup";
                popup.textContent = `Submitting Task...`;
                document.body.appendChild(popup);

                try {
                    const response = await fetch(
                        "https://beemazing1.onrender.com/api/complete-task",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                adminEmail,
                                taskTitle: task.title.trim(),
                                user: currentUser, // Who is actually completing the task
                                date: today,
                                isPrivate: task.isPrivate, // Let backend enforce private task rules
                            }),
                        },
                    );
                    const data = await response.json();
                    if (!response.ok) {
                        console.error("🔥 finishTask: Server error details:", {
                            status: response.status,
                            statusText: response.statusText,
                            error: data.error,
                            task: task.title,
                            completer: currentUser,
                            isPrivate: task.isPrivate,
                        });
                        throw new Error(
                            data.error || `HTTP error ${response.status}`,
                        );
                    }

                    console.log("✅ finishTask: Task submitted", data);
                    popup.textContent = `Task Submitted by ${currentUser}! Waiting for Parent Review`;

                    // Update the specific task's turn display immediately
                    const taskItems = document.querySelectorAll(".task-item");
                    taskItems.forEach((taskItem) => {
                        if (
                            taskItem.querySelector("strong").textContent ===
                            task.title
                        ) {
                            const isRotation =
                                task.settings?.includes("Rotation");
                            if (
                                isRotation &&
                                data.currentTurnIndex !== undefined &&
                                data.nextUser
                            ) {
                                // Update turn information
                                let turnHTML = `<strong>${task.title}</strong><br>`;
                                if (data.nextUser !== "—") {
                                    const nextTurnIndex =
                                        (data.currentTurnIndex + 1) %
                                        task.users.length;
                                    const nextNextUser =
                                        task.users[nextTurnIndex] || "—";
                                    turnHTML += `Turn: ${data.nextUser}<br>Next: ${nextNextUser}<br>`;
                                } else {
                                    turnHTML += `<span style="color: green;">Turn: All done!</span><br>`;
                                }
                                turnHTML += `Buzz Points: ${task.reward || 0} 🍯<br>`;
                                // Recalculate progress
                                const turnData = mixedTurnData(task, today);
                                const userTurns = turnData.turns.filter(
                                    (turn) => turn.user === currentUser,
                                );
                                const userTotal = userTurns.reduce(
                                    (sum, turn) =>
                                        sum +
                                        (turn.isCompleted || turn.isPending
                                            ? 1
                                            : 0),
                                    0,
                                );
                                const userRequiredTimes = userTurns.length;
                                turnHTML += `Progress: ${userTotal}/${userRequiredTimes}<br>`;
                                taskItem.innerHTML = turnHTML;

                                // Reattach the Finish Task button if still applicable
                                const isToday =
                                    today ===
                                    new Date().toLocaleDateString("sv-SE");
                                let canFinish = false;
                                if (isToday && userTotal < userRequiredTimes) {
                                    const activeTurn = turnData.turns.find(
                                        (turn) =>
                                            !turn.isCompleted &&
                                            !turn.isPending,
                                    );
                                    canFinish =
                                        activeTurn?.user === currentUser;
                                }
                                if (canFinish) {
                                    const finishBtn =
                                        document.createElement("button");
                                    finishBtn.className = "finished-btn";
                                    finishBtn.textContent = "Finish Task";
                                    finishBtn.addEventListener("click", (e) => {
                                        e.stopPropagation();
                                        finishTask(currentUser, task, today);
                                    });
                                    taskItem.appendChild(finishBtn);
                                }
                            }
                        }
                    });

                    setTimeout(() => {
                        popup.remove();
                        // Refresh the currently active tab
                        const myTasksTab = document.getElementById("myTasks");
                        const allTasksTab = document.getElementById("allTasks");

                        console.log(
                            "🔍 finishTask: Refreshing tabs after completion",
                            {
                                myTasksHidden:
                                    myTasksTab.classList.contains("hidden"),
                                allTasksHidden:
                                    allTasksTab.classList.contains("hidden"),
                                taskTitle: task.title,
                            },
                        );

                        if (!myTasksTab.classList.contains("hidden")) {
                            console.log("🔍 finishTask: Refreshing My Tasks");
                            // Force refresh with cache busting to ensure fresh data
                            setTimeout(() => {
                                loadUserTasks(currentUser, today);
                            }, 100);
                        } else if (!allTasksTab.classList.contains("hidden")) {
                            console.log("🔍 finishTask: Refreshing All Tasks");
                            console.log(
                                "🔍 finishTask: Refreshing All Tasks with params",
                                {
                                    currentUser,
                                    today,
                                    completedTask: task.title,
                                },
                            );
                            // Force refresh with cache busting to ensure fresh data
                            setTimeout(() => {
                                loadAllTasks(currentUser, today);
                            }, 100);
                        }
                    }, 2000);
                } catch (err) {
                    console.error("🔥 finishTask: Error submitting task", {
                        error: err,
                        message: err.message,
                        task: task.title,
                        completer: currentUser,
                        isPrivate: task.isPrivate,
                    });
                    popup.textContent = `Error: ${err.message}`;
                    popup.style.color = "red";
                    setTimeout(() => {
                        popup.remove();
                        button.disabled = false;
                    }, 3000);
                }
            }

            window.addEventListener("resize", adjustContentTop);
            window.addEventListener("load", adjustContentTop);
            window.addEventListener("storage", (event) => {
                if (
                    event.key === "isAdmin" ||
                    event.key === "userPermissions"
                ) {
                    showAdminControlsIfNeeded();
                }
            });

            // Auto-refresh functionality removed - users can manually refresh to check approval status

            async function loadNotifications(userName) {
                const adminEmail = localStorage.getItem("currentAdminEmail");
                const offerHelpBadge =
                    document.getElementById("offerHelpBadge");
                const needHelpBadge = document.getElementById("needHelpBadge");
                if (!adminEmail || !userName) {
                    console.error(
                        "loadNotifications: Missing adminEmail or userName",
                    );
                    if (offerHelpBadge) offerHelpBadge.style.display = "none";
                    if (needHelpBadge) needHelpBadge.style.display = "none";
                    return;
                }
                try {
                    const res = await fetch(
                        `https://beemazing1.onrender.com/api/notifications?adminEmail=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}&t=${Date.now()}`,
                        {
                            method: "GET",
                            headers: { "Content-Type": "application/json" },
                        },
                    );
                    const data = await res.json();
                    console.log("Load notifications response:", data);
                    if (!res.ok) {
                        throw new Error(
                            data.error || "Failed to fetch notifications",
                        );
                    }
                    const notifications = data.notifications || [];
                    if (notifications.length === 0) {
                        if (offerHelpBadge)
                            offerHelpBadge.style.display = "none";
                        if (needHelpBadge) needHelpBadge.style.display = "none";
                        return;
                    }
                    const offerHelpNotifications = notifications.filter(
                        (n) => n.offerType === "offerHelp",
                    );
                    const needHelpNotifications = notifications.filter(
                        (n) => n.offerType === "needHelp",
                    );
                    const offerHelpCount = offerHelpNotifications.reduce(
                        (sum, n) => sum + n.taskCount,
                        0,
                    );
                    const needHelpCount = needHelpNotifications.reduce(
                        (sum, n) => sum + n.taskCount,
                        0,
                    );
                    if (offerHelpBadge) {
                        if (offerHelpCount > 0) {
                            offerHelpBadge.textContent = `${offerHelpCount}`;
                            offerHelpBadge.style.display = "block";
                        } else {
                            offerHelpBadge.style.display = "none";
                        }
                    }
                    if (needHelpBadge) {
                        if (needHelpCount > 0) {
                            needHelpBadge.textContent = `${needHelpCount}`;
                            needHelpBadge.style.display = "block";
                        } else {
                            needHelpBadge.style.display = "none";
                        }
                    }
                } catch (err) {
                    console.error("Failed to load notifications:", err.message);
                    if (offerHelpBadge) offerHelpBadge.style.display = "none";
                    if (needHelpBadge) needHelpBadge.style.display = "none";
                }
            }
        </script>

        <script src="/BeeMazing-A1/shared/avatar-system.js"></script>

        <div
            id="chestVideoOverlay"
            style="
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(10, 10, 10, 0.959); /* darkened more */
                backdrop-filter: blur(5px);
                z-index: 2000;
                justify-content: center;
                align-items: center;
                overflow: hidden;
            "
        >
            <video
                id="chestVideo"
                autoplay
                muted
                playsinline
                style="
                    max-width: 90vw;
                    max-height: 90vh;
                    border-radius: 20px;
                    box-shadow: 0 0 30px rgba(255, 193, 7, 0.6);
                    background: #1a1a1a;
                    display: block;
                "
            >
                <source
                    src="/BeeMazing-A1/mobile/4-Market/LuckyChest/Chest_fixed.mp4"
                    type="video/mp4"
                />
                Your browser does not support the video tag.
            </video>
            <audio id="chestUnlockSound" preload="auto">
                <source
                    src="/BeeMazing-A1/mobile/4-Market/LuckyChest/ChestUnlock.mp3"
                    type="audio/mp3"
                />
                Your browser does not support the audio element.
            </audio>
        </div>

        <div
            id="taskVideoOverlay"
            style="
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.95);
                z-index: 9999;
                justify-content: center;
                align-items: center;
                flex-direction: column;
            "
        >
            <h1
                style="
                    color: gold;
                    font-size: 36px;
                    margin-bottom: 20px;
                    font-family: Orbitron, sans-serif;
                "
            >
                Well Done!
            </h1>
            <video
                id="taskAvatarVideo"
                autoplay
                playsinline
                style="
                    max-width: 90vw;
                    max-height: 70vh;
                    border-radius: 20px;
                    box-shadow: 0 0 30px gold;
                    background: black;
                "
            ></video>
        </div>
    </body>
</html>
