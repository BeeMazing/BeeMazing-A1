<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Admin Task Review</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">







  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

:root {
    --primary-color: #FFC107;
    --secondary-color: #212121;
    --accent-color: #FFFFFF;
    --light-bg: #1E1F26;
    --text-color: #FFFFFF;
    --footer-height: 70px;
}


    body {
      font-family: 'Poppins', sans-serif;
      background-color: #1E1F26;
      color: #FFFFFF;
      margin: 0;
      padding: 0;
    }
    .date-header {
      background: #212121;
      padding: 10px;
      position: sticky;
      top: 0;
      z-index: 50;
    }
    .month-nav {
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 18px;
        font-weight: bold;
        width: 100%;
        padding: 5px 0;
    }
    .month-nav button {
      margin: 0 10px;
      background: #FFC107;
      color: #212121;
      border: none;
      padding: 5px 10px;
      border-radius: 6px;
      cursor: pointer;
    }
    .month-nav button:hover {
      background: #FFD54F;
    }
    .day-scroll-wrapper {
      display: flex;
      align-items: center;
      padding: 5px 0;
      overflow: hidden;
    }
    .scroll-btn {
      background: #212121;
      color: #fff;
      border: none;
      font-size: 20px;
      padding: 5px 10px;
      cursor: pointer;
    }
    .day-scroll {
      display: flex;
      overflow-x: auto;
      gap: 8px;
      padding: 5px 10px;
    }
    .day {
      min-width: 38px;
      height: 38px;
      line-height: 38px;
      text-align: center;
      border-radius: 50%;
      background: #333;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
    }
    .day.selected {
      background: #FFC107;
      color: #212121;
    }
    .task-entry {
      background: #2A2B32;
      border: 2px solid #444754;
      border-radius: 12px;
      padding: 16px;
      margin: 15px;
      cursor: pointer;
    }
    .task-entry:hover {
      background: #333540;
    }
    .task-title {
      margin: 0;
      font-weight: bold;
      display: flex;
      align-items: center;
    }
    .notification-bubble {
      background: #D32F2F;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      line-height: 20px;
      text-align: center;
      font-size: 12px;
      margin-left: 10px;
    }
    .task-details {
      display: none;
      margin-top: 10px;
    }
    .task-details.show {
      display: block;
    }
    .turn-entry {
      background: #3A3B44;
      border-radius: 8px;
      padding: 10px;
      margin: 5px 0;
      cursor: move;
      border: 2px solid transparent;
    }
    .turn-entry.dragging {
      opacity: 0.7;
      border: 2px solid #FFC107;
    }
    .turn-entry.drag-over {
      border: 2px dashed #FFC107;
    }
    .turn-entry p {
      margin: 5px 0;
    }
    .accept-btn, .decline-btn, .replace-btn, .revert-btn {
      margin-top: 10px;
      padding: 8px 14px;
      font-weight: bold;
      border-radius: 6px;
      border: none;
      cursor: pointer;
    }
    .accept-btn {
      background-color: #4CAF50;
      color: white;
      margin-right: 10px;
    }
    .decline-btn {
      background-color: #D32F2F;
      color: white;
    }
    .replace-btn {
      background-color: #2196F3;
      color: white;
      margin-right: 10px;
    }
    .revert-btn {
      background-color: #FF9800;
      color: white;
    }
    select {
      padding: 8px;
      border-radius: 6px;
      background: #333;
      color: #fff;
      border: 1px solid #444754;
      margin-top: 10px;
    }
    .day-scroll::-webkit-scrollbar {
      display: none;
    }
    .day-scroll {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }


    .footer {
    position: fixed;
    bottom: 0;
    width: 100%;
    display: flex;
    justify-content: space-around;
    background: var(--secondary-color);
    padding: 10px 0;
    box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
    z-index: 100;
    height: var(--footer-height);
}
.footer a {
    text-decoration: none;
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.3s ease;
}
.footer a:hover {
    transform: scale(1.1);
}
.footer-icon img {
    width: 40px;
    height: 40px;
    filter: invert(100%) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
}
.footer a.active img {
    filter: invert(77%) sepia(88%) saturate(900%) hue-rotate(0deg)
        brightness(100%) contrast(100%) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2)) !important;
}
.footer-icon span {
    font-size: 12px;
    margin-top: 5px;
    font-weight: 600;
}
.footer a.active span {
    color: var(--primary-color);
}
@media (max-width: 600px) {
    .footer-icon img {
        width: 35px;
        height: 35px;
    }
}











/* Menu Toggle Button */
.menu-btn {
        position: fixed;
        top: 1px;
        left: 10px;
        background: var(--secondary-color);
        border: none;
        color: var(--text-color);
        font-size: 24px;
        cursor: pointer;
        padding: 8px;
        z-index: 202; /* Above overlay */
        transition: color 0.3s ease, background 0.3s ease;
    }
    .menu-btn:hover {
        color: var(--primary-color);
        background: var(--light-bg);
    }

    /* Side Menu */
    .side-menu {
        position: fixed;
        top: 0;
        left: 0;
        width: 250px;
        height: 100%;
        background: var(--secondary-color);
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
        transform: translateX(-100%);
        transition: transform 0.3s ease-in-out;
        z-index: 201; /* Above overlay, below menu-btn */
        display: flex;
        flex-direction: column;
    }
    .side-menu.open {
        transform: translateX(0);
    }


/* Overlay */
.overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5); /* Semi-transparent black */
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        z-index: 200; /* Below menu and menu-btn */
    }
    .overlay.active {
        opacity: 1;
        visibility: visible;
    }

    /* Content Blur */
    .content-blur {
        transition: filter 0.3s ease;
    }
    body.menu-open .content-blur {
        filter: blur(3px); /* Apply blur when menu is open */
    }







.menu-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    background: var(--light-bg);
    border-bottom: 1px solid #444754;
}
.menu-header h2 {
    font-size: 18px;
    color: var(--text-color);
}
.close-btn {
    background: none;
    border: none;
    color: var(--text-color);
    font-size: 24px;
    cursor: pointer;
    padding: 5px;
}
.close-btn:hover {
    color: var(--primary-color);
}
.menu-items {
    list-style: none;
    padding: 0;
    margin: 0;
    flex-grow: 1;
}
.menu-items li {
    border-bottom: 1px solid #444754;
}
.menu-link {
    display: block;
    padding: 15px 20px;
    color: var(--text-color);
    text-decoration: none;
    font-size: 16px;
    transition: background 0.3s ease, color 0.3s ease;
}
.menu-link:hover {
    background: var(--light-bg);
    color: var(--primary-color);
}

/* Ensure content shifts when menu is open */
body.menu-open {
    overflow: hidden;
}

/* Responsive adjustments */
@media (max-width: 600px) {
    .side-menu {
        width: 200px;
    }
    .menu-link {
        font-size: 14px;
        padding: 12px 15px;
    }
    .menu-header h2 {
        font-size: 16px;
    }
}
  </style>





</head>
<body>
    <body>
        <nav id="sideMenu" class="side-menu">
            <div class="menu-header">
                <h2>Admin Menu</h2>
                <button id="closeMenu" class="close-btn" aria-label="Close Menu">×</button>
            </div>
            <ul class="menu-items">
                <li><a href="#" id="taskSettingsLink" class="menu-link">Create a Task</a></li>
                <li><a href="#" id="marketDashLink" class="menu-link">Create a Reward</a></li>
                <li><a href="#" id="userManagementLink" class="menu-link">User Management</a></li>
                <li><a href="#" id="logoutLink" class="menu-link">Logout</a></li>
            </ul>
        </nav>
        <div id="overlay" class="overlay"></div>
        <div class="date-header">
            <button id="menuToggle" class="menu-btn" aria-label="Toggle Menu">☰</button>
            <div class="month-nav">
                <button id="prevMonth"><</button>
                <span id="monthLabel">Month</span>
                <button id="nextMonth">></button>
            </div>
            <div class="day-scroll-wrapper">
                <button class="scroll-btn" id="scrollLeft"><</button>
                <div class="day-scroll" id="dayScrollContainer"></div>
                <button class="scroll-btn" id="scrollRight">></button>
            </div>
        </div>

  <div id="taskContainer">Loading tasks...</div>





  <div class="footer">
    <a href="#" id="homeButton" class="footer-icon active" aria-label="Home">
        <img src="/BeeMazing-Y1/mobile/1-Home/HomeBtn.png" alt="Home" />
        <span>Home</span>
    </a>
    <a href="#" id="profileButton" class="footer-icon" aria-label="Profile">
        <img src="/BeeMazing-Y1/mobile/1-Home/ProfileBtn.png" alt="Profile" />
        <span>Profile</span>
    </a>
    <a href="#" id="marketButton" class="footer-icon" aria-label="Market">
        <img src="/BeeMazing-Y1/mobile/1-Home/MarketBtn.png" alt="Market" />
        <span>Market</span>
    </a>
</div>



  <script>





// Dynamically set footer button links and active state
// Dynamically set footer button links and active state
const urlParams = new URLSearchParams(window.location.search);
const adminEmail = urlParams.get('admin') || localStorage.getItem('currentAdminEmail') || '';
const userName = urlParams.get('user') || '';
const basePath = '/BeeMazing-Y1/mobile/2-UserProfiles';

const homeButton = document.getElementById('homeButton');
const profileButton = document.getElementById('profileButton');
const marketButton = document.getElementById('marketButton');

if (adminEmail && userName) {
    homeButton.href = `${basePath}/userAdmin.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
    profileButton.href = `${basePath}/users.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
    marketButton.href = `${basePath}/usermarket.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
}

// Set active state
document.querySelectorAll('.footer a').forEach(link => {
    const currentPath = window.location.pathname.replace(/\/$/, '');
    const linkPath = new URL(link.href, window.location.origin).pathname.replace(/\/$/, '');
    if (currentPath === linkPath) {
        link.classList.add('active');
    } else {
        link.classList.remove('active');
    }
});


// Side Menu Toggle
const menuToggle = document.getElementById('menuToggle');
    const sideMenu = document.getElementById('sideMenu');
    const closeMenu = document.getElementById('closeMenu');
    const overlay = document.getElementById('overlay');
    const contentElements = document.querySelectorAll('.date-header, #taskContainer, .footer');

    function openMenu() {
        sideMenu.classList.add('open');
        overlay.classList.add('active');
        document.body.classList.add('menu-open');
        contentElements.forEach(el => el.classList.add('content-blur'));
    }

    function closeMenuFn() {
        sideMenu.classList.remove('open');
        overlay.classList.remove('active');
        document.body.classList.remove('menu-open');
        contentElements.forEach(el => el.classList.remove('content-blur'));
    }

    menuToggle.addEventListener('click', openMenu);
    closeMenu.addEventListener('click', closeMenuFn);
    overlay.addEventListener('click', closeMenuFn);

    // Prevent clicks inside the menu from closing it
    sideMenu.addEventListener('click', (e) => {
        e.stopPropagation();
    });


// Set side menu links
const taskSettingsLink = document.getElementById('taskSettingsLink');
        const marketDashLink = document.getElementById('marketDashLink');
        const userManagementLink = document.getElementById('userManagementLink');
        const logoutLink = document.getElementById('logoutLink');

        if (adminEmail && userName) {
            taskSettingsLink.href = `/BeeMazing-Y1/mobile/3-Tasks/tasks.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
            marketDashLink.href = `/BeeMazing-Y1/mobile/4-Market/market.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
            userManagementLink.href = `/BeeMazing-Y1/mobile/1-Home/home.html?admin=${encodeURIComponent(adminEmail)}&user=${encodeURIComponent(userName)}`;
            logoutLink.href = `/BeeMazing-Y1/login.html`;
        }

        // Clear localStorage on logout to match home.html
        logoutLink.addEventListener('click', () => {
            localStorage.removeItem('isAdmin');
            localStorage.removeItem('userData');
            localStorage.removeItem('adminPassword');
            // Keep currentAdminEmail as per home.js
        });



        let selectedDate = new Date().toLocaleDateString("sv-SE");
let allUsers = [];
const expandedTasks = new Set();

async function fetchUsers() {
  try {
    const res = await fetch(`https://beemazing.onrender.com/get-users?adminEmail=${encodeURIComponent(adminEmail)}`);
    const data = await res.json();
    allUsers = data.users || [];
  } catch (err) {
    console.error("Error fetching users:", err);
  }
}




async function updateLuckyChestProgress(userName, earnedHoney) {
  const adminEmail = localStorage.getItem("currentAdminEmail");
  try {
    const response = await fetch(`https://beemazing.onrender.com/api/lucky-chests?adminEmail=${encodeURIComponent(adminEmail)}`);
    const data = await response.json();
    if (!response.ok) throw new Error(data.error || "Failed to fetch lucky chests");
    const allChests = data.luckyChests || {};
    const userChests = allChests[userName] || [];

    let updated = false;

    userChests.forEach(chest => {
      if (chest.progress < chest.requiredPoints) {
        chest.progress += earnedHoney;
        if (chest.progress > chest.requiredPoints) {
          chest.progress = chest.requiredPoints;
        }
        updated = true;
      }
    });

    if (updated) {
      allChests[userName] = userChests;
      await fetch("https://beemazing.onrender.com/api/lucky-chests", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ adminEmail, luckyChests: allChests })
      });
    }
  } catch (err) {
    console.error("Error updating lucky chest progress:", err);
  }
}








async function handleDecision(title, date, index, decision, user, event) {
  try {
    const button = event.target;
    const taskEntry = button.closest(".task-entry");
    const buttons = taskEntry.querySelectorAll("button");
    buttons.forEach(btn => {
      btn.disabled = true;
      btn.style.opacity = "0.5";
    });

    const response = await fetch("https://beemazing.onrender.com/api/review-task", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        adminEmail,
        title,
        date,
        selectedDate,
        user,
        decision
      })
    });

    const data = await response.json();
    if (!response.ok) throw new Error(data.error || "Failed to process decision");

    // If task is accepted, update Lucky Chest progress
    if (decision === "accept" && data.rewardAmount > 0) {
      await updateLuckyChestProgress(user, data.rewardAmount);
    }

    setTimeout(() => loadTasks(), 500);
  } catch (err) {
    console.error("Error processing decision:", err);
    const errorDiv = document.createElement("div");
    errorDiv.style.color = "red";
    errorDiv.textContent = `Error: ${err.message}`;
    taskEntry.appendChild(errorDiv);
    taskEntry.querySelectorAll("button").forEach(btn => {
      btn.disabled = false;
      btn.style.opacity = "1";
    });
    setTimeout(() => errorDiv.remove(), 3000);
  }
}





async function handleReplace(title, date, index, originalUser, event) {
  const taskEntry = event.target.closest(".task-entry");
  const select = taskEntry.querySelector(`#replace-select-${index}`);
  const newUser = select.value;

  // Validate new user
  if (!newUser || newUser === originalUser) {
    const errorDiv = document.createElement("div");
    errorDiv.style.color = "red";
    errorDiv.textContent = "Please select a different user.";
    taskEntry.appendChild(errorDiv);
    setTimeout(() => errorDiv.remove(), 3000);
    return;
  }
  if (!allUsers.includes(newUser)) {
    const errorDiv = document.createElement("div");
    errorDiv.style.color = "red";
    errorDiv.textContent = "Invalid user selected.";
    taskEntry.appendChild(errorDiv);
    setTimeout(() => errorDiv.remove(), 3000);
    return;
  }

  try {
    const response = await fetch("https://beemazing.onrender.com/api/replace-user", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        adminEmail,
        title,
        date,
        selectedDate,
        index: parseInt(index),
        originalUser,
        newUser
      })
    });

    const data = await response.json();
    if (!response.ok) throw new Error(data.error || "Failed to replace user");

    // Update UI only after server confirmation
    const turnEntry = taskEntry.querySelector(`.turn-entry[data-index="${index}"]`);
    turnEntry.querySelector("p").textContent = `Turn ${parseInt(index) + 1}: ${newUser} - Pending`;
    turnEntry.querySelector("select").value = "";
    turnEntry.dataset.user = newUser;
    setTimeout(() => loadTasks(true), 500); // Reduced delay, force retry
  } catch (err) {
    console.error("Error replacing user:", err);
    const errorDiv = document.createElement("div");
    errorDiv.style.color = "red";
    errorDiv.textContent = `Error: ${err.message}`;
    taskEntry.appendChild(errorDiv);
    setTimeout(() => errorDiv.remove(), 3000);
  }
}




async function handleRevert(title, date, index, user, event) {
  try {
    const button = event.target;
    const taskEntry = button.closest(".task-entry");
    const buttons = taskEntry.querySelectorAll("button");
    buttons.forEach(btn => {
      btn.disabled = true;
      btn.style.opacity = "0.5";
    });

    const response = await fetch("https://beemazing.onrender.com/api/revert-decision", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        adminEmail,
        title,
        date,
        selectedDate,
        user
      })
    });

    const data = await response.json();
    if (!response.ok) throw new Error(data.error || "Failed to revert decision");

    setTimeout(() => loadTasks(), 500);
  } catch (err) {
    console.error("Error reverting decision:", err);
    const errorDiv = document.createElement("div");
    errorDiv.style.color = "red";
    errorDiv.textContent = `Error: ${err.message}`;
    taskEntry.appendChild(errorDiv);
    taskEntry.querySelectorAll("button").forEach(btn => {
      btn.disabled = false;
      btn.style.opacity = "1";
    });
    setTimeout(() => errorDiv.remove(), 3000);
  }
}



async function handleReorder(title, date, newUserOrder) {
  try {
    const response = await fetch("https://beemazing.onrender.com/api/reorder-turns", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        adminEmail,
        title,
        date,
        users: newUserOrder,
        resetTempReplacement: true,
        selectedDate
      })
    });
    const data = await response.json();
    if (!response.ok) throw new Error(data.error || "Failed to reorder turns");
    setTimeout(() => loadTasks(), 500); // Reduced delay
  } catch (err) {
    console.error("Error reordering turns:", err);
    const errorDiv = document.createElement("div");
    errorDiv.style.color = "red";
    errorDiv.textContent = "Failed to reorder turns. Please try again.";
    document.getElementById("taskContainer").appendChild(errorDiv);
    setTimeout(() => errorDiv.remove(), 3000);
  }
}




async function loadTasks(retry = false, attempt = 1, maxAttempts = 3) {
  try {
    console.log(`Loading tasks for date: ${selectedDate}, attempt: ${attempt}`); // Debug
    const res = await fetch(`https://beemazing.onrender.com/get-tasks?adminEmail=${encodeURIComponent(adminEmail)}&t=${Date.now()}`, {
      cache: "no-store"
    });
    if (!res.ok) throw new Error(`HTTP error ${res.status}`);
    const { tasks } = await res.json();
    console.log("All tasks received:", tasks.map(t => ({
      title: t.title,
      users: t.users,
      date: t.date,
      tempTurnReplacement: t.tempTurnReplacement,
      timesPerDay: t.timesPerDay,
      settings: t.settings
    }))); // Debug

    const container = document.getElementById("taskContainer");
    container.innerHTML = ""; // Clear UI

    const tasksByTitle = {};
    const duplicateTasks = {}; // Track duplicates
    tasks.forEach(task => {
      if (!task.title || !task.users || !task.date) {
        console.warn(`Skipping invalid task:`, task);
        return;
      }

      // Filter by date range
      const [startDateStr, endDateStr] = task.date.split(" to ");
      const startDate = new Date(startDateStr);
      const endDate = new Date(endDateStr || "3000-01-01");
      const currentDate = new Date(selectedDate);
      if (currentDate < startDate || currentDate > endDate) {
        console.log(`Skipping task ${task.title}: ${task.date} does not include ${selectedDate}`); // Debug
        return;
      }

      // Track all tasks with same title
      if (!duplicateTasks[task.title]) duplicateTasks[task.title] = [];
      duplicateTasks[task.title].push({
        date: task.date,
        users: task.users,
        tempTurnReplacement: task.tempTurnReplacement?.[selectedDate] || {},
        startDate
      });

      const existingTask = tasksByTitle[task.title];
      const currentDateRange = task.date;
      let shouldReplace = false;

      if (!existingTask) {
        shouldReplace = true;
      } else {
        const taskEntry = document.querySelector(`.task-entry[data-title="${task.title}"]`);
        const replaceDateRange = taskEntry?.dataset.date;
        if (replaceDateRange && currentDateRange === replaceDateRange) {
          shouldReplace = true;
        } else if (new Date(existingTask.startDate) < startDate) {
          shouldReplace = true;
        }
      }

      if (shouldReplace) {
        tasksByTitle[task.title] = {
          turns: [],
          pendingCount: 0,
          date: task.date,
          userOrder: task.users || [],
          settings: task.settings || "Rotation",
          startDate,
          timesPerDay: task.timesPerDay || 1
        };
      } else {
        console.warn(`Duplicate task title: ${task.title}, date: ${task.date}, keeping date: ${existingTask.date}`); // Debug
        return;
      }

      let turns = [];
      if (task.settings?.includes("Rotation")) {
        if (typeof calculateTurn !== 'function') {
          console.error(`calculateTurn is not defined for task: ${task.title}`);
          turns = [{
            user: "Error",
            repetition: 1,
            index: 0,
            date: task.date,
            isPending: false,
            isCompleted: false,
            originalUser: "Error"
          }];
        } else {
          const rotation = calculateTurn(task, selectedDate);
          const completions = (task.completions && task.completions[selectedDate]) || [];
          const pendingCompletions = (task.pendingCompletions && task.pendingCompletions[selectedDate]) || [];
          const required = task.repeat === "Daily" ? task.timesPerDay || 1 :
                          task.repeat === "Weekly" ? task.timesPerWeek || 1 :
                          task.repeat === "Monthly" ? task.timesPerMonth || 1 : 1;

          // Calculate user completion counts
          const userCompletionCounts = {};
          const userPendingCounts = {};
          completions.forEach(u => {
            userCompletionCounts[u] = (userCompletionCounts[u] || 0) + 1;
          });
          pendingCompletions.forEach(u => {
            userPendingCounts[u] = (userPendingCounts[u] || 0) + 1;
          });

          // Generate turns using calculateTurn's logic
          const totalCompletions = rotation.completedCount;
          const assignedUsers = rotation.userOrder;
          for (let i = 0; i < required; i++) {
            const userIndex = (totalCompletions + i) % (assignedUsers.length || 1);
            const user = assignedUsers[userIndex] || "Unknown";
            const originalUser = task.users[userIndex % task.users.length] || user;
            let isCompleted = false;
            let isPending = false;

            if (userCompletionCounts[user] && userCompletionCounts[user] > 0) {
              isCompleted = true;
              userCompletionCounts[user]--;
            } else if (userPendingCounts[user] && userPendingCounts[user] > 0) {
              isPending = true;
              userPendingCounts[user]--;
            }

            turns.push({
              user,
              repetition: i + 1,
              index: i,
              date: task.date,
              isPending,
              isCompleted,
              originalUser
            });
          }
        }
      } else if (task.settings?.includes("Individual")) {
        if (typeof calculateIndividualProgress !== 'function') {
          console.error(`calculateIndividualProgress is not defined for task: ${task.title}`);
          turns = [{
            user: "Error",
            repetition: 1,
            index: 0,
            date: task.date,
            isPending: false,
            isCompleted: false,
            originalUser: "Error"
          }];
        } else {
          task.users.forEach((user, index) => {
            const { count, required, isComplete } = calculateIndividualProgress(task, selectedDate, user);
            const isPending = task.pendingCompletions?.[selectedDate]?.includes(user) || false;
            turns.push({
              user,
              repetition: count + 1,
              index,
              date: task.date,
              isPending,
              isCompleted: isComplete,
              originalUser: user
            });
          });
        }
      } else {
        console.warn(`Unsupported task settings for ${task.title}: ${task.settings}`);
        turns = [{
          user: "No Settings",
          repetition: 1,
          index: 0,
          date: task.date,
          isPending: false,
          isCompleted: false,
          originalUser: "No Settings"
        }];
      }

      console.log(`Turns for ${task.title} on ${selectedDate}:`, turns); // Debug

      tasksByTitle[task.title].pendingCount += turns.filter(t => t.isPending).length;
      turns.forEach((turn) => {
        tasksByTitle[task.title].turns.push({
          user: turn.user,
          repetition: turn.repetition,
          index: turn.index,
          date: turn.date,
          isPending: turn.isPending,
          isCompleted: turn.isCompleted,
          originalUser: turn.originalUser
        });
      });
    });

    if (retry && attempt < maxAttempts) {
      const hasReplacement = Object.values(tasksByTitle).some(task =>
        task.turns.some(turn => turn.user !== task.userOrder[turn.index % task.userOrder.length])
      );
      if (!hasReplacement) {
        console.warn(`Retry ${attempt}: No tempTurnReplacement found, retrying...`);
        await new Promise(resolve => setTimeout(resolve, 500));
        return loadTasks(true, attempt + 1, maxAttempts);
      }
    }

    Object.keys(tasksByTitle).forEach(title => {
      const { turns, pendingCount, date, userOrder, settings } = tasksByTitle[title];
      const div = document.createElement("div");
      div.className = "task-entry";
      div.dataset.title = title;
      div.dataset.date = date;
      div.innerHTML = `
        <h3 class="task-title">${title}${pendingCount > 0 ? `<span class="notification-bubble">${pendingCount}</span>` : ''}</h3>
        <div class="task-details${expandedTasks.has(title) ? ' show' : ''}">
          ${
            tasksByTitle[title].turns.length && turns[0].repetition !== undefined && turns[0].user !== undefined && tasksByTitle[title].turns
              ? (settings.includes("Rotation")
                ? turns.map(turn => `
                  <div class="turn-entry" draggable="true" data-index="${turn.index}" data-user="${turn.user}">
                    <p>Turn ${turn.index + 1}: ${turn.user} - ${turn.isCompleted ? 'Accepted' : turn.isPending ? 'Waiting for Review' : 'Pending'}</p>
                    ${turn.isPending && !turn.isCompleted ? `
                      <button class="accept-btn" onclick="handleDecision('${title}', '${turn.date}', ${turn.index}, 'accept', '${turn.user}', event)">Accept</button>
                      <button class="decline-btn" onclick="handleDecision('${title}', '${turn.date}', ${turn.index}, 'decline', '${turn.user}', event)">Decline</button>
                    ` : turn.isCompleted ? `
                      <button class="revert-btn" onclick="handleRevert('${title}', '${turn.date}', ${turn.index}, '${turn.user}', event)">Revert</button>
                    ` : `
                      <select id="replace-select-${turn.index}">
                        <option value="">Select User</option>
                        ${allUsers.map(u => `<option value="${u}">${u}</option>`).join('')}
                      </select>
                      <button class="replace-btn" onclick="handleReplace('${title}', '${turn.date}', ${turn.index}, '${turn.user}', event)">Replace</button>
                    `}
                  </div>
                `).join('')
                :
                userOrder.map(user => {
                  const userTurns = turns.filter(t => t.user === user);
                  return `
                    <h4 style="margin-top: 10px;">${user}</h4>
                    ${userTurns.map(turn => `
                      <div class="turn-entry" draggable="false" data-index="${turn.index}" data-user="${turn.user}">
                        <p>Attempt ${turn.repetition}: ${turn.isCompleted ? 'Accepted' : turn.isPending ? 'Waiting for Review' : 'Pending'}</p>
                        ${turn.isPending && !turn.isCompleted ? `
                          <button class="accept-btn" onclick="handleDecision('${title}', '${turn.date}', ${turn.index}, 'accept', '${turn.user}', event)">Accept</button>
                          <button class="decline-btn" onclick="handleDecision('${title}', '${turn.date}', ${turn.index}, 'decline', '${turn.user}', event)">Decline</button>
                        ` : turn.isCompleted ? `
                          <button class="revert-btn" onclick="handleRevert('${title}', '${turn.date}', ${turn.index}, '${turn.user}', event)">Revert</button>
                        ` : `
                          <select id="replace-select-${turn.index}">
                            <option value="">Select User</option>
                            ${allUsers.map(u => `<option value="${u}">${u}</option>`).join('')}
                          </select>
                          <button class="replace-btn" onclick="handleReplace('${title}', '${turn.date}', ${turn.index}, '${turn.user}', event)">Replace</button>
                        `}
                      </div>
                    `).join('')}
                  `;
                }).join(''))
              : '<p>No turns assigned.</p>'
          }
        </div>
      `;
      container.appendChild(div);

      div.querySelector(".task-title").addEventListener("click", () => {
        const details = div.querySelector(".task-details");
        details.classList.toggle("show");
        if (details.classList.contains("show")) {
          expandedTasks.add(title);
        } else {
          expandedTasks.delete(title);
        }
      });
    });

    if (!container.innerHTML) {
      container.innerHTML = "<p>No tasks for this date.</p>";
    }
  } catch (err) {
    console.error("Error loading tasks:", err);
    document.getElementById("taskContainer").innerHTML = "<p>Error loading tasks. Please try again.</p>";
  }
}



function generateScrollableDates(monthOffset = 0) {
  const container = document.getElementById("dayScrollContainer");
  container.innerHTML = "";

  const today = new Date();
  today.setDate(1);
  today.setMonth(today.getMonth() + monthOffset);

  const currentMonth = today.getMonth();
  const currentYear = today.getFullYear();
  const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();

  document.getElementById("monthLabel").textContent = today.toLocaleDateString(undefined, {
    month: 'long',
    year: 'numeric',
  });

  const todayStr = new Date().toLocaleDateString("sv-SE");

  for (let i = 1; i <= daysInMonth; i++) {
    const date = new Date(currentYear, currentMonth, i);
    const btn = document.createElement("div");
    btn.className = "day";
    btn.textContent = i;
    btn.dataset.date = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

    btn.addEventListener("click", () => {
      document.querySelectorAll(".day").forEach(d => d.classList.remove("selected"));
      btn.classList.add("selected");
      selectedDate = btn.dataset.date;
      loadTasks();
    });

    if (btn.dataset.date === todayStr) {
      btn.classList.add("selected");
      selectedDate = btn.dataset.date;
      loadTasks();
    }

    container.appendChild(btn);
  }

  setTimeout(() => {
    const selected = document.querySelector(".day.selected");
    if (selected) {
      selected.scrollIntoView({ behavior: "smooth", inline: "center" });
    }
  }, 50);
}















let monthOffset = 0;
document.getElementById("prevMonth").addEventListener("click", () => {
  monthOffset--;
  generateScrollableDates(monthOffset);
});
document.getElementById("nextMonth").addEventListener("click", () => {
  monthOffset++;
  generateScrollableDates(monthOffset);
});
document.getElementById("scrollLeft").addEventListener("click", () => {
  document.getElementById("dayScrollContainer").scrollBy({
    left: -200,
    behavior: "smooth",
  });
});
document.getElementById("scrollRight").addEventListener("click", () => {
  document.getElementById("dayScrollContainer").scrollBy({
    left: 200,
    behavior: "smooth",
  });
});

fetchUsers().then(() => generateScrollableDates());






  </script>



<script src="/BeeMazing-Y1/shared/taskrotations.js?t=${Date.now()}"></script>






</body>
</html>